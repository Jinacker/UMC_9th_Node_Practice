
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model FoodCategory
 * / ============================
 * / FOOD CATEGORY
 * / ============================
 */
export type FoodCategory = $Result.DefaultSelection<Prisma.$FoodCategoryPayload>
/**
 * Model UserFavorCategory
 * / ============================
 * / USER FAVOR CATEGORY
 * / ============================
 */
export type UserFavorCategory = $Result.DefaultSelection<Prisma.$UserFavorCategoryPayload>
/**
 * Model Region
 * / ============================
 * / REGION
 * / ============================
 */
export type Region = $Result.DefaultSelection<Prisma.$RegionPayload>
/**
 * Model Diner
 * / ============================
 * / DINER
 * / ============================
 */
export type Diner = $Result.DefaultSelection<Prisma.$DinerPayload>
/**
 * Model Mission
 * / ============================
 * / MISSION
 * / ============================
 */
export type Mission = $Result.DefaultSelection<Prisma.$MissionPayload>
/**
 * Model DinerMission
 * / ============================
 * / DINER MISSION
 * / ============================
 */
export type DinerMission = $Result.DefaultSelection<Prisma.$DinerMissionPayload>
/**
 * Model Review
 * / ============================
 * / REVIEW
 * / ============================
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model PointHistory
 * / ============================
 * / POINT HISTORY
 * / ============================
 */
export type PointHistory = $Result.DefaultSelection<Prisma.$PointHistoryPayload>
/**
 * Model MissionClearLog
 * / ============================
 * / MISSION CLEAR LOG
 * / ============================
 */
export type MissionClearLog = $Result.DefaultSelection<Prisma.$MissionClearLogPayload>
/**
 * Model Inquiry
 * / ============================
 * / INQUIRY
 * / ============================
 */
export type Inquiry = $Result.DefaultSelection<Prisma.$InquiryPayload>
/**
 * Model RegionMissionCounter
 * / ============================
 * / REGION MISSION COUNTER
 * / ============================
 */
export type RegionMissionCounter = $Result.DefaultSelection<Prisma.$RegionMissionCounterPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.foodCategory`: Exposes CRUD operations for the **FoodCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodCategories
    * const foodCategories = await prisma.foodCategory.findMany()
    * ```
    */
  get foodCategory(): Prisma.FoodCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userFavorCategory`: Exposes CRUD operations for the **UserFavorCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFavorCategories
    * const userFavorCategories = await prisma.userFavorCategory.findMany()
    * ```
    */
  get userFavorCategory(): Prisma.UserFavorCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.region`: Exposes CRUD operations for the **Region** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.region.findMany()
    * ```
    */
  get region(): Prisma.RegionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.diner`: Exposes CRUD operations for the **Diner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diners
    * const diners = await prisma.diner.findMany()
    * ```
    */
  get diner(): Prisma.DinerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mission`: Exposes CRUD operations for the **Mission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Missions
    * const missions = await prisma.mission.findMany()
    * ```
    */
  get mission(): Prisma.MissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dinerMission`: Exposes CRUD operations for the **DinerMission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DinerMissions
    * const dinerMissions = await prisma.dinerMission.findMany()
    * ```
    */
  get dinerMission(): Prisma.DinerMissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pointHistory`: Exposes CRUD operations for the **PointHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PointHistories
    * const pointHistories = await prisma.pointHistory.findMany()
    * ```
    */
  get pointHistory(): Prisma.PointHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.missionClearLog`: Exposes CRUD operations for the **MissionClearLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MissionClearLogs
    * const missionClearLogs = await prisma.missionClearLog.findMany()
    * ```
    */
  get missionClearLog(): Prisma.MissionClearLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inquiry`: Exposes CRUD operations for the **Inquiry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inquiries
    * const inquiries = await prisma.inquiry.findMany()
    * ```
    */
  get inquiry(): Prisma.InquiryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.regionMissionCounter`: Exposes CRUD operations for the **RegionMissionCounter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegionMissionCounters
    * const regionMissionCounters = await prisma.regionMissionCounter.findMany()
    * ```
    */
  get regionMissionCounter(): Prisma.RegionMissionCounterDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    FoodCategory: 'FoodCategory',
    UserFavorCategory: 'UserFavorCategory',
    Region: 'Region',
    Diner: 'Diner',
    Mission: 'Mission',
    DinerMission: 'DinerMission',
    Review: 'Review',
    PointHistory: 'PointHistory',
    MissionClearLog: 'MissionClearLog',
    Inquiry: 'Inquiry',
    RegionMissionCounter: 'RegionMissionCounter'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "foodCategory" | "userFavorCategory" | "region" | "diner" | "mission" | "dinerMission" | "review" | "pointHistory" | "missionClearLog" | "inquiry" | "regionMissionCounter"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      FoodCategory: {
        payload: Prisma.$FoodCategoryPayload<ExtArgs>
        fields: Prisma.FoodCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCategoryPayload>
          }
          findFirst: {
            args: Prisma.FoodCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCategoryPayload>
          }
          findMany: {
            args: Prisma.FoodCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCategoryPayload>[]
          }
          create: {
            args: Prisma.FoodCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCategoryPayload>
          }
          createMany: {
            args: Prisma.FoodCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FoodCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCategoryPayload>
          }
          update: {
            args: Prisma.FoodCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCategoryPayload>
          }
          deleteMany: {
            args: Prisma.FoodCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoodCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCategoryPayload>
          }
          aggregate: {
            args: Prisma.FoodCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodCategory>
          }
          groupBy: {
            args: Prisma.FoodCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<FoodCategoryCountAggregateOutputType> | number
          }
        }
      }
      UserFavorCategory: {
        payload: Prisma.$UserFavorCategoryPayload<ExtArgs>
        fields: Prisma.UserFavorCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFavorCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavorCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFavorCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavorCategoryPayload>
          }
          findFirst: {
            args: Prisma.UserFavorCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavorCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFavorCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavorCategoryPayload>
          }
          findMany: {
            args: Prisma.UserFavorCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavorCategoryPayload>[]
          }
          create: {
            args: Prisma.UserFavorCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavorCategoryPayload>
          }
          createMany: {
            args: Prisma.UserFavorCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserFavorCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavorCategoryPayload>
          }
          update: {
            args: Prisma.UserFavorCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavorCategoryPayload>
          }
          deleteMany: {
            args: Prisma.UserFavorCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFavorCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserFavorCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFavorCategoryPayload>
          }
          aggregate: {
            args: Prisma.UserFavorCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFavorCategory>
          }
          groupBy: {
            args: Prisma.UserFavorCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFavorCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFavorCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<UserFavorCategoryCountAggregateOutputType> | number
          }
        }
      }
      Region: {
        payload: Prisma.$RegionPayload<ExtArgs>
        fields: Prisma.RegionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findFirst: {
            args: Prisma.RegionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findMany: {
            args: Prisma.RegionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          create: {
            args: Prisma.RegionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          createMany: {
            args: Prisma.RegionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RegionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          update: {
            args: Prisma.RegionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          deleteMany: {
            args: Prisma.RegionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RegionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          aggregate: {
            args: Prisma.RegionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegion>
          }
          groupBy: {
            args: Prisma.RegionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionCountArgs<ExtArgs>
            result: $Utils.Optional<RegionCountAggregateOutputType> | number
          }
        }
      }
      Diner: {
        payload: Prisma.$DinerPayload<ExtArgs>
        fields: Prisma.DinerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DinerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DinerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinerPayload>
          }
          findFirst: {
            args: Prisma.DinerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DinerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinerPayload>
          }
          findMany: {
            args: Prisma.DinerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinerPayload>[]
          }
          create: {
            args: Prisma.DinerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinerPayload>
          }
          createMany: {
            args: Prisma.DinerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DinerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinerPayload>
          }
          update: {
            args: Prisma.DinerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinerPayload>
          }
          deleteMany: {
            args: Prisma.DinerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DinerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DinerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinerPayload>
          }
          aggregate: {
            args: Prisma.DinerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiner>
          }
          groupBy: {
            args: Prisma.DinerGroupByArgs<ExtArgs>
            result: $Utils.Optional<DinerGroupByOutputType>[]
          }
          count: {
            args: Prisma.DinerCountArgs<ExtArgs>
            result: $Utils.Optional<DinerCountAggregateOutputType> | number
          }
        }
      }
      Mission: {
        payload: Prisma.$MissionPayload<ExtArgs>
        fields: Prisma.MissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          findFirst: {
            args: Prisma.MissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          findMany: {
            args: Prisma.MissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>[]
          }
          create: {
            args: Prisma.MissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          createMany: {
            args: Prisma.MissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          update: {
            args: Prisma.MissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          deleteMany: {
            args: Prisma.MissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          aggregate: {
            args: Prisma.MissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMission>
          }
          groupBy: {
            args: Prisma.MissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MissionCountArgs<ExtArgs>
            result: $Utils.Optional<MissionCountAggregateOutputType> | number
          }
        }
      }
      DinerMission: {
        payload: Prisma.$DinerMissionPayload<ExtArgs>
        fields: Prisma.DinerMissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DinerMissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinerMissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DinerMissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinerMissionPayload>
          }
          findFirst: {
            args: Prisma.DinerMissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinerMissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DinerMissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinerMissionPayload>
          }
          findMany: {
            args: Prisma.DinerMissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinerMissionPayload>[]
          }
          create: {
            args: Prisma.DinerMissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinerMissionPayload>
          }
          createMany: {
            args: Prisma.DinerMissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DinerMissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinerMissionPayload>
          }
          update: {
            args: Prisma.DinerMissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinerMissionPayload>
          }
          deleteMany: {
            args: Prisma.DinerMissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DinerMissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DinerMissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DinerMissionPayload>
          }
          aggregate: {
            args: Prisma.DinerMissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDinerMission>
          }
          groupBy: {
            args: Prisma.DinerMissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DinerMissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DinerMissionCountArgs<ExtArgs>
            result: $Utils.Optional<DinerMissionCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      PointHistory: {
        payload: Prisma.$PointHistoryPayload<ExtArgs>
        fields: Prisma.PointHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PointHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PointHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload>
          }
          findFirst: {
            args: Prisma.PointHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PointHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload>
          }
          findMany: {
            args: Prisma.PointHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload>[]
          }
          create: {
            args: Prisma.PointHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload>
          }
          createMany: {
            args: Prisma.PointHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PointHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload>
          }
          update: {
            args: Prisma.PointHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PointHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PointHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PointHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload>
          }
          aggregate: {
            args: Prisma.PointHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePointHistory>
          }
          groupBy: {
            args: Prisma.PointHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PointHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PointHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PointHistoryCountAggregateOutputType> | number
          }
        }
      }
      MissionClearLog: {
        payload: Prisma.$MissionClearLogPayload<ExtArgs>
        fields: Prisma.MissionClearLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MissionClearLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionClearLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MissionClearLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionClearLogPayload>
          }
          findFirst: {
            args: Prisma.MissionClearLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionClearLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MissionClearLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionClearLogPayload>
          }
          findMany: {
            args: Prisma.MissionClearLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionClearLogPayload>[]
          }
          create: {
            args: Prisma.MissionClearLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionClearLogPayload>
          }
          createMany: {
            args: Prisma.MissionClearLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MissionClearLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionClearLogPayload>
          }
          update: {
            args: Prisma.MissionClearLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionClearLogPayload>
          }
          deleteMany: {
            args: Prisma.MissionClearLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MissionClearLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MissionClearLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionClearLogPayload>
          }
          aggregate: {
            args: Prisma.MissionClearLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMissionClearLog>
          }
          groupBy: {
            args: Prisma.MissionClearLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<MissionClearLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.MissionClearLogCountArgs<ExtArgs>
            result: $Utils.Optional<MissionClearLogCountAggregateOutputType> | number
          }
        }
      }
      Inquiry: {
        payload: Prisma.$InquiryPayload<ExtArgs>
        fields: Prisma.InquiryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InquiryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InquiryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          findFirst: {
            args: Prisma.InquiryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InquiryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          findMany: {
            args: Prisma.InquiryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>[]
          }
          create: {
            args: Prisma.InquiryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          createMany: {
            args: Prisma.InquiryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InquiryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          update: {
            args: Prisma.InquiryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          deleteMany: {
            args: Prisma.InquiryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InquiryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InquiryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          aggregate: {
            args: Prisma.InquiryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInquiry>
          }
          groupBy: {
            args: Prisma.InquiryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InquiryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InquiryCountArgs<ExtArgs>
            result: $Utils.Optional<InquiryCountAggregateOutputType> | number
          }
        }
      }
      RegionMissionCounter: {
        payload: Prisma.$RegionMissionCounterPayload<ExtArgs>
        fields: Prisma.RegionMissionCounterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionMissionCounterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMissionCounterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionMissionCounterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMissionCounterPayload>
          }
          findFirst: {
            args: Prisma.RegionMissionCounterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMissionCounterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionMissionCounterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMissionCounterPayload>
          }
          findMany: {
            args: Prisma.RegionMissionCounterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMissionCounterPayload>[]
          }
          create: {
            args: Prisma.RegionMissionCounterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMissionCounterPayload>
          }
          createMany: {
            args: Prisma.RegionMissionCounterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RegionMissionCounterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMissionCounterPayload>
          }
          update: {
            args: Prisma.RegionMissionCounterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMissionCounterPayload>
          }
          deleteMany: {
            args: Prisma.RegionMissionCounterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegionMissionCounterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RegionMissionCounterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionMissionCounterPayload>
          }
          aggregate: {
            args: Prisma.RegionMissionCounterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegionMissionCounter>
          }
          groupBy: {
            args: Prisma.RegionMissionCounterGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegionMissionCounterGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionMissionCounterCountArgs<ExtArgs>
            result: $Utils.Optional<RegionMissionCounterCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    foodCategory?: FoodCategoryOmit
    userFavorCategory?: UserFavorCategoryOmit
    region?: RegionOmit
    diner?: DinerOmit
    mission?: MissionOmit
    dinerMission?: DinerMissionOmit
    review?: ReviewOmit
    pointHistory?: PointHistoryOmit
    missionClearLog?: MissionClearLogOmit
    inquiry?: InquiryOmit
    regionMissionCounter?: RegionMissionCounterOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    userFavorCategories: number
    reviews: number
    pointHistories: number
    missionClearLogs: number
    inquiries: number
    regionMissionCounts: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userFavorCategories?: boolean | UserCountOutputTypeCountUserFavorCategoriesArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    pointHistories?: boolean | UserCountOutputTypeCountPointHistoriesArgs
    missionClearLogs?: boolean | UserCountOutputTypeCountMissionClearLogsArgs
    inquiries?: boolean | UserCountOutputTypeCountInquiriesArgs
    regionMissionCounts?: boolean | UserCountOutputTypeCountRegionMissionCountsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserFavorCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavorCategoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPointHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMissionClearLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionClearLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRegionMissionCountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionMissionCounterWhereInput
  }


  /**
   * Count Type FoodCategoryCountOutputType
   */

  export type FoodCategoryCountOutputType = {
    diners: number
    userFavorCategories: number
  }

  export type FoodCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diners?: boolean | FoodCategoryCountOutputTypeCountDinersArgs
    userFavorCategories?: boolean | FoodCategoryCountOutputTypeCountUserFavorCategoriesArgs
  }

  // Custom InputTypes
  /**
   * FoodCategoryCountOutputType without action
   */
  export type FoodCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategoryCountOutputType
     */
    select?: FoodCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FoodCategoryCountOutputType without action
   */
  export type FoodCategoryCountOutputTypeCountDinersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DinerWhereInput
  }

  /**
   * FoodCategoryCountOutputType without action
   */
  export type FoodCategoryCountOutputTypeCountUserFavorCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavorCategoryWhereInput
  }


  /**
   * Count Type RegionCountOutputType
   */

  export type RegionCountOutputType = {
    diners: number
    regionMissionCounters: number
  }

  export type RegionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diners?: boolean | RegionCountOutputTypeCountDinersArgs
    regionMissionCounters?: boolean | RegionCountOutputTypeCountRegionMissionCountersArgs
  }

  // Custom InputTypes
  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCountOutputType
     */
    select?: RegionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountDinersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DinerWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountRegionMissionCountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionMissionCounterWhereInput
  }


  /**
   * Count Type DinerCountOutputType
   */

  export type DinerCountOutputType = {
    dinerMissions: number
    reviews: number
  }

  export type DinerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dinerMissions?: boolean | DinerCountOutputTypeCountDinerMissionsArgs
    reviews?: boolean | DinerCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * DinerCountOutputType without action
   */
  export type DinerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DinerCountOutputType
     */
    select?: DinerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DinerCountOutputType without action
   */
  export type DinerCountOutputTypeCountDinerMissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DinerMissionWhereInput
  }

  /**
   * DinerCountOutputType without action
   */
  export type DinerCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Count Type MissionCountOutputType
   */

  export type MissionCountOutputType = {
    dinerMissions: number
  }

  export type MissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dinerMissions?: boolean | MissionCountOutputTypeCountDinerMissionsArgs
  }

  // Custom InputTypes
  /**
   * MissionCountOutputType without action
   */
  export type MissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionCountOutputType
     */
    select?: MissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MissionCountOutputType without action
   */
  export type MissionCountOutputTypeCountDinerMissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DinerMissionWhereInput
  }


  /**
   * Count Type DinerMissionCountOutputType
   */

  export type DinerMissionCountOutputType = {
    missionClearLogs: number
  }

  export type DinerMissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    missionClearLogs?: boolean | DinerMissionCountOutputTypeCountMissionClearLogsArgs
  }

  // Custom InputTypes
  /**
   * DinerMissionCountOutputType without action
   */
  export type DinerMissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DinerMissionCountOutputType
     */
    select?: DinerMissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DinerMissionCountOutputType without action
   */
  export type DinerMissionCountOutputTypeCountMissionClearLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionClearLogWhereInput
  }


  /**
   * Count Type PointHistoryCountOutputType
   */

  export type PointHistoryCountOutputType = {
    missionClearLogs: number
  }

  export type PointHistoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    missionClearLogs?: boolean | PointHistoryCountOutputTypeCountMissionClearLogsArgs
  }

  // Custom InputTypes
  /**
   * PointHistoryCountOutputType without action
   */
  export type PointHistoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistoryCountOutputType
     */
    select?: PointHistoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PointHistoryCountOutputType without action
   */
  export type PointHistoryCountOutputTypeCountMissionClearLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionClearLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    role: $Enums.UserRole | null
    gender: string | null
    birth: Date | null
    address: string | null
    detailAddress: string | null
    phoneNumber: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    role: $Enums.UserRole | null
    gender: string | null
    birth: Date | null
    address: string | null
    detailAddress: string | null
    phoneNumber: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    role: number
    gender: number
    birth: number
    address: number
    detailAddress: number
    phoneNumber: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    gender?: true
    birth?: true
    address?: true
    detailAddress?: true
    phoneNumber?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    gender?: true
    birth?: true
    address?: true
    detailAddress?: true
    phoneNumber?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    gender?: true
    birth?: true
    address?: true
    detailAddress?: true
    phoneNumber?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    name: string
    role: $Enums.UserRole
    gender: string
    birth: Date
    address: string
    detailAddress: string | null
    phoneNumber: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    gender?: boolean
    birth?: boolean
    address?: boolean
    detailAddress?: boolean
    phoneNumber?: boolean
    userFavorCategories?: boolean | User$userFavorCategoriesArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    pointHistories?: boolean | User$pointHistoriesArgs<ExtArgs>
    missionClearLogs?: boolean | User$missionClearLogsArgs<ExtArgs>
    inquiries?: boolean | User$inquiriesArgs<ExtArgs>
    regionMissionCounts?: boolean | User$regionMissionCountsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    gender?: boolean
    birth?: boolean
    address?: boolean
    detailAddress?: boolean
    phoneNumber?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "role" | "gender" | "birth" | "address" | "detailAddress" | "phoneNumber", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userFavorCategories?: boolean | User$userFavorCategoriesArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    pointHistories?: boolean | User$pointHistoriesArgs<ExtArgs>
    missionClearLogs?: boolean | User$missionClearLogsArgs<ExtArgs>
    inquiries?: boolean | User$inquiriesArgs<ExtArgs>
    regionMissionCounts?: boolean | User$regionMissionCountsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      userFavorCategories: Prisma.$UserFavorCategoryPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      pointHistories: Prisma.$PointHistoryPayload<ExtArgs>[]
      missionClearLogs: Prisma.$MissionClearLogPayload<ExtArgs>[]
      inquiries: Prisma.$InquiryPayload<ExtArgs>[]
      regionMissionCounts: Prisma.$RegionMissionCounterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      name: string
      role: $Enums.UserRole
      gender: string
      birth: Date
      address: string
      detailAddress: string | null
      phoneNumber: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userFavorCategories<T extends User$userFavorCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$userFavorCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavorCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pointHistories<T extends User$pointHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$pointHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    missionClearLogs<T extends User$missionClearLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$missionClearLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionClearLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inquiries<T extends User$inquiriesArgs<ExtArgs> = {}>(args?: Subset<T, User$inquiriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    regionMissionCounts<T extends User$regionMissionCountsArgs<ExtArgs> = {}>(args?: Subset<T, User$regionMissionCountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionMissionCounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly gender: FieldRef<"User", 'String'>
    readonly birth: FieldRef<"User", 'DateTime'>
    readonly address: FieldRef<"User", 'String'>
    readonly detailAddress: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.userFavorCategories
   */
  export type User$userFavorCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorCategory
     */
    select?: UserFavorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorCategory
     */
    omit?: UserFavorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavorCategoryInclude<ExtArgs> | null
    where?: UserFavorCategoryWhereInput
    orderBy?: UserFavorCategoryOrderByWithRelationInput | UserFavorCategoryOrderByWithRelationInput[]
    cursor?: UserFavorCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFavorCategoryScalarFieldEnum | UserFavorCategoryScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.pointHistories
   */
  export type User$pointHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    where?: PointHistoryWhereInput
    orderBy?: PointHistoryOrderByWithRelationInput | PointHistoryOrderByWithRelationInput[]
    cursor?: PointHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PointHistoryScalarFieldEnum | PointHistoryScalarFieldEnum[]
  }

  /**
   * User.missionClearLogs
   */
  export type User$missionClearLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionClearLog
     */
    select?: MissionClearLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissionClearLog
     */
    omit?: MissionClearLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionClearLogInclude<ExtArgs> | null
    where?: MissionClearLogWhereInput
    orderBy?: MissionClearLogOrderByWithRelationInput | MissionClearLogOrderByWithRelationInput[]
    cursor?: MissionClearLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MissionClearLogScalarFieldEnum | MissionClearLogScalarFieldEnum[]
  }

  /**
   * User.inquiries
   */
  export type User$inquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    where?: InquiryWhereInput
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    cursor?: InquiryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * User.regionMissionCounts
   */
  export type User$regionMissionCountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMissionCounter
     */
    select?: RegionMissionCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMissionCounter
     */
    omit?: RegionMissionCounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMissionCounterInclude<ExtArgs> | null
    where?: RegionMissionCounterWhereInput
    orderBy?: RegionMissionCounterOrderByWithRelationInput | RegionMissionCounterOrderByWithRelationInput[]
    cursor?: RegionMissionCounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegionMissionCounterScalarFieldEnum | RegionMissionCounterScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model FoodCategory
   */

  export type AggregateFoodCategory = {
    _count: FoodCategoryCountAggregateOutputType | null
    _avg: FoodCategoryAvgAggregateOutputType | null
    _sum: FoodCategorySumAggregateOutputType | null
    _min: FoodCategoryMinAggregateOutputType | null
    _max: FoodCategoryMaxAggregateOutputType | null
  }

  export type FoodCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type FoodCategorySumAggregateOutputType = {
    id: number | null
  }

  export type FoodCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type FoodCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type FoodCategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type FoodCategoryAvgAggregateInputType = {
    id?: true
  }

  export type FoodCategorySumAggregateInputType = {
    id?: true
  }

  export type FoodCategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type FoodCategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type FoodCategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type FoodCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodCategory to aggregate.
     */
    where?: FoodCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodCategories to fetch.
     */
    orderBy?: FoodCategoryOrderByWithRelationInput | FoodCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodCategories
    **/
    _count?: true | FoodCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodCategoryMaxAggregateInputType
  }

  export type GetFoodCategoryAggregateType<T extends FoodCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodCategory[P]>
      : GetScalarType<T[P], AggregateFoodCategory[P]>
  }




  export type FoodCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodCategoryWhereInput
    orderBy?: FoodCategoryOrderByWithAggregationInput | FoodCategoryOrderByWithAggregationInput[]
    by: FoodCategoryScalarFieldEnum[] | FoodCategoryScalarFieldEnum
    having?: FoodCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodCategoryCountAggregateInputType | true
    _avg?: FoodCategoryAvgAggregateInputType
    _sum?: FoodCategorySumAggregateInputType
    _min?: FoodCategoryMinAggregateInputType
    _max?: FoodCategoryMaxAggregateInputType
  }

  export type FoodCategoryGroupByOutputType = {
    id: number
    name: string
    _count: FoodCategoryCountAggregateOutputType | null
    _avg: FoodCategoryAvgAggregateOutputType | null
    _sum: FoodCategorySumAggregateOutputType | null
    _min: FoodCategoryMinAggregateOutputType | null
    _max: FoodCategoryMaxAggregateOutputType | null
  }

  type GetFoodCategoryGroupByPayload<T extends FoodCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], FoodCategoryGroupByOutputType[P]>
        }
      >
    >


  export type FoodCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    diners?: boolean | FoodCategory$dinersArgs<ExtArgs>
    userFavorCategories?: boolean | FoodCategory$userFavorCategoriesArgs<ExtArgs>
    _count?: boolean | FoodCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodCategory"]>



  export type FoodCategorySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type FoodCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["foodCategory"]>
  export type FoodCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diners?: boolean | FoodCategory$dinersArgs<ExtArgs>
    userFavorCategories?: boolean | FoodCategory$userFavorCategoriesArgs<ExtArgs>
    _count?: boolean | FoodCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FoodCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodCategory"
    objects: {
      diners: Prisma.$DinerPayload<ExtArgs>[]
      userFavorCategories: Prisma.$UserFavorCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["foodCategory"]>
    composites: {}
  }

  type FoodCategoryGetPayload<S extends boolean | null | undefined | FoodCategoryDefaultArgs> = $Result.GetResult<Prisma.$FoodCategoryPayload, S>

  type FoodCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FoodCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FoodCategoryCountAggregateInputType | true
    }

  export interface FoodCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodCategory'], meta: { name: 'FoodCategory' } }
    /**
     * Find zero or one FoodCategory that matches the filter.
     * @param {FoodCategoryFindUniqueArgs} args - Arguments to find a FoodCategory
     * @example
     * // Get one FoodCategory
     * const foodCategory = await prisma.foodCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodCategoryFindUniqueArgs>(args: SelectSubset<T, FoodCategoryFindUniqueArgs<ExtArgs>>): Prisma__FoodCategoryClient<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FoodCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FoodCategoryFindUniqueOrThrowArgs} args - Arguments to find a FoodCategory
     * @example
     * // Get one FoodCategory
     * const foodCategory = await prisma.foodCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodCategoryClient<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCategoryFindFirstArgs} args - Arguments to find a FoodCategory
     * @example
     * // Get one FoodCategory
     * const foodCategory = await prisma.foodCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodCategoryFindFirstArgs>(args?: SelectSubset<T, FoodCategoryFindFirstArgs<ExtArgs>>): Prisma__FoodCategoryClient<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FoodCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCategoryFindFirstOrThrowArgs} args - Arguments to find a FoodCategory
     * @example
     * // Get one FoodCategory
     * const foodCategory = await prisma.foodCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodCategoryClient<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FoodCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodCategories
     * const foodCategories = await prisma.foodCategory.findMany()
     * 
     * // Get first 10 FoodCategories
     * const foodCategories = await prisma.foodCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodCategoryWithIdOnly = await prisma.foodCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodCategoryFindManyArgs>(args?: SelectSubset<T, FoodCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FoodCategory.
     * @param {FoodCategoryCreateArgs} args - Arguments to create a FoodCategory.
     * @example
     * // Create one FoodCategory
     * const FoodCategory = await prisma.foodCategory.create({
     *   data: {
     *     // ... data to create a FoodCategory
     *   }
     * })
     * 
     */
    create<T extends FoodCategoryCreateArgs>(args: SelectSubset<T, FoodCategoryCreateArgs<ExtArgs>>): Prisma__FoodCategoryClient<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FoodCategories.
     * @param {FoodCategoryCreateManyArgs} args - Arguments to create many FoodCategories.
     * @example
     * // Create many FoodCategories
     * const foodCategory = await prisma.foodCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodCategoryCreateManyArgs>(args?: SelectSubset<T, FoodCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FoodCategory.
     * @param {FoodCategoryDeleteArgs} args - Arguments to delete one FoodCategory.
     * @example
     * // Delete one FoodCategory
     * const FoodCategory = await prisma.foodCategory.delete({
     *   where: {
     *     // ... filter to delete one FoodCategory
     *   }
     * })
     * 
     */
    delete<T extends FoodCategoryDeleteArgs>(args: SelectSubset<T, FoodCategoryDeleteArgs<ExtArgs>>): Prisma__FoodCategoryClient<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FoodCategory.
     * @param {FoodCategoryUpdateArgs} args - Arguments to update one FoodCategory.
     * @example
     * // Update one FoodCategory
     * const foodCategory = await prisma.foodCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodCategoryUpdateArgs>(args: SelectSubset<T, FoodCategoryUpdateArgs<ExtArgs>>): Prisma__FoodCategoryClient<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FoodCategories.
     * @param {FoodCategoryDeleteManyArgs} args - Arguments to filter FoodCategories to delete.
     * @example
     * // Delete a few FoodCategories
     * const { count } = await prisma.foodCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodCategoryDeleteManyArgs>(args?: SelectSubset<T, FoodCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodCategories
     * const foodCategory = await prisma.foodCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodCategoryUpdateManyArgs>(args: SelectSubset<T, FoodCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FoodCategory.
     * @param {FoodCategoryUpsertArgs} args - Arguments to update or create a FoodCategory.
     * @example
     * // Update or create a FoodCategory
     * const foodCategory = await prisma.foodCategory.upsert({
     *   create: {
     *     // ... data to create a FoodCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodCategory we want to update
     *   }
     * })
     */
    upsert<T extends FoodCategoryUpsertArgs>(args: SelectSubset<T, FoodCategoryUpsertArgs<ExtArgs>>): Prisma__FoodCategoryClient<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FoodCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCategoryCountArgs} args - Arguments to filter FoodCategories to count.
     * @example
     * // Count the number of FoodCategories
     * const count = await prisma.foodCategory.count({
     *   where: {
     *     // ... the filter for the FoodCategories we want to count
     *   }
     * })
    **/
    count<T extends FoodCategoryCountArgs>(
      args?: Subset<T, FoodCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodCategoryAggregateArgs>(args: Subset<T, FoodCategoryAggregateArgs>): Prisma.PrismaPromise<GetFoodCategoryAggregateType<T>>

    /**
     * Group by FoodCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodCategoryGroupByArgs['orderBy'] }
        : { orderBy?: FoodCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodCategory model
   */
  readonly fields: FoodCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    diners<T extends FoodCategory$dinersArgs<ExtArgs> = {}>(args?: Subset<T, FoodCategory$dinersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DinerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userFavorCategories<T extends FoodCategory$userFavorCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, FoodCategory$userFavorCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavorCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodCategory model
   */
  interface FoodCategoryFieldRefs {
    readonly id: FieldRef<"FoodCategory", 'Int'>
    readonly name: FieldRef<"FoodCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FoodCategory findUnique
   */
  export type FoodCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCategory
     */
    omit?: FoodCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FoodCategory to fetch.
     */
    where: FoodCategoryWhereUniqueInput
  }

  /**
   * FoodCategory findUniqueOrThrow
   */
  export type FoodCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCategory
     */
    omit?: FoodCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FoodCategory to fetch.
     */
    where: FoodCategoryWhereUniqueInput
  }

  /**
   * FoodCategory findFirst
   */
  export type FoodCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCategory
     */
    omit?: FoodCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FoodCategory to fetch.
     */
    where?: FoodCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodCategories to fetch.
     */
    orderBy?: FoodCategoryOrderByWithRelationInput | FoodCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodCategories.
     */
    cursor?: FoodCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodCategories.
     */
    distinct?: FoodCategoryScalarFieldEnum | FoodCategoryScalarFieldEnum[]
  }

  /**
   * FoodCategory findFirstOrThrow
   */
  export type FoodCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCategory
     */
    omit?: FoodCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FoodCategory to fetch.
     */
    where?: FoodCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodCategories to fetch.
     */
    orderBy?: FoodCategoryOrderByWithRelationInput | FoodCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodCategories.
     */
    cursor?: FoodCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodCategories.
     */
    distinct?: FoodCategoryScalarFieldEnum | FoodCategoryScalarFieldEnum[]
  }

  /**
   * FoodCategory findMany
   */
  export type FoodCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCategory
     */
    omit?: FoodCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FoodCategories to fetch.
     */
    where?: FoodCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodCategories to fetch.
     */
    orderBy?: FoodCategoryOrderByWithRelationInput | FoodCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodCategories.
     */
    cursor?: FoodCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodCategories.
     */
    skip?: number
    distinct?: FoodCategoryScalarFieldEnum | FoodCategoryScalarFieldEnum[]
  }

  /**
   * FoodCategory create
   */
  export type FoodCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCategory
     */
    omit?: FoodCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodCategory.
     */
    data: XOR<FoodCategoryCreateInput, FoodCategoryUncheckedCreateInput>
  }

  /**
   * FoodCategory createMany
   */
  export type FoodCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodCategories.
     */
    data: FoodCategoryCreateManyInput | FoodCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodCategory update
   */
  export type FoodCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCategory
     */
    omit?: FoodCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodCategory.
     */
    data: XOR<FoodCategoryUpdateInput, FoodCategoryUncheckedUpdateInput>
    /**
     * Choose, which FoodCategory to update.
     */
    where: FoodCategoryWhereUniqueInput
  }

  /**
   * FoodCategory updateMany
   */
  export type FoodCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodCategories.
     */
    data: XOR<FoodCategoryUpdateManyMutationInput, FoodCategoryUncheckedUpdateManyInput>
    /**
     * Filter which FoodCategories to update
     */
    where?: FoodCategoryWhereInput
    /**
     * Limit how many FoodCategories to update.
     */
    limit?: number
  }

  /**
   * FoodCategory upsert
   */
  export type FoodCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCategory
     */
    omit?: FoodCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodCategory to update in case it exists.
     */
    where: FoodCategoryWhereUniqueInput
    /**
     * In case the FoodCategory found by the `where` argument doesn't exist, create a new FoodCategory with this data.
     */
    create: XOR<FoodCategoryCreateInput, FoodCategoryUncheckedCreateInput>
    /**
     * In case the FoodCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodCategoryUpdateInput, FoodCategoryUncheckedUpdateInput>
  }

  /**
   * FoodCategory delete
   */
  export type FoodCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCategory
     */
    omit?: FoodCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
    /**
     * Filter which FoodCategory to delete.
     */
    where: FoodCategoryWhereUniqueInput
  }

  /**
   * FoodCategory deleteMany
   */
  export type FoodCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodCategories to delete
     */
    where?: FoodCategoryWhereInput
    /**
     * Limit how many FoodCategories to delete.
     */
    limit?: number
  }

  /**
   * FoodCategory.diners
   */
  export type FoodCategory$dinersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diner
     */
    select?: DinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diner
     */
    omit?: DinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerInclude<ExtArgs> | null
    where?: DinerWhereInput
    orderBy?: DinerOrderByWithRelationInput | DinerOrderByWithRelationInput[]
    cursor?: DinerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DinerScalarFieldEnum | DinerScalarFieldEnum[]
  }

  /**
   * FoodCategory.userFavorCategories
   */
  export type FoodCategory$userFavorCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorCategory
     */
    select?: UserFavorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorCategory
     */
    omit?: UserFavorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavorCategoryInclude<ExtArgs> | null
    where?: UserFavorCategoryWhereInput
    orderBy?: UserFavorCategoryOrderByWithRelationInput | UserFavorCategoryOrderByWithRelationInput[]
    cursor?: UserFavorCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFavorCategoryScalarFieldEnum | UserFavorCategoryScalarFieldEnum[]
  }

  /**
   * FoodCategory without action
   */
  export type FoodCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FoodCategory
     */
    omit?: FoodCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
  }


  /**
   * Model UserFavorCategory
   */

  export type AggregateUserFavorCategory = {
    _count: UserFavorCategoryCountAggregateOutputType | null
    _avg: UserFavorCategoryAvgAggregateOutputType | null
    _sum: UserFavorCategorySumAggregateOutputType | null
    _min: UserFavorCategoryMinAggregateOutputType | null
    _max: UserFavorCategoryMaxAggregateOutputType | null
  }

  export type UserFavorCategoryAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    foodCategoryId: number | null
  }

  export type UserFavorCategorySumAggregateOutputType = {
    id: number | null
    userId: number | null
    foodCategoryId: number | null
  }

  export type UserFavorCategoryMinAggregateOutputType = {
    id: number | null
    userId: number | null
    foodCategoryId: number | null
  }

  export type UserFavorCategoryMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    foodCategoryId: number | null
  }

  export type UserFavorCategoryCountAggregateOutputType = {
    id: number
    userId: number
    foodCategoryId: number
    _all: number
  }


  export type UserFavorCategoryAvgAggregateInputType = {
    id?: true
    userId?: true
    foodCategoryId?: true
  }

  export type UserFavorCategorySumAggregateInputType = {
    id?: true
    userId?: true
    foodCategoryId?: true
  }

  export type UserFavorCategoryMinAggregateInputType = {
    id?: true
    userId?: true
    foodCategoryId?: true
  }

  export type UserFavorCategoryMaxAggregateInputType = {
    id?: true
    userId?: true
    foodCategoryId?: true
  }

  export type UserFavorCategoryCountAggregateInputType = {
    id?: true
    userId?: true
    foodCategoryId?: true
    _all?: true
  }

  export type UserFavorCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFavorCategory to aggregate.
     */
    where?: UserFavorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorCategories to fetch.
     */
    orderBy?: UserFavorCategoryOrderByWithRelationInput | UserFavorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFavorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFavorCategories
    **/
    _count?: true | UserFavorCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserFavorCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserFavorCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFavorCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFavorCategoryMaxAggregateInputType
  }

  export type GetUserFavorCategoryAggregateType<T extends UserFavorCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFavorCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFavorCategory[P]>
      : GetScalarType<T[P], AggregateUserFavorCategory[P]>
  }




  export type UserFavorCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFavorCategoryWhereInput
    orderBy?: UserFavorCategoryOrderByWithAggregationInput | UserFavorCategoryOrderByWithAggregationInput[]
    by: UserFavorCategoryScalarFieldEnum[] | UserFavorCategoryScalarFieldEnum
    having?: UserFavorCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFavorCategoryCountAggregateInputType | true
    _avg?: UserFavorCategoryAvgAggregateInputType
    _sum?: UserFavorCategorySumAggregateInputType
    _min?: UserFavorCategoryMinAggregateInputType
    _max?: UserFavorCategoryMaxAggregateInputType
  }

  export type UserFavorCategoryGroupByOutputType = {
    id: number
    userId: number
    foodCategoryId: number
    _count: UserFavorCategoryCountAggregateOutputType | null
    _avg: UserFavorCategoryAvgAggregateOutputType | null
    _sum: UserFavorCategorySumAggregateOutputType | null
    _min: UserFavorCategoryMinAggregateOutputType | null
    _max: UserFavorCategoryMaxAggregateOutputType | null
  }

  type GetUserFavorCategoryGroupByPayload<T extends UserFavorCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFavorCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFavorCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFavorCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], UserFavorCategoryGroupByOutputType[P]>
        }
      >
    >


  export type UserFavorCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    foodCategoryId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    foodCategory?: boolean | FoodCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFavorCategory"]>



  export type UserFavorCategorySelectScalar = {
    id?: boolean
    userId?: boolean
    foodCategoryId?: boolean
  }

  export type UserFavorCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "foodCategoryId", ExtArgs["result"]["userFavorCategory"]>
  export type UserFavorCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    foodCategory?: boolean | FoodCategoryDefaultArgs<ExtArgs>
  }

  export type $UserFavorCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFavorCategory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      foodCategory: Prisma.$FoodCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      foodCategoryId: number
    }, ExtArgs["result"]["userFavorCategory"]>
    composites: {}
  }

  type UserFavorCategoryGetPayload<S extends boolean | null | undefined | UserFavorCategoryDefaultArgs> = $Result.GetResult<Prisma.$UserFavorCategoryPayload, S>

  type UserFavorCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFavorCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserFavorCategoryCountAggregateInputType | true
    }

  export interface UserFavorCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFavorCategory'], meta: { name: 'UserFavorCategory' } }
    /**
     * Find zero or one UserFavorCategory that matches the filter.
     * @param {UserFavorCategoryFindUniqueArgs} args - Arguments to find a UserFavorCategory
     * @example
     * // Get one UserFavorCategory
     * const userFavorCategory = await prisma.userFavorCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFavorCategoryFindUniqueArgs>(args: SelectSubset<T, UserFavorCategoryFindUniqueArgs<ExtArgs>>): Prisma__UserFavorCategoryClient<$Result.GetResult<Prisma.$UserFavorCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserFavorCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFavorCategoryFindUniqueOrThrowArgs} args - Arguments to find a UserFavorCategory
     * @example
     * // Get one UserFavorCategory
     * const userFavorCategory = await prisma.userFavorCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFavorCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFavorCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFavorCategoryClient<$Result.GetResult<Prisma.$UserFavorCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFavorCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavorCategoryFindFirstArgs} args - Arguments to find a UserFavorCategory
     * @example
     * // Get one UserFavorCategory
     * const userFavorCategory = await prisma.userFavorCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFavorCategoryFindFirstArgs>(args?: SelectSubset<T, UserFavorCategoryFindFirstArgs<ExtArgs>>): Prisma__UserFavorCategoryClient<$Result.GetResult<Prisma.$UserFavorCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserFavorCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavorCategoryFindFirstOrThrowArgs} args - Arguments to find a UserFavorCategory
     * @example
     * // Get one UserFavorCategory
     * const userFavorCategory = await prisma.userFavorCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFavorCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFavorCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFavorCategoryClient<$Result.GetResult<Prisma.$UserFavorCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserFavorCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavorCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFavorCategories
     * const userFavorCategories = await prisma.userFavorCategory.findMany()
     * 
     * // Get first 10 UserFavorCategories
     * const userFavorCategories = await prisma.userFavorCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFavorCategoryWithIdOnly = await prisma.userFavorCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFavorCategoryFindManyArgs>(args?: SelectSubset<T, UserFavorCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFavorCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserFavorCategory.
     * @param {UserFavorCategoryCreateArgs} args - Arguments to create a UserFavorCategory.
     * @example
     * // Create one UserFavorCategory
     * const UserFavorCategory = await prisma.userFavorCategory.create({
     *   data: {
     *     // ... data to create a UserFavorCategory
     *   }
     * })
     * 
     */
    create<T extends UserFavorCategoryCreateArgs>(args: SelectSubset<T, UserFavorCategoryCreateArgs<ExtArgs>>): Prisma__UserFavorCategoryClient<$Result.GetResult<Prisma.$UserFavorCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserFavorCategories.
     * @param {UserFavorCategoryCreateManyArgs} args - Arguments to create many UserFavorCategories.
     * @example
     * // Create many UserFavorCategories
     * const userFavorCategory = await prisma.userFavorCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFavorCategoryCreateManyArgs>(args?: SelectSubset<T, UserFavorCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserFavorCategory.
     * @param {UserFavorCategoryDeleteArgs} args - Arguments to delete one UserFavorCategory.
     * @example
     * // Delete one UserFavorCategory
     * const UserFavorCategory = await prisma.userFavorCategory.delete({
     *   where: {
     *     // ... filter to delete one UserFavorCategory
     *   }
     * })
     * 
     */
    delete<T extends UserFavorCategoryDeleteArgs>(args: SelectSubset<T, UserFavorCategoryDeleteArgs<ExtArgs>>): Prisma__UserFavorCategoryClient<$Result.GetResult<Prisma.$UserFavorCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserFavorCategory.
     * @param {UserFavorCategoryUpdateArgs} args - Arguments to update one UserFavorCategory.
     * @example
     * // Update one UserFavorCategory
     * const userFavorCategory = await prisma.userFavorCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFavorCategoryUpdateArgs>(args: SelectSubset<T, UserFavorCategoryUpdateArgs<ExtArgs>>): Prisma__UserFavorCategoryClient<$Result.GetResult<Prisma.$UserFavorCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserFavorCategories.
     * @param {UserFavorCategoryDeleteManyArgs} args - Arguments to filter UserFavorCategories to delete.
     * @example
     * // Delete a few UserFavorCategories
     * const { count } = await prisma.userFavorCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFavorCategoryDeleteManyArgs>(args?: SelectSubset<T, UserFavorCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFavorCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavorCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFavorCategories
     * const userFavorCategory = await prisma.userFavorCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFavorCategoryUpdateManyArgs>(args: SelectSubset<T, UserFavorCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserFavorCategory.
     * @param {UserFavorCategoryUpsertArgs} args - Arguments to update or create a UserFavorCategory.
     * @example
     * // Update or create a UserFavorCategory
     * const userFavorCategory = await prisma.userFavorCategory.upsert({
     *   create: {
     *     // ... data to create a UserFavorCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFavorCategory we want to update
     *   }
     * })
     */
    upsert<T extends UserFavorCategoryUpsertArgs>(args: SelectSubset<T, UserFavorCategoryUpsertArgs<ExtArgs>>): Prisma__UserFavorCategoryClient<$Result.GetResult<Prisma.$UserFavorCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserFavorCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavorCategoryCountArgs} args - Arguments to filter UserFavorCategories to count.
     * @example
     * // Count the number of UserFavorCategories
     * const count = await prisma.userFavorCategory.count({
     *   where: {
     *     // ... the filter for the UserFavorCategories we want to count
     *   }
     * })
    **/
    count<T extends UserFavorCategoryCountArgs>(
      args?: Subset<T, UserFavorCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFavorCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFavorCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavorCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFavorCategoryAggregateArgs>(args: Subset<T, UserFavorCategoryAggregateArgs>): Prisma.PrismaPromise<GetUserFavorCategoryAggregateType<T>>

    /**
     * Group by UserFavorCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFavorCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFavorCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFavorCategoryGroupByArgs['orderBy'] }
        : { orderBy?: UserFavorCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFavorCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFavorCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFavorCategory model
   */
  readonly fields: UserFavorCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFavorCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFavorCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    foodCategory<T extends FoodCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodCategoryDefaultArgs<ExtArgs>>): Prisma__FoodCategoryClient<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFavorCategory model
   */
  interface UserFavorCategoryFieldRefs {
    readonly id: FieldRef<"UserFavorCategory", 'Int'>
    readonly userId: FieldRef<"UserFavorCategory", 'Int'>
    readonly foodCategoryId: FieldRef<"UserFavorCategory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserFavorCategory findUnique
   */
  export type UserFavorCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorCategory
     */
    select?: UserFavorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorCategory
     */
    omit?: UserFavorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorCategory to fetch.
     */
    where: UserFavorCategoryWhereUniqueInput
  }

  /**
   * UserFavorCategory findUniqueOrThrow
   */
  export type UserFavorCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorCategory
     */
    select?: UserFavorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorCategory
     */
    omit?: UserFavorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorCategory to fetch.
     */
    where: UserFavorCategoryWhereUniqueInput
  }

  /**
   * UserFavorCategory findFirst
   */
  export type UserFavorCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorCategory
     */
    select?: UserFavorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorCategory
     */
    omit?: UserFavorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorCategory to fetch.
     */
    where?: UserFavorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorCategories to fetch.
     */
    orderBy?: UserFavorCategoryOrderByWithRelationInput | UserFavorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFavorCategories.
     */
    cursor?: UserFavorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFavorCategories.
     */
    distinct?: UserFavorCategoryScalarFieldEnum | UserFavorCategoryScalarFieldEnum[]
  }

  /**
   * UserFavorCategory findFirstOrThrow
   */
  export type UserFavorCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorCategory
     */
    select?: UserFavorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorCategory
     */
    omit?: UserFavorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorCategory to fetch.
     */
    where?: UserFavorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorCategories to fetch.
     */
    orderBy?: UserFavorCategoryOrderByWithRelationInput | UserFavorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFavorCategories.
     */
    cursor?: UserFavorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFavorCategories.
     */
    distinct?: UserFavorCategoryScalarFieldEnum | UserFavorCategoryScalarFieldEnum[]
  }

  /**
   * UserFavorCategory findMany
   */
  export type UserFavorCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorCategory
     */
    select?: UserFavorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorCategory
     */
    omit?: UserFavorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavorCategoryInclude<ExtArgs> | null
    /**
     * Filter, which UserFavorCategories to fetch.
     */
    where?: UserFavorCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFavorCategories to fetch.
     */
    orderBy?: UserFavorCategoryOrderByWithRelationInput | UserFavorCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFavorCategories.
     */
    cursor?: UserFavorCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFavorCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFavorCategories.
     */
    skip?: number
    distinct?: UserFavorCategoryScalarFieldEnum | UserFavorCategoryScalarFieldEnum[]
  }

  /**
   * UserFavorCategory create
   */
  export type UserFavorCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorCategory
     */
    select?: UserFavorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorCategory
     */
    omit?: UserFavorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavorCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFavorCategory.
     */
    data: XOR<UserFavorCategoryCreateInput, UserFavorCategoryUncheckedCreateInput>
  }

  /**
   * UserFavorCategory createMany
   */
  export type UserFavorCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFavorCategories.
     */
    data: UserFavorCategoryCreateManyInput | UserFavorCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFavorCategory update
   */
  export type UserFavorCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorCategory
     */
    select?: UserFavorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorCategory
     */
    omit?: UserFavorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavorCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFavorCategory.
     */
    data: XOR<UserFavorCategoryUpdateInput, UserFavorCategoryUncheckedUpdateInput>
    /**
     * Choose, which UserFavorCategory to update.
     */
    where: UserFavorCategoryWhereUniqueInput
  }

  /**
   * UserFavorCategory updateMany
   */
  export type UserFavorCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFavorCategories.
     */
    data: XOR<UserFavorCategoryUpdateManyMutationInput, UserFavorCategoryUncheckedUpdateManyInput>
    /**
     * Filter which UserFavorCategories to update
     */
    where?: UserFavorCategoryWhereInput
    /**
     * Limit how many UserFavorCategories to update.
     */
    limit?: number
  }

  /**
   * UserFavorCategory upsert
   */
  export type UserFavorCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorCategory
     */
    select?: UserFavorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorCategory
     */
    omit?: UserFavorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavorCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFavorCategory to update in case it exists.
     */
    where: UserFavorCategoryWhereUniqueInput
    /**
     * In case the UserFavorCategory found by the `where` argument doesn't exist, create a new UserFavorCategory with this data.
     */
    create: XOR<UserFavorCategoryCreateInput, UserFavorCategoryUncheckedCreateInput>
    /**
     * In case the UserFavorCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFavorCategoryUpdateInput, UserFavorCategoryUncheckedUpdateInput>
  }

  /**
   * UserFavorCategory delete
   */
  export type UserFavorCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorCategory
     */
    select?: UserFavorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorCategory
     */
    omit?: UserFavorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavorCategoryInclude<ExtArgs> | null
    /**
     * Filter which UserFavorCategory to delete.
     */
    where: UserFavorCategoryWhereUniqueInput
  }

  /**
   * UserFavorCategory deleteMany
   */
  export type UserFavorCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFavorCategories to delete
     */
    where?: UserFavorCategoryWhereInput
    /**
     * Limit how many UserFavorCategories to delete.
     */
    limit?: number
  }

  /**
   * UserFavorCategory without action
   */
  export type UserFavorCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFavorCategory
     */
    select?: UserFavorCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserFavorCategory
     */
    omit?: UserFavorCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFavorCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Region
   */

  export type AggregateRegion = {
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  export type RegionAvgAggregateOutputType = {
    id: number | null
  }

  export type RegionSumAggregateOutputType = {
    id: number | null
  }

  export type RegionMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RegionMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RegionCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RegionAvgAggregateInputType = {
    id?: true
  }

  export type RegionSumAggregateInputType = {
    id?: true
  }

  export type RegionMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RegionMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RegionCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RegionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Region to aggregate.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regions
    **/
    _count?: true | RegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionMaxAggregateInputType
  }

  export type GetRegionAggregateType<T extends RegionAggregateArgs> = {
        [P in keyof T & keyof AggregateRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegion[P]>
      : GetScalarType<T[P], AggregateRegion[P]>
  }




  export type RegionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithAggregationInput | RegionOrderByWithAggregationInput[]
    by: RegionScalarFieldEnum[] | RegionScalarFieldEnum
    having?: RegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionCountAggregateInputType | true
    _avg?: RegionAvgAggregateInputType
    _sum?: RegionSumAggregateInputType
    _min?: RegionMinAggregateInputType
    _max?: RegionMaxAggregateInputType
  }

  export type RegionGroupByOutputType = {
    id: number
    name: string
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  type GetRegionGroupByPayload<T extends RegionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionGroupByOutputType[P]>
            : GetScalarType<T[P], RegionGroupByOutputType[P]>
        }
      >
    >


  export type RegionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    diners?: boolean | Region$dinersArgs<ExtArgs>
    regionMissionCounters?: boolean | Region$regionMissionCountersArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["region"]>



  export type RegionSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type RegionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["region"]>
  export type RegionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diners?: boolean | Region$dinersArgs<ExtArgs>
    regionMissionCounters?: boolean | Region$regionMissionCountersArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RegionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Region"
    objects: {
      diners: Prisma.$DinerPayload<ExtArgs>[]
      regionMissionCounters: Prisma.$RegionMissionCounterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["region"]>
    composites: {}
  }

  type RegionGetPayload<S extends boolean | null | undefined | RegionDefaultArgs> = $Result.GetResult<Prisma.$RegionPayload, S>

  type RegionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegionCountAggregateInputType | true
    }

  export interface RegionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Region'], meta: { name: 'Region' } }
    /**
     * Find zero or one Region that matches the filter.
     * @param {RegionFindUniqueArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegionFindUniqueArgs>(args: SelectSubset<T, RegionFindUniqueArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Region that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegionFindUniqueOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegionFindUniqueOrThrowArgs>(args: SelectSubset<T, RegionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Region that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegionFindFirstArgs>(args?: SelectSubset<T, RegionFindFirstArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Region that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegionFindFirstOrThrowArgs>(args?: SelectSubset<T, RegionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.region.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.region.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionWithIdOnly = await prisma.region.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegionFindManyArgs>(args?: SelectSubset<T, RegionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Region.
     * @param {RegionCreateArgs} args - Arguments to create a Region.
     * @example
     * // Create one Region
     * const Region = await prisma.region.create({
     *   data: {
     *     // ... data to create a Region
     *   }
     * })
     * 
     */
    create<T extends RegionCreateArgs>(args: SelectSubset<T, RegionCreateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Regions.
     * @param {RegionCreateManyArgs} args - Arguments to create many Regions.
     * @example
     * // Create many Regions
     * const region = await prisma.region.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegionCreateManyArgs>(args?: SelectSubset<T, RegionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Region.
     * @param {RegionDeleteArgs} args - Arguments to delete one Region.
     * @example
     * // Delete one Region
     * const Region = await prisma.region.delete({
     *   where: {
     *     // ... filter to delete one Region
     *   }
     * })
     * 
     */
    delete<T extends RegionDeleteArgs>(args: SelectSubset<T, RegionDeleteArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Region.
     * @param {RegionUpdateArgs} args - Arguments to update one Region.
     * @example
     * // Update one Region
     * const region = await prisma.region.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegionUpdateArgs>(args: SelectSubset<T, RegionUpdateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Regions.
     * @param {RegionDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.region.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegionDeleteManyArgs>(args?: SelectSubset<T, RegionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegionUpdateManyArgs>(args: SelectSubset<T, RegionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Region.
     * @param {RegionUpsertArgs} args - Arguments to update or create a Region.
     * @example
     * // Update or create a Region
     * const region = await prisma.region.upsert({
     *   create: {
     *     // ... data to create a Region
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Region we want to update
     *   }
     * })
     */
    upsert<T extends RegionUpsertArgs>(args: SelectSubset<T, RegionUpsertArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.region.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends RegionCountArgs>(
      args?: Subset<T, RegionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionAggregateArgs>(args: Subset<T, RegionAggregateArgs>): Prisma.PrismaPromise<GetRegionAggregateType<T>>

    /**
     * Group by Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionGroupByArgs['orderBy'] }
        : { orderBy?: RegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Region model
   */
  readonly fields: RegionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Region.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    diners<T extends Region$dinersArgs<ExtArgs> = {}>(args?: Subset<T, Region$dinersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DinerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    regionMissionCounters<T extends Region$regionMissionCountersArgs<ExtArgs> = {}>(args?: Subset<T, Region$regionMissionCountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionMissionCounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Region model
   */
  interface RegionFieldRefs {
    readonly id: FieldRef<"Region", 'Int'>
    readonly name: FieldRef<"Region", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Region findUnique
   */
  export type RegionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findUniqueOrThrow
   */
  export type RegionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findFirst
   */
  export type RegionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findFirstOrThrow
   */
  export type RegionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findMany
   */
  export type RegionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Regions to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region create
   */
  export type RegionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to create a Region.
     */
    data: XOR<RegionCreateInput, RegionUncheckedCreateInput>
  }

  /**
   * Region createMany
   */
  export type RegionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Region update
   */
  export type RegionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to update a Region.
     */
    data: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
    /**
     * Choose, which Region to update.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region updateMany
   */
  export type RegionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to update.
     */
    limit?: number
  }

  /**
   * Region upsert
   */
  export type RegionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The filter to search for the Region to update in case it exists.
     */
    where: RegionWhereUniqueInput
    /**
     * In case the Region found by the `where` argument doesn't exist, create a new Region with this data.
     */
    create: XOR<RegionCreateInput, RegionUncheckedCreateInput>
    /**
     * In case the Region was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
  }

  /**
   * Region delete
   */
  export type RegionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter which Region to delete.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region deleteMany
   */
  export type RegionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regions to delete
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to delete.
     */
    limit?: number
  }

  /**
   * Region.diners
   */
  export type Region$dinersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diner
     */
    select?: DinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diner
     */
    omit?: DinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerInclude<ExtArgs> | null
    where?: DinerWhereInput
    orderBy?: DinerOrderByWithRelationInput | DinerOrderByWithRelationInput[]
    cursor?: DinerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DinerScalarFieldEnum | DinerScalarFieldEnum[]
  }

  /**
   * Region.regionMissionCounters
   */
  export type Region$regionMissionCountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMissionCounter
     */
    select?: RegionMissionCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMissionCounter
     */
    omit?: RegionMissionCounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMissionCounterInclude<ExtArgs> | null
    where?: RegionMissionCounterWhereInput
    orderBy?: RegionMissionCounterOrderByWithRelationInput | RegionMissionCounterOrderByWithRelationInput[]
    cursor?: RegionMissionCounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegionMissionCounterScalarFieldEnum | RegionMissionCounterScalarFieldEnum[]
  }

  /**
   * Region without action
   */
  export type RegionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
  }


  /**
   * Model Diner
   */

  export type AggregateDiner = {
    _count: DinerCountAggregateOutputType | null
    _avg: DinerAvgAggregateOutputType | null
    _sum: DinerSumAggregateOutputType | null
    _min: DinerMinAggregateOutputType | null
    _max: DinerMaxAggregateOutputType | null
  }

  export type DinerAvgAggregateOutputType = {
    id: number | null
    regionId: number | null
    categoryId: number | null
    rating: number | null
  }

  export type DinerSumAggregateOutputType = {
    id: number | null
    regionId: number | null
    categoryId: number | null
    rating: number | null
  }

  export type DinerMinAggregateOutputType = {
    id: number | null
    regionId: number | null
    categoryId: number | null
    name: string | null
    phoneNumber: string | null
    address: string | null
    rating: number | null
  }

  export type DinerMaxAggregateOutputType = {
    id: number | null
    regionId: number | null
    categoryId: number | null
    name: string | null
    phoneNumber: string | null
    address: string | null
    rating: number | null
  }

  export type DinerCountAggregateOutputType = {
    id: number
    regionId: number
    categoryId: number
    name: number
    phoneNumber: number
    address: number
    rating: number
    _all: number
  }


  export type DinerAvgAggregateInputType = {
    id?: true
    regionId?: true
    categoryId?: true
    rating?: true
  }

  export type DinerSumAggregateInputType = {
    id?: true
    regionId?: true
    categoryId?: true
    rating?: true
  }

  export type DinerMinAggregateInputType = {
    id?: true
    regionId?: true
    categoryId?: true
    name?: true
    phoneNumber?: true
    address?: true
    rating?: true
  }

  export type DinerMaxAggregateInputType = {
    id?: true
    regionId?: true
    categoryId?: true
    name?: true
    phoneNumber?: true
    address?: true
    rating?: true
  }

  export type DinerCountAggregateInputType = {
    id?: true
    regionId?: true
    categoryId?: true
    name?: true
    phoneNumber?: true
    address?: true
    rating?: true
    _all?: true
  }

  export type DinerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diner to aggregate.
     */
    where?: DinerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diners to fetch.
     */
    orderBy?: DinerOrderByWithRelationInput | DinerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DinerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Diners
    **/
    _count?: true | DinerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DinerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DinerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DinerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DinerMaxAggregateInputType
  }

  export type GetDinerAggregateType<T extends DinerAggregateArgs> = {
        [P in keyof T & keyof AggregateDiner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiner[P]>
      : GetScalarType<T[P], AggregateDiner[P]>
  }




  export type DinerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DinerWhereInput
    orderBy?: DinerOrderByWithAggregationInput | DinerOrderByWithAggregationInput[]
    by: DinerScalarFieldEnum[] | DinerScalarFieldEnum
    having?: DinerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DinerCountAggregateInputType | true
    _avg?: DinerAvgAggregateInputType
    _sum?: DinerSumAggregateInputType
    _min?: DinerMinAggregateInputType
    _max?: DinerMaxAggregateInputType
  }

  export type DinerGroupByOutputType = {
    id: number
    regionId: number
    categoryId: number
    name: string
    phoneNumber: string | null
    address: string | null
    rating: number | null
    _count: DinerCountAggregateOutputType | null
    _avg: DinerAvgAggregateOutputType | null
    _sum: DinerSumAggregateOutputType | null
    _min: DinerMinAggregateOutputType | null
    _max: DinerMaxAggregateOutputType | null
  }

  type GetDinerGroupByPayload<T extends DinerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DinerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DinerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DinerGroupByOutputType[P]>
            : GetScalarType<T[P], DinerGroupByOutputType[P]>
        }
      >
    >


  export type DinerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionId?: boolean
    categoryId?: boolean
    name?: boolean
    phoneNumber?: boolean
    address?: boolean
    rating?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    category?: boolean | FoodCategoryDefaultArgs<ExtArgs>
    dinerMissions?: boolean | Diner$dinerMissionsArgs<ExtArgs>
    reviews?: boolean | Diner$reviewsArgs<ExtArgs>
    _count?: boolean | DinerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diner"]>



  export type DinerSelectScalar = {
    id?: boolean
    regionId?: boolean
    categoryId?: boolean
    name?: boolean
    phoneNumber?: boolean
    address?: boolean
    rating?: boolean
  }

  export type DinerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "regionId" | "categoryId" | "name" | "phoneNumber" | "address" | "rating", ExtArgs["result"]["diner"]>
  export type DinerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    category?: boolean | FoodCategoryDefaultArgs<ExtArgs>
    dinerMissions?: boolean | Diner$dinerMissionsArgs<ExtArgs>
    reviews?: boolean | Diner$reviewsArgs<ExtArgs>
    _count?: boolean | DinerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DinerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Diner"
    objects: {
      region: Prisma.$RegionPayload<ExtArgs>
      category: Prisma.$FoodCategoryPayload<ExtArgs>
      dinerMissions: Prisma.$DinerMissionPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      regionId: number
      categoryId: number
      name: string
      phoneNumber: string | null
      address: string | null
      rating: number | null
    }, ExtArgs["result"]["diner"]>
    composites: {}
  }

  type DinerGetPayload<S extends boolean | null | undefined | DinerDefaultArgs> = $Result.GetResult<Prisma.$DinerPayload, S>

  type DinerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DinerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DinerCountAggregateInputType | true
    }

  export interface DinerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Diner'], meta: { name: 'Diner' } }
    /**
     * Find zero or one Diner that matches the filter.
     * @param {DinerFindUniqueArgs} args - Arguments to find a Diner
     * @example
     * // Get one Diner
     * const diner = await prisma.diner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DinerFindUniqueArgs>(args: SelectSubset<T, DinerFindUniqueArgs<ExtArgs>>): Prisma__DinerClient<$Result.GetResult<Prisma.$DinerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Diner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DinerFindUniqueOrThrowArgs} args - Arguments to find a Diner
     * @example
     * // Get one Diner
     * const diner = await prisma.diner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DinerFindUniqueOrThrowArgs>(args: SelectSubset<T, DinerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DinerClient<$Result.GetResult<Prisma.$DinerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Diner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinerFindFirstArgs} args - Arguments to find a Diner
     * @example
     * // Get one Diner
     * const diner = await prisma.diner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DinerFindFirstArgs>(args?: SelectSubset<T, DinerFindFirstArgs<ExtArgs>>): Prisma__DinerClient<$Result.GetResult<Prisma.$DinerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Diner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinerFindFirstOrThrowArgs} args - Arguments to find a Diner
     * @example
     * // Get one Diner
     * const diner = await prisma.diner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DinerFindFirstOrThrowArgs>(args?: SelectSubset<T, DinerFindFirstOrThrowArgs<ExtArgs>>): Prisma__DinerClient<$Result.GetResult<Prisma.$DinerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Diners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diners
     * const diners = await prisma.diner.findMany()
     * 
     * // Get first 10 Diners
     * const diners = await prisma.diner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dinerWithIdOnly = await prisma.diner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DinerFindManyArgs>(args?: SelectSubset<T, DinerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DinerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Diner.
     * @param {DinerCreateArgs} args - Arguments to create a Diner.
     * @example
     * // Create one Diner
     * const Diner = await prisma.diner.create({
     *   data: {
     *     // ... data to create a Diner
     *   }
     * })
     * 
     */
    create<T extends DinerCreateArgs>(args: SelectSubset<T, DinerCreateArgs<ExtArgs>>): Prisma__DinerClient<$Result.GetResult<Prisma.$DinerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Diners.
     * @param {DinerCreateManyArgs} args - Arguments to create many Diners.
     * @example
     * // Create many Diners
     * const diner = await prisma.diner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DinerCreateManyArgs>(args?: SelectSubset<T, DinerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Diner.
     * @param {DinerDeleteArgs} args - Arguments to delete one Diner.
     * @example
     * // Delete one Diner
     * const Diner = await prisma.diner.delete({
     *   where: {
     *     // ... filter to delete one Diner
     *   }
     * })
     * 
     */
    delete<T extends DinerDeleteArgs>(args: SelectSubset<T, DinerDeleteArgs<ExtArgs>>): Prisma__DinerClient<$Result.GetResult<Prisma.$DinerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Diner.
     * @param {DinerUpdateArgs} args - Arguments to update one Diner.
     * @example
     * // Update one Diner
     * const diner = await prisma.diner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DinerUpdateArgs>(args: SelectSubset<T, DinerUpdateArgs<ExtArgs>>): Prisma__DinerClient<$Result.GetResult<Prisma.$DinerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Diners.
     * @param {DinerDeleteManyArgs} args - Arguments to filter Diners to delete.
     * @example
     * // Delete a few Diners
     * const { count } = await prisma.diner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DinerDeleteManyArgs>(args?: SelectSubset<T, DinerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diners
     * const diner = await prisma.diner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DinerUpdateManyArgs>(args: SelectSubset<T, DinerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Diner.
     * @param {DinerUpsertArgs} args - Arguments to update or create a Diner.
     * @example
     * // Update or create a Diner
     * const diner = await prisma.diner.upsert({
     *   create: {
     *     // ... data to create a Diner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diner we want to update
     *   }
     * })
     */
    upsert<T extends DinerUpsertArgs>(args: SelectSubset<T, DinerUpsertArgs<ExtArgs>>): Prisma__DinerClient<$Result.GetResult<Prisma.$DinerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Diners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinerCountArgs} args - Arguments to filter Diners to count.
     * @example
     * // Count the number of Diners
     * const count = await prisma.diner.count({
     *   where: {
     *     // ... the filter for the Diners we want to count
     *   }
     * })
    **/
    count<T extends DinerCountArgs>(
      args?: Subset<T, DinerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DinerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DinerAggregateArgs>(args: Subset<T, DinerAggregateArgs>): Prisma.PrismaPromise<GetDinerAggregateType<T>>

    /**
     * Group by Diner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DinerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DinerGroupByArgs['orderBy'] }
        : { orderBy?: DinerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DinerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDinerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Diner model
   */
  readonly fields: DinerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Diner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DinerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    region<T extends RegionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionDefaultArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends FoodCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodCategoryDefaultArgs<ExtArgs>>): Prisma__FoodCategoryClient<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dinerMissions<T extends Diner$dinerMissionsArgs<ExtArgs> = {}>(args?: Subset<T, Diner$dinerMissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DinerMissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Diner$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Diner$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Diner model
   */
  interface DinerFieldRefs {
    readonly id: FieldRef<"Diner", 'Int'>
    readonly regionId: FieldRef<"Diner", 'Int'>
    readonly categoryId: FieldRef<"Diner", 'Int'>
    readonly name: FieldRef<"Diner", 'String'>
    readonly phoneNumber: FieldRef<"Diner", 'String'>
    readonly address: FieldRef<"Diner", 'String'>
    readonly rating: FieldRef<"Diner", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Diner findUnique
   */
  export type DinerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diner
     */
    select?: DinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diner
     */
    omit?: DinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerInclude<ExtArgs> | null
    /**
     * Filter, which Diner to fetch.
     */
    where: DinerWhereUniqueInput
  }

  /**
   * Diner findUniqueOrThrow
   */
  export type DinerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diner
     */
    select?: DinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diner
     */
    omit?: DinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerInclude<ExtArgs> | null
    /**
     * Filter, which Diner to fetch.
     */
    where: DinerWhereUniqueInput
  }

  /**
   * Diner findFirst
   */
  export type DinerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diner
     */
    select?: DinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diner
     */
    omit?: DinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerInclude<ExtArgs> | null
    /**
     * Filter, which Diner to fetch.
     */
    where?: DinerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diners to fetch.
     */
    orderBy?: DinerOrderByWithRelationInput | DinerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diners.
     */
    cursor?: DinerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diners.
     */
    distinct?: DinerScalarFieldEnum | DinerScalarFieldEnum[]
  }

  /**
   * Diner findFirstOrThrow
   */
  export type DinerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diner
     */
    select?: DinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diner
     */
    omit?: DinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerInclude<ExtArgs> | null
    /**
     * Filter, which Diner to fetch.
     */
    where?: DinerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diners to fetch.
     */
    orderBy?: DinerOrderByWithRelationInput | DinerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diners.
     */
    cursor?: DinerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diners.
     */
    distinct?: DinerScalarFieldEnum | DinerScalarFieldEnum[]
  }

  /**
   * Diner findMany
   */
  export type DinerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diner
     */
    select?: DinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diner
     */
    omit?: DinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerInclude<ExtArgs> | null
    /**
     * Filter, which Diners to fetch.
     */
    where?: DinerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diners to fetch.
     */
    orderBy?: DinerOrderByWithRelationInput | DinerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Diners.
     */
    cursor?: DinerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diners.
     */
    skip?: number
    distinct?: DinerScalarFieldEnum | DinerScalarFieldEnum[]
  }

  /**
   * Diner create
   */
  export type DinerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diner
     */
    select?: DinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diner
     */
    omit?: DinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerInclude<ExtArgs> | null
    /**
     * The data needed to create a Diner.
     */
    data: XOR<DinerCreateInput, DinerUncheckedCreateInput>
  }

  /**
   * Diner createMany
   */
  export type DinerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Diners.
     */
    data: DinerCreateManyInput | DinerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Diner update
   */
  export type DinerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diner
     */
    select?: DinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diner
     */
    omit?: DinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerInclude<ExtArgs> | null
    /**
     * The data needed to update a Diner.
     */
    data: XOR<DinerUpdateInput, DinerUncheckedUpdateInput>
    /**
     * Choose, which Diner to update.
     */
    where: DinerWhereUniqueInput
  }

  /**
   * Diner updateMany
   */
  export type DinerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Diners.
     */
    data: XOR<DinerUpdateManyMutationInput, DinerUncheckedUpdateManyInput>
    /**
     * Filter which Diners to update
     */
    where?: DinerWhereInput
    /**
     * Limit how many Diners to update.
     */
    limit?: number
  }

  /**
   * Diner upsert
   */
  export type DinerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diner
     */
    select?: DinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diner
     */
    omit?: DinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerInclude<ExtArgs> | null
    /**
     * The filter to search for the Diner to update in case it exists.
     */
    where: DinerWhereUniqueInput
    /**
     * In case the Diner found by the `where` argument doesn't exist, create a new Diner with this data.
     */
    create: XOR<DinerCreateInput, DinerUncheckedCreateInput>
    /**
     * In case the Diner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DinerUpdateInput, DinerUncheckedUpdateInput>
  }

  /**
   * Diner delete
   */
  export type DinerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diner
     */
    select?: DinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diner
     */
    omit?: DinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerInclude<ExtArgs> | null
    /**
     * Filter which Diner to delete.
     */
    where: DinerWhereUniqueInput
  }

  /**
   * Diner deleteMany
   */
  export type DinerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diners to delete
     */
    where?: DinerWhereInput
    /**
     * Limit how many Diners to delete.
     */
    limit?: number
  }

  /**
   * Diner.dinerMissions
   */
  export type Diner$dinerMissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DinerMission
     */
    select?: DinerMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DinerMission
     */
    omit?: DinerMissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerMissionInclude<ExtArgs> | null
    where?: DinerMissionWhereInput
    orderBy?: DinerMissionOrderByWithRelationInput | DinerMissionOrderByWithRelationInput[]
    cursor?: DinerMissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DinerMissionScalarFieldEnum | DinerMissionScalarFieldEnum[]
  }

  /**
   * Diner.reviews
   */
  export type Diner$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Diner without action
   */
  export type DinerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diner
     */
    select?: DinerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Diner
     */
    omit?: DinerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerInclude<ExtArgs> | null
  }


  /**
   * Model Mission
   */

  export type AggregateMission = {
    _count: MissionCountAggregateOutputType | null
    _avg: MissionAvgAggregateOutputType | null
    _sum: MissionSumAggregateOutputType | null
    _min: MissionMinAggregateOutputType | null
    _max: MissionMaxAggregateOutputType | null
  }

  export type MissionAvgAggregateOutputType = {
    id: number | null
    pointReward: number | null
  }

  export type MissionSumAggregateOutputType = {
    id: number | null
    pointReward: number | null
  }

  export type MissionMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    pointReward: number | null
  }

  export type MissionMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    pointReward: number | null
  }

  export type MissionCountAggregateOutputType = {
    id: number
    title: number
    description: number
    pointReward: number
    _all: number
  }


  export type MissionAvgAggregateInputType = {
    id?: true
    pointReward?: true
  }

  export type MissionSumAggregateInputType = {
    id?: true
    pointReward?: true
  }

  export type MissionMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    pointReward?: true
  }

  export type MissionMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    pointReward?: true
  }

  export type MissionCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    pointReward?: true
    _all?: true
  }

  export type MissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mission to aggregate.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Missions
    **/
    _count?: true | MissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MissionMaxAggregateInputType
  }

  export type GetMissionAggregateType<T extends MissionAggregateArgs> = {
        [P in keyof T & keyof AggregateMission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMission[P]>
      : GetScalarType<T[P], AggregateMission[P]>
  }




  export type MissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionWhereInput
    orderBy?: MissionOrderByWithAggregationInput | MissionOrderByWithAggregationInput[]
    by: MissionScalarFieldEnum[] | MissionScalarFieldEnum
    having?: MissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MissionCountAggregateInputType | true
    _avg?: MissionAvgAggregateInputType
    _sum?: MissionSumAggregateInputType
    _min?: MissionMinAggregateInputType
    _max?: MissionMaxAggregateInputType
  }

  export type MissionGroupByOutputType = {
    id: number
    title: string
    description: string | null
    pointReward: number
    _count: MissionCountAggregateOutputType | null
    _avg: MissionAvgAggregateOutputType | null
    _sum: MissionSumAggregateOutputType | null
    _min: MissionMinAggregateOutputType | null
    _max: MissionMaxAggregateOutputType | null
  }

  type GetMissionGroupByPayload<T extends MissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MissionGroupByOutputType[P]>
            : GetScalarType<T[P], MissionGroupByOutputType[P]>
        }
      >
    >


  export type MissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    pointReward?: boolean
    dinerMissions?: boolean | Mission$dinerMissionsArgs<ExtArgs>
    _count?: boolean | MissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mission"]>



  export type MissionSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    pointReward?: boolean
  }

  export type MissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "pointReward", ExtArgs["result"]["mission"]>
  export type MissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dinerMissions?: boolean | Mission$dinerMissionsArgs<ExtArgs>
    _count?: boolean | MissionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mission"
    objects: {
      dinerMissions: Prisma.$DinerMissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      pointReward: number
    }, ExtArgs["result"]["mission"]>
    composites: {}
  }

  type MissionGetPayload<S extends boolean | null | undefined | MissionDefaultArgs> = $Result.GetResult<Prisma.$MissionPayload, S>

  type MissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MissionCountAggregateInputType | true
    }

  export interface MissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mission'], meta: { name: 'Mission' } }
    /**
     * Find zero or one Mission that matches the filter.
     * @param {MissionFindUniqueArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MissionFindUniqueArgs>(args: SelectSubset<T, MissionFindUniqueArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MissionFindUniqueOrThrowArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MissionFindUniqueOrThrowArgs>(args: SelectSubset<T, MissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFindFirstArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MissionFindFirstArgs>(args?: SelectSubset<T, MissionFindFirstArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFindFirstOrThrowArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MissionFindFirstOrThrowArgs>(args?: SelectSubset<T, MissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Missions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Missions
     * const missions = await prisma.mission.findMany()
     * 
     * // Get first 10 Missions
     * const missions = await prisma.mission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const missionWithIdOnly = await prisma.mission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MissionFindManyArgs>(args?: SelectSubset<T, MissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mission.
     * @param {MissionCreateArgs} args - Arguments to create a Mission.
     * @example
     * // Create one Mission
     * const Mission = await prisma.mission.create({
     *   data: {
     *     // ... data to create a Mission
     *   }
     * })
     * 
     */
    create<T extends MissionCreateArgs>(args: SelectSubset<T, MissionCreateArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Missions.
     * @param {MissionCreateManyArgs} args - Arguments to create many Missions.
     * @example
     * // Create many Missions
     * const mission = await prisma.mission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MissionCreateManyArgs>(args?: SelectSubset<T, MissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Mission.
     * @param {MissionDeleteArgs} args - Arguments to delete one Mission.
     * @example
     * // Delete one Mission
     * const Mission = await prisma.mission.delete({
     *   where: {
     *     // ... filter to delete one Mission
     *   }
     * })
     * 
     */
    delete<T extends MissionDeleteArgs>(args: SelectSubset<T, MissionDeleteArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mission.
     * @param {MissionUpdateArgs} args - Arguments to update one Mission.
     * @example
     * // Update one Mission
     * const mission = await prisma.mission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MissionUpdateArgs>(args: SelectSubset<T, MissionUpdateArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Missions.
     * @param {MissionDeleteManyArgs} args - Arguments to filter Missions to delete.
     * @example
     * // Delete a few Missions
     * const { count } = await prisma.mission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MissionDeleteManyArgs>(args?: SelectSubset<T, MissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Missions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Missions
     * const mission = await prisma.mission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MissionUpdateManyArgs>(args: SelectSubset<T, MissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mission.
     * @param {MissionUpsertArgs} args - Arguments to update or create a Mission.
     * @example
     * // Update or create a Mission
     * const mission = await prisma.mission.upsert({
     *   create: {
     *     // ... data to create a Mission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mission we want to update
     *   }
     * })
     */
    upsert<T extends MissionUpsertArgs>(args: SelectSubset<T, MissionUpsertArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Missions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionCountArgs} args - Arguments to filter Missions to count.
     * @example
     * // Count the number of Missions
     * const count = await prisma.mission.count({
     *   where: {
     *     // ... the filter for the Missions we want to count
     *   }
     * })
    **/
    count<T extends MissionCountArgs>(
      args?: Subset<T, MissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MissionAggregateArgs>(args: Subset<T, MissionAggregateArgs>): Prisma.PrismaPromise<GetMissionAggregateType<T>>

    /**
     * Group by Mission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MissionGroupByArgs['orderBy'] }
        : { orderBy?: MissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mission model
   */
  readonly fields: MissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dinerMissions<T extends Mission$dinerMissionsArgs<ExtArgs> = {}>(args?: Subset<T, Mission$dinerMissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DinerMissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mission model
   */
  interface MissionFieldRefs {
    readonly id: FieldRef<"Mission", 'Int'>
    readonly title: FieldRef<"Mission", 'String'>
    readonly description: FieldRef<"Mission", 'String'>
    readonly pointReward: FieldRef<"Mission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Mission findUnique
   */
  export type MissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission findUniqueOrThrow
   */
  export type MissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission findFirst
   */
  export type MissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Missions.
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Missions.
     */
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * Mission findFirstOrThrow
   */
  export type MissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Missions.
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Missions.
     */
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * Mission findMany
   */
  export type MissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Missions to fetch.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Missions.
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * Mission create
   */
  export type MissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Mission.
     */
    data: XOR<MissionCreateInput, MissionUncheckedCreateInput>
  }

  /**
   * Mission createMany
   */
  export type MissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Missions.
     */
    data: MissionCreateManyInput | MissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mission update
   */
  export type MissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Mission.
     */
    data: XOR<MissionUpdateInput, MissionUncheckedUpdateInput>
    /**
     * Choose, which Mission to update.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission updateMany
   */
  export type MissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Missions.
     */
    data: XOR<MissionUpdateManyMutationInput, MissionUncheckedUpdateManyInput>
    /**
     * Filter which Missions to update
     */
    where?: MissionWhereInput
    /**
     * Limit how many Missions to update.
     */
    limit?: number
  }

  /**
   * Mission upsert
   */
  export type MissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Mission to update in case it exists.
     */
    where: MissionWhereUniqueInput
    /**
     * In case the Mission found by the `where` argument doesn't exist, create a new Mission with this data.
     */
    create: XOR<MissionCreateInput, MissionUncheckedCreateInput>
    /**
     * In case the Mission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MissionUpdateInput, MissionUncheckedUpdateInput>
  }

  /**
   * Mission delete
   */
  export type MissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter which Mission to delete.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission deleteMany
   */
  export type MissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Missions to delete
     */
    where?: MissionWhereInput
    /**
     * Limit how many Missions to delete.
     */
    limit?: number
  }

  /**
   * Mission.dinerMissions
   */
  export type Mission$dinerMissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DinerMission
     */
    select?: DinerMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DinerMission
     */
    omit?: DinerMissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerMissionInclude<ExtArgs> | null
    where?: DinerMissionWhereInput
    orderBy?: DinerMissionOrderByWithRelationInput | DinerMissionOrderByWithRelationInput[]
    cursor?: DinerMissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DinerMissionScalarFieldEnum | DinerMissionScalarFieldEnum[]
  }

  /**
   * Mission without action
   */
  export type MissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mission
     */
    omit?: MissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
  }


  /**
   * Model DinerMission
   */

  export type AggregateDinerMission = {
    _count: DinerMissionCountAggregateOutputType | null
    _avg: DinerMissionAvgAggregateOutputType | null
    _sum: DinerMissionSumAggregateOutputType | null
    _min: DinerMissionMinAggregateOutputType | null
    _max: DinerMissionMaxAggregateOutputType | null
  }

  export type DinerMissionAvgAggregateOutputType = {
    id: number | null
    dinerId: number | null
    missionId: number | null
  }

  export type DinerMissionSumAggregateOutputType = {
    id: number | null
    dinerId: number | null
    missionId: number | null
  }

  export type DinerMissionMinAggregateOutputType = {
    id: number | null
    dinerId: number | null
    missionId: number | null
    startDate: Date | null
    endDate: Date | null
  }

  export type DinerMissionMaxAggregateOutputType = {
    id: number | null
    dinerId: number | null
    missionId: number | null
    startDate: Date | null
    endDate: Date | null
  }

  export type DinerMissionCountAggregateOutputType = {
    id: number
    dinerId: number
    missionId: number
    startDate: number
    endDate: number
    _all: number
  }


  export type DinerMissionAvgAggregateInputType = {
    id?: true
    dinerId?: true
    missionId?: true
  }

  export type DinerMissionSumAggregateInputType = {
    id?: true
    dinerId?: true
    missionId?: true
  }

  export type DinerMissionMinAggregateInputType = {
    id?: true
    dinerId?: true
    missionId?: true
    startDate?: true
    endDate?: true
  }

  export type DinerMissionMaxAggregateInputType = {
    id?: true
    dinerId?: true
    missionId?: true
    startDate?: true
    endDate?: true
  }

  export type DinerMissionCountAggregateInputType = {
    id?: true
    dinerId?: true
    missionId?: true
    startDate?: true
    endDate?: true
    _all?: true
  }

  export type DinerMissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DinerMission to aggregate.
     */
    where?: DinerMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DinerMissions to fetch.
     */
    orderBy?: DinerMissionOrderByWithRelationInput | DinerMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DinerMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DinerMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DinerMissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DinerMissions
    **/
    _count?: true | DinerMissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DinerMissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DinerMissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DinerMissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DinerMissionMaxAggregateInputType
  }

  export type GetDinerMissionAggregateType<T extends DinerMissionAggregateArgs> = {
        [P in keyof T & keyof AggregateDinerMission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDinerMission[P]>
      : GetScalarType<T[P], AggregateDinerMission[P]>
  }




  export type DinerMissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DinerMissionWhereInput
    orderBy?: DinerMissionOrderByWithAggregationInput | DinerMissionOrderByWithAggregationInput[]
    by: DinerMissionScalarFieldEnum[] | DinerMissionScalarFieldEnum
    having?: DinerMissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DinerMissionCountAggregateInputType | true
    _avg?: DinerMissionAvgAggregateInputType
    _sum?: DinerMissionSumAggregateInputType
    _min?: DinerMissionMinAggregateInputType
    _max?: DinerMissionMaxAggregateInputType
  }

  export type DinerMissionGroupByOutputType = {
    id: number
    dinerId: number
    missionId: number
    startDate: Date
    endDate: Date | null
    _count: DinerMissionCountAggregateOutputType | null
    _avg: DinerMissionAvgAggregateOutputType | null
    _sum: DinerMissionSumAggregateOutputType | null
    _min: DinerMissionMinAggregateOutputType | null
    _max: DinerMissionMaxAggregateOutputType | null
  }

  type GetDinerMissionGroupByPayload<T extends DinerMissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DinerMissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DinerMissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DinerMissionGroupByOutputType[P]>
            : GetScalarType<T[P], DinerMissionGroupByOutputType[P]>
        }
      >
    >


  export type DinerMissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dinerId?: boolean
    missionId?: boolean
    startDate?: boolean
    endDate?: boolean
    diner?: boolean | DinerDefaultArgs<ExtArgs>
    mission?: boolean | MissionDefaultArgs<ExtArgs>
    missionClearLogs?: boolean | DinerMission$missionClearLogsArgs<ExtArgs>
    _count?: boolean | DinerMissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dinerMission"]>



  export type DinerMissionSelectScalar = {
    id?: boolean
    dinerId?: boolean
    missionId?: boolean
    startDate?: boolean
    endDate?: boolean
  }

  export type DinerMissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dinerId" | "missionId" | "startDate" | "endDate", ExtArgs["result"]["dinerMission"]>
  export type DinerMissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diner?: boolean | DinerDefaultArgs<ExtArgs>
    mission?: boolean | MissionDefaultArgs<ExtArgs>
    missionClearLogs?: boolean | DinerMission$missionClearLogsArgs<ExtArgs>
    _count?: boolean | DinerMissionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DinerMissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DinerMission"
    objects: {
      diner: Prisma.$DinerPayload<ExtArgs>
      mission: Prisma.$MissionPayload<ExtArgs>
      missionClearLogs: Prisma.$MissionClearLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dinerId: number
      missionId: number
      startDate: Date
      endDate: Date | null
    }, ExtArgs["result"]["dinerMission"]>
    composites: {}
  }

  type DinerMissionGetPayload<S extends boolean | null | undefined | DinerMissionDefaultArgs> = $Result.GetResult<Prisma.$DinerMissionPayload, S>

  type DinerMissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DinerMissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DinerMissionCountAggregateInputType | true
    }

  export interface DinerMissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DinerMission'], meta: { name: 'DinerMission' } }
    /**
     * Find zero or one DinerMission that matches the filter.
     * @param {DinerMissionFindUniqueArgs} args - Arguments to find a DinerMission
     * @example
     * // Get one DinerMission
     * const dinerMission = await prisma.dinerMission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DinerMissionFindUniqueArgs>(args: SelectSubset<T, DinerMissionFindUniqueArgs<ExtArgs>>): Prisma__DinerMissionClient<$Result.GetResult<Prisma.$DinerMissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DinerMission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DinerMissionFindUniqueOrThrowArgs} args - Arguments to find a DinerMission
     * @example
     * // Get one DinerMission
     * const dinerMission = await prisma.dinerMission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DinerMissionFindUniqueOrThrowArgs>(args: SelectSubset<T, DinerMissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DinerMissionClient<$Result.GetResult<Prisma.$DinerMissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DinerMission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinerMissionFindFirstArgs} args - Arguments to find a DinerMission
     * @example
     * // Get one DinerMission
     * const dinerMission = await prisma.dinerMission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DinerMissionFindFirstArgs>(args?: SelectSubset<T, DinerMissionFindFirstArgs<ExtArgs>>): Prisma__DinerMissionClient<$Result.GetResult<Prisma.$DinerMissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DinerMission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinerMissionFindFirstOrThrowArgs} args - Arguments to find a DinerMission
     * @example
     * // Get one DinerMission
     * const dinerMission = await prisma.dinerMission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DinerMissionFindFirstOrThrowArgs>(args?: SelectSubset<T, DinerMissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DinerMissionClient<$Result.GetResult<Prisma.$DinerMissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DinerMissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinerMissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DinerMissions
     * const dinerMissions = await prisma.dinerMission.findMany()
     * 
     * // Get first 10 DinerMissions
     * const dinerMissions = await prisma.dinerMission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dinerMissionWithIdOnly = await prisma.dinerMission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DinerMissionFindManyArgs>(args?: SelectSubset<T, DinerMissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DinerMissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DinerMission.
     * @param {DinerMissionCreateArgs} args - Arguments to create a DinerMission.
     * @example
     * // Create one DinerMission
     * const DinerMission = await prisma.dinerMission.create({
     *   data: {
     *     // ... data to create a DinerMission
     *   }
     * })
     * 
     */
    create<T extends DinerMissionCreateArgs>(args: SelectSubset<T, DinerMissionCreateArgs<ExtArgs>>): Prisma__DinerMissionClient<$Result.GetResult<Prisma.$DinerMissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DinerMissions.
     * @param {DinerMissionCreateManyArgs} args - Arguments to create many DinerMissions.
     * @example
     * // Create many DinerMissions
     * const dinerMission = await prisma.dinerMission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DinerMissionCreateManyArgs>(args?: SelectSubset<T, DinerMissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DinerMission.
     * @param {DinerMissionDeleteArgs} args - Arguments to delete one DinerMission.
     * @example
     * // Delete one DinerMission
     * const DinerMission = await prisma.dinerMission.delete({
     *   where: {
     *     // ... filter to delete one DinerMission
     *   }
     * })
     * 
     */
    delete<T extends DinerMissionDeleteArgs>(args: SelectSubset<T, DinerMissionDeleteArgs<ExtArgs>>): Prisma__DinerMissionClient<$Result.GetResult<Prisma.$DinerMissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DinerMission.
     * @param {DinerMissionUpdateArgs} args - Arguments to update one DinerMission.
     * @example
     * // Update one DinerMission
     * const dinerMission = await prisma.dinerMission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DinerMissionUpdateArgs>(args: SelectSubset<T, DinerMissionUpdateArgs<ExtArgs>>): Prisma__DinerMissionClient<$Result.GetResult<Prisma.$DinerMissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DinerMissions.
     * @param {DinerMissionDeleteManyArgs} args - Arguments to filter DinerMissions to delete.
     * @example
     * // Delete a few DinerMissions
     * const { count } = await prisma.dinerMission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DinerMissionDeleteManyArgs>(args?: SelectSubset<T, DinerMissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DinerMissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinerMissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DinerMissions
     * const dinerMission = await prisma.dinerMission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DinerMissionUpdateManyArgs>(args: SelectSubset<T, DinerMissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DinerMission.
     * @param {DinerMissionUpsertArgs} args - Arguments to update or create a DinerMission.
     * @example
     * // Update or create a DinerMission
     * const dinerMission = await prisma.dinerMission.upsert({
     *   create: {
     *     // ... data to create a DinerMission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DinerMission we want to update
     *   }
     * })
     */
    upsert<T extends DinerMissionUpsertArgs>(args: SelectSubset<T, DinerMissionUpsertArgs<ExtArgs>>): Prisma__DinerMissionClient<$Result.GetResult<Prisma.$DinerMissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DinerMissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinerMissionCountArgs} args - Arguments to filter DinerMissions to count.
     * @example
     * // Count the number of DinerMissions
     * const count = await prisma.dinerMission.count({
     *   where: {
     *     // ... the filter for the DinerMissions we want to count
     *   }
     * })
    **/
    count<T extends DinerMissionCountArgs>(
      args?: Subset<T, DinerMissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DinerMissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DinerMission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinerMissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DinerMissionAggregateArgs>(args: Subset<T, DinerMissionAggregateArgs>): Prisma.PrismaPromise<GetDinerMissionAggregateType<T>>

    /**
     * Group by DinerMission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DinerMissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DinerMissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DinerMissionGroupByArgs['orderBy'] }
        : { orderBy?: DinerMissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DinerMissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDinerMissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DinerMission model
   */
  readonly fields: DinerMissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DinerMission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DinerMissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    diner<T extends DinerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DinerDefaultArgs<ExtArgs>>): Prisma__DinerClient<$Result.GetResult<Prisma.$DinerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mission<T extends MissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MissionDefaultArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    missionClearLogs<T extends DinerMission$missionClearLogsArgs<ExtArgs> = {}>(args?: Subset<T, DinerMission$missionClearLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionClearLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DinerMission model
   */
  interface DinerMissionFieldRefs {
    readonly id: FieldRef<"DinerMission", 'Int'>
    readonly dinerId: FieldRef<"DinerMission", 'Int'>
    readonly missionId: FieldRef<"DinerMission", 'Int'>
    readonly startDate: FieldRef<"DinerMission", 'DateTime'>
    readonly endDate: FieldRef<"DinerMission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DinerMission findUnique
   */
  export type DinerMissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DinerMission
     */
    select?: DinerMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DinerMission
     */
    omit?: DinerMissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerMissionInclude<ExtArgs> | null
    /**
     * Filter, which DinerMission to fetch.
     */
    where: DinerMissionWhereUniqueInput
  }

  /**
   * DinerMission findUniqueOrThrow
   */
  export type DinerMissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DinerMission
     */
    select?: DinerMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DinerMission
     */
    omit?: DinerMissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerMissionInclude<ExtArgs> | null
    /**
     * Filter, which DinerMission to fetch.
     */
    where: DinerMissionWhereUniqueInput
  }

  /**
   * DinerMission findFirst
   */
  export type DinerMissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DinerMission
     */
    select?: DinerMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DinerMission
     */
    omit?: DinerMissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerMissionInclude<ExtArgs> | null
    /**
     * Filter, which DinerMission to fetch.
     */
    where?: DinerMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DinerMissions to fetch.
     */
    orderBy?: DinerMissionOrderByWithRelationInput | DinerMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DinerMissions.
     */
    cursor?: DinerMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DinerMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DinerMissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DinerMissions.
     */
    distinct?: DinerMissionScalarFieldEnum | DinerMissionScalarFieldEnum[]
  }

  /**
   * DinerMission findFirstOrThrow
   */
  export type DinerMissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DinerMission
     */
    select?: DinerMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DinerMission
     */
    omit?: DinerMissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerMissionInclude<ExtArgs> | null
    /**
     * Filter, which DinerMission to fetch.
     */
    where?: DinerMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DinerMissions to fetch.
     */
    orderBy?: DinerMissionOrderByWithRelationInput | DinerMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DinerMissions.
     */
    cursor?: DinerMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DinerMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DinerMissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DinerMissions.
     */
    distinct?: DinerMissionScalarFieldEnum | DinerMissionScalarFieldEnum[]
  }

  /**
   * DinerMission findMany
   */
  export type DinerMissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DinerMission
     */
    select?: DinerMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DinerMission
     */
    omit?: DinerMissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerMissionInclude<ExtArgs> | null
    /**
     * Filter, which DinerMissions to fetch.
     */
    where?: DinerMissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DinerMissions to fetch.
     */
    orderBy?: DinerMissionOrderByWithRelationInput | DinerMissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DinerMissions.
     */
    cursor?: DinerMissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DinerMissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DinerMissions.
     */
    skip?: number
    distinct?: DinerMissionScalarFieldEnum | DinerMissionScalarFieldEnum[]
  }

  /**
   * DinerMission create
   */
  export type DinerMissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DinerMission
     */
    select?: DinerMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DinerMission
     */
    omit?: DinerMissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerMissionInclude<ExtArgs> | null
    /**
     * The data needed to create a DinerMission.
     */
    data: XOR<DinerMissionCreateInput, DinerMissionUncheckedCreateInput>
  }

  /**
   * DinerMission createMany
   */
  export type DinerMissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DinerMissions.
     */
    data: DinerMissionCreateManyInput | DinerMissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DinerMission update
   */
  export type DinerMissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DinerMission
     */
    select?: DinerMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DinerMission
     */
    omit?: DinerMissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerMissionInclude<ExtArgs> | null
    /**
     * The data needed to update a DinerMission.
     */
    data: XOR<DinerMissionUpdateInput, DinerMissionUncheckedUpdateInput>
    /**
     * Choose, which DinerMission to update.
     */
    where: DinerMissionWhereUniqueInput
  }

  /**
   * DinerMission updateMany
   */
  export type DinerMissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DinerMissions.
     */
    data: XOR<DinerMissionUpdateManyMutationInput, DinerMissionUncheckedUpdateManyInput>
    /**
     * Filter which DinerMissions to update
     */
    where?: DinerMissionWhereInput
    /**
     * Limit how many DinerMissions to update.
     */
    limit?: number
  }

  /**
   * DinerMission upsert
   */
  export type DinerMissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DinerMission
     */
    select?: DinerMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DinerMission
     */
    omit?: DinerMissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerMissionInclude<ExtArgs> | null
    /**
     * The filter to search for the DinerMission to update in case it exists.
     */
    where: DinerMissionWhereUniqueInput
    /**
     * In case the DinerMission found by the `where` argument doesn't exist, create a new DinerMission with this data.
     */
    create: XOR<DinerMissionCreateInput, DinerMissionUncheckedCreateInput>
    /**
     * In case the DinerMission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DinerMissionUpdateInput, DinerMissionUncheckedUpdateInput>
  }

  /**
   * DinerMission delete
   */
  export type DinerMissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DinerMission
     */
    select?: DinerMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DinerMission
     */
    omit?: DinerMissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerMissionInclude<ExtArgs> | null
    /**
     * Filter which DinerMission to delete.
     */
    where: DinerMissionWhereUniqueInput
  }

  /**
   * DinerMission deleteMany
   */
  export type DinerMissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DinerMissions to delete
     */
    where?: DinerMissionWhereInput
    /**
     * Limit how many DinerMissions to delete.
     */
    limit?: number
  }

  /**
   * DinerMission.missionClearLogs
   */
  export type DinerMission$missionClearLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionClearLog
     */
    select?: MissionClearLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissionClearLog
     */
    omit?: MissionClearLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionClearLogInclude<ExtArgs> | null
    where?: MissionClearLogWhereInput
    orderBy?: MissionClearLogOrderByWithRelationInput | MissionClearLogOrderByWithRelationInput[]
    cursor?: MissionClearLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MissionClearLogScalarFieldEnum | MissionClearLogScalarFieldEnum[]
  }

  /**
   * DinerMission without action
   */
  export type DinerMissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DinerMission
     */
    select?: DinerMissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DinerMission
     */
    omit?: DinerMissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DinerMissionInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    id: number | null
    dinerId: number | null
    userId: number | null
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    id: number | null
    dinerId: number | null
    userId: number | null
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: number | null
    dinerId: number | null
    userId: number | null
    rating: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: number | null
    dinerId: number | null
    userId: number | null
    rating: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    dinerId: number
    userId: number
    rating: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    id?: true
    dinerId?: true
    userId?: true
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    id?: true
    dinerId?: true
    userId?: true
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    dinerId?: true
    userId?: true
    rating?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    dinerId?: true
    userId?: true
    rating?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    dinerId?: true
    userId?: true
    rating?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: number
    dinerId: number
    userId: number
    rating: number
    content: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dinerId?: boolean
    userId?: boolean
    rating?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    diner?: boolean | DinerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>



  export type ReviewSelectScalar = {
    id?: boolean
    dinerId?: boolean
    userId?: boolean
    rating?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dinerId" | "userId" | "rating" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diner?: boolean | DinerDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      diner: Prisma.$DinerPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dinerId: number
      userId: number
      rating: number
      content: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    diner<T extends DinerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DinerDefaultArgs<ExtArgs>>): Prisma__DinerClient<$Result.GetResult<Prisma.$DinerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'Int'>
    readonly dinerId: FieldRef<"Review", 'Int'>
    readonly userId: FieldRef<"Review", 'Int'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly content: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model PointHistory
   */

  export type AggregatePointHistory = {
    _count: PointHistoryCountAggregateOutputType | null
    _avg: PointHistoryAvgAggregateOutputType | null
    _sum: PointHistorySumAggregateOutputType | null
    _min: PointHistoryMinAggregateOutputType | null
    _max: PointHistoryMaxAggregateOutputType | null
  }

  export type PointHistoryAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
  }

  export type PointHistorySumAggregateOutputType = {
    id: number | null
    userId: number | null
    amount: number | null
  }

  export type PointHistoryMinAggregateOutputType = {
    id: number | null
    userId: number | null
    historyDate: Date | null
    description: string | null
    amount: number | null
  }

  export type PointHistoryMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    historyDate: Date | null
    description: string | null
    amount: number | null
  }

  export type PointHistoryCountAggregateOutputType = {
    id: number
    userId: number
    historyDate: number
    description: number
    amount: number
    _all: number
  }


  export type PointHistoryAvgAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
  }

  export type PointHistorySumAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
  }

  export type PointHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    historyDate?: true
    description?: true
    amount?: true
  }

  export type PointHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    historyDate?: true
    description?: true
    amount?: true
  }

  export type PointHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    historyDate?: true
    description?: true
    amount?: true
    _all?: true
  }

  export type PointHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointHistory to aggregate.
     */
    where?: PointHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointHistories to fetch.
     */
    orderBy?: PointHistoryOrderByWithRelationInput | PointHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PointHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PointHistories
    **/
    _count?: true | PointHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PointHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PointHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointHistoryMaxAggregateInputType
  }

  export type GetPointHistoryAggregateType<T extends PointHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePointHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePointHistory[P]>
      : GetScalarType<T[P], AggregatePointHistory[P]>
  }




  export type PointHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointHistoryWhereInput
    orderBy?: PointHistoryOrderByWithAggregationInput | PointHistoryOrderByWithAggregationInput[]
    by: PointHistoryScalarFieldEnum[] | PointHistoryScalarFieldEnum
    having?: PointHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointHistoryCountAggregateInputType | true
    _avg?: PointHistoryAvgAggregateInputType
    _sum?: PointHistorySumAggregateInputType
    _min?: PointHistoryMinAggregateInputType
    _max?: PointHistoryMaxAggregateInputType
  }

  export type PointHistoryGroupByOutputType = {
    id: number
    userId: number
    historyDate: Date
    description: string | null
    amount: number
    _count: PointHistoryCountAggregateOutputType | null
    _avg: PointHistoryAvgAggregateOutputType | null
    _sum: PointHistorySumAggregateOutputType | null
    _min: PointHistoryMinAggregateOutputType | null
    _max: PointHistoryMaxAggregateOutputType | null
  }

  type GetPointHistoryGroupByPayload<T extends PointHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PointHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PointHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PointHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    historyDate?: boolean
    description?: boolean
    amount?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    missionClearLogs?: boolean | PointHistory$missionClearLogsArgs<ExtArgs>
    _count?: boolean | PointHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointHistory"]>



  export type PointHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    historyDate?: boolean
    description?: boolean
    amount?: boolean
  }

  export type PointHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "historyDate" | "description" | "amount", ExtArgs["result"]["pointHistory"]>
  export type PointHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    missionClearLogs?: boolean | PointHistory$missionClearLogsArgs<ExtArgs>
    _count?: boolean | PointHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PointHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PointHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      missionClearLogs: Prisma.$MissionClearLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      historyDate: Date
      description: string | null
      amount: number
    }, ExtArgs["result"]["pointHistory"]>
    composites: {}
  }

  type PointHistoryGetPayload<S extends boolean | null | undefined | PointHistoryDefaultArgs> = $Result.GetResult<Prisma.$PointHistoryPayload, S>

  type PointHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PointHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PointHistoryCountAggregateInputType | true
    }

  export interface PointHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PointHistory'], meta: { name: 'PointHistory' } }
    /**
     * Find zero or one PointHistory that matches the filter.
     * @param {PointHistoryFindUniqueArgs} args - Arguments to find a PointHistory
     * @example
     * // Get one PointHistory
     * const pointHistory = await prisma.pointHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PointHistoryFindUniqueArgs>(args: SelectSubset<T, PointHistoryFindUniqueArgs<ExtArgs>>): Prisma__PointHistoryClient<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PointHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PointHistoryFindUniqueOrThrowArgs} args - Arguments to find a PointHistory
     * @example
     * // Get one PointHistory
     * const pointHistory = await prisma.pointHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PointHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PointHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PointHistoryClient<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointHistoryFindFirstArgs} args - Arguments to find a PointHistory
     * @example
     * // Get one PointHistory
     * const pointHistory = await prisma.pointHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PointHistoryFindFirstArgs>(args?: SelectSubset<T, PointHistoryFindFirstArgs<ExtArgs>>): Prisma__PointHistoryClient<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointHistoryFindFirstOrThrowArgs} args - Arguments to find a PointHistory
     * @example
     * // Get one PointHistory
     * const pointHistory = await prisma.pointHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PointHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PointHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PointHistoryClient<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PointHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PointHistories
     * const pointHistories = await prisma.pointHistory.findMany()
     * 
     * // Get first 10 PointHistories
     * const pointHistories = await prisma.pointHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pointHistoryWithIdOnly = await prisma.pointHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PointHistoryFindManyArgs>(args?: SelectSubset<T, PointHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PointHistory.
     * @param {PointHistoryCreateArgs} args - Arguments to create a PointHistory.
     * @example
     * // Create one PointHistory
     * const PointHistory = await prisma.pointHistory.create({
     *   data: {
     *     // ... data to create a PointHistory
     *   }
     * })
     * 
     */
    create<T extends PointHistoryCreateArgs>(args: SelectSubset<T, PointHistoryCreateArgs<ExtArgs>>): Prisma__PointHistoryClient<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PointHistories.
     * @param {PointHistoryCreateManyArgs} args - Arguments to create many PointHistories.
     * @example
     * // Create many PointHistories
     * const pointHistory = await prisma.pointHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PointHistoryCreateManyArgs>(args?: SelectSubset<T, PointHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PointHistory.
     * @param {PointHistoryDeleteArgs} args - Arguments to delete one PointHistory.
     * @example
     * // Delete one PointHistory
     * const PointHistory = await prisma.pointHistory.delete({
     *   where: {
     *     // ... filter to delete one PointHistory
     *   }
     * })
     * 
     */
    delete<T extends PointHistoryDeleteArgs>(args: SelectSubset<T, PointHistoryDeleteArgs<ExtArgs>>): Prisma__PointHistoryClient<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PointHistory.
     * @param {PointHistoryUpdateArgs} args - Arguments to update one PointHistory.
     * @example
     * // Update one PointHistory
     * const pointHistory = await prisma.pointHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PointHistoryUpdateArgs>(args: SelectSubset<T, PointHistoryUpdateArgs<ExtArgs>>): Prisma__PointHistoryClient<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PointHistories.
     * @param {PointHistoryDeleteManyArgs} args - Arguments to filter PointHistories to delete.
     * @example
     * // Delete a few PointHistories
     * const { count } = await prisma.pointHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PointHistoryDeleteManyArgs>(args?: SelectSubset<T, PointHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PointHistories
     * const pointHistory = await prisma.pointHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PointHistoryUpdateManyArgs>(args: SelectSubset<T, PointHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PointHistory.
     * @param {PointHistoryUpsertArgs} args - Arguments to update or create a PointHistory.
     * @example
     * // Update or create a PointHistory
     * const pointHistory = await prisma.pointHistory.upsert({
     *   create: {
     *     // ... data to create a PointHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PointHistory we want to update
     *   }
     * })
     */
    upsert<T extends PointHistoryUpsertArgs>(args: SelectSubset<T, PointHistoryUpsertArgs<ExtArgs>>): Prisma__PointHistoryClient<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PointHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointHistoryCountArgs} args - Arguments to filter PointHistories to count.
     * @example
     * // Count the number of PointHistories
     * const count = await prisma.pointHistory.count({
     *   where: {
     *     // ... the filter for the PointHistories we want to count
     *   }
     * })
    **/
    count<T extends PointHistoryCountArgs>(
      args?: Subset<T, PointHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PointHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointHistoryAggregateArgs>(args: Subset<T, PointHistoryAggregateArgs>): Prisma.PrismaPromise<GetPointHistoryAggregateType<T>>

    /**
     * Group by PointHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PointHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PointHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PointHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PointHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PointHistory model
   */
  readonly fields: PointHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PointHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PointHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    missionClearLogs<T extends PointHistory$missionClearLogsArgs<ExtArgs> = {}>(args?: Subset<T, PointHistory$missionClearLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionClearLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PointHistory model
   */
  interface PointHistoryFieldRefs {
    readonly id: FieldRef<"PointHistory", 'Int'>
    readonly userId: FieldRef<"PointHistory", 'Int'>
    readonly historyDate: FieldRef<"PointHistory", 'DateTime'>
    readonly description: FieldRef<"PointHistory", 'String'>
    readonly amount: FieldRef<"PointHistory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PointHistory findUnique
   */
  export type PointHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PointHistory to fetch.
     */
    where: PointHistoryWhereUniqueInput
  }

  /**
   * PointHistory findUniqueOrThrow
   */
  export type PointHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PointHistory to fetch.
     */
    where: PointHistoryWhereUniqueInput
  }

  /**
   * PointHistory findFirst
   */
  export type PointHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PointHistory to fetch.
     */
    where?: PointHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointHistories to fetch.
     */
    orderBy?: PointHistoryOrderByWithRelationInput | PointHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointHistories.
     */
    cursor?: PointHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointHistories.
     */
    distinct?: PointHistoryScalarFieldEnum | PointHistoryScalarFieldEnum[]
  }

  /**
   * PointHistory findFirstOrThrow
   */
  export type PointHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PointHistory to fetch.
     */
    where?: PointHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointHistories to fetch.
     */
    orderBy?: PointHistoryOrderByWithRelationInput | PointHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointHistories.
     */
    cursor?: PointHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointHistories.
     */
    distinct?: PointHistoryScalarFieldEnum | PointHistoryScalarFieldEnum[]
  }

  /**
   * PointHistory findMany
   */
  export type PointHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PointHistories to fetch.
     */
    where?: PointHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointHistories to fetch.
     */
    orderBy?: PointHistoryOrderByWithRelationInput | PointHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PointHistories.
     */
    cursor?: PointHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointHistories.
     */
    skip?: number
    distinct?: PointHistoryScalarFieldEnum | PointHistoryScalarFieldEnum[]
  }

  /**
   * PointHistory create
   */
  export type PointHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PointHistory.
     */
    data: XOR<PointHistoryCreateInput, PointHistoryUncheckedCreateInput>
  }

  /**
   * PointHistory createMany
   */
  export type PointHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PointHistories.
     */
    data: PointHistoryCreateManyInput | PointHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PointHistory update
   */
  export type PointHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PointHistory.
     */
    data: XOR<PointHistoryUpdateInput, PointHistoryUncheckedUpdateInput>
    /**
     * Choose, which PointHistory to update.
     */
    where: PointHistoryWhereUniqueInput
  }

  /**
   * PointHistory updateMany
   */
  export type PointHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PointHistories.
     */
    data: XOR<PointHistoryUpdateManyMutationInput, PointHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PointHistories to update
     */
    where?: PointHistoryWhereInput
    /**
     * Limit how many PointHistories to update.
     */
    limit?: number
  }

  /**
   * PointHistory upsert
   */
  export type PointHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PointHistory to update in case it exists.
     */
    where: PointHistoryWhereUniqueInput
    /**
     * In case the PointHistory found by the `where` argument doesn't exist, create a new PointHistory with this data.
     */
    create: XOR<PointHistoryCreateInput, PointHistoryUncheckedCreateInput>
    /**
     * In case the PointHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PointHistoryUpdateInput, PointHistoryUncheckedUpdateInput>
  }

  /**
   * PointHistory delete
   */
  export type PointHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    /**
     * Filter which PointHistory to delete.
     */
    where: PointHistoryWhereUniqueInput
  }

  /**
   * PointHistory deleteMany
   */
  export type PointHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointHistories to delete
     */
    where?: PointHistoryWhereInput
    /**
     * Limit how many PointHistories to delete.
     */
    limit?: number
  }

  /**
   * PointHistory.missionClearLogs
   */
  export type PointHistory$missionClearLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionClearLog
     */
    select?: MissionClearLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissionClearLog
     */
    omit?: MissionClearLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionClearLogInclude<ExtArgs> | null
    where?: MissionClearLogWhereInput
    orderBy?: MissionClearLogOrderByWithRelationInput | MissionClearLogOrderByWithRelationInput[]
    cursor?: MissionClearLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MissionClearLogScalarFieldEnum | MissionClearLogScalarFieldEnum[]
  }

  /**
   * PointHistory without action
   */
  export type PointHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
  }


  /**
   * Model MissionClearLog
   */

  export type AggregateMissionClearLog = {
    _count: MissionClearLogCountAggregateOutputType | null
    _avg: MissionClearLogAvgAggregateOutputType | null
    _sum: MissionClearLogSumAggregateOutputType | null
    _min: MissionClearLogMinAggregateOutputType | null
    _max: MissionClearLogMaxAggregateOutputType | null
  }

  export type MissionClearLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    dinerMissionId: number | null
    pointHistoryId: number | null
  }

  export type MissionClearLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
    dinerMissionId: number | null
    pointHistoryId: number | null
  }

  export type MissionClearLogMinAggregateOutputType = {
    id: number | null
    userId: number | null
    dinerMissionId: number | null
    pointHistoryId: number | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type MissionClearLogMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    dinerMissionId: number | null
    pointHistoryId: number | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type MissionClearLogCountAggregateOutputType = {
    id: number
    userId: number
    dinerMissionId: number
    pointHistoryId: number
    status: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type MissionClearLogAvgAggregateInputType = {
    id?: true
    userId?: true
    dinerMissionId?: true
    pointHistoryId?: true
  }

  export type MissionClearLogSumAggregateInputType = {
    id?: true
    userId?: true
    dinerMissionId?: true
    pointHistoryId?: true
  }

  export type MissionClearLogMinAggregateInputType = {
    id?: true
    userId?: true
    dinerMissionId?: true
    pointHistoryId?: true
    status?: true
    startedAt?: true
    completedAt?: true
  }

  export type MissionClearLogMaxAggregateInputType = {
    id?: true
    userId?: true
    dinerMissionId?: true
    pointHistoryId?: true
    status?: true
    startedAt?: true
    completedAt?: true
  }

  export type MissionClearLogCountAggregateInputType = {
    id?: true
    userId?: true
    dinerMissionId?: true
    pointHistoryId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type MissionClearLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MissionClearLog to aggregate.
     */
    where?: MissionClearLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionClearLogs to fetch.
     */
    orderBy?: MissionClearLogOrderByWithRelationInput | MissionClearLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MissionClearLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionClearLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionClearLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MissionClearLogs
    **/
    _count?: true | MissionClearLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MissionClearLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MissionClearLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MissionClearLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MissionClearLogMaxAggregateInputType
  }

  export type GetMissionClearLogAggregateType<T extends MissionClearLogAggregateArgs> = {
        [P in keyof T & keyof AggregateMissionClearLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMissionClearLog[P]>
      : GetScalarType<T[P], AggregateMissionClearLog[P]>
  }




  export type MissionClearLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionClearLogWhereInput
    orderBy?: MissionClearLogOrderByWithAggregationInput | MissionClearLogOrderByWithAggregationInput[]
    by: MissionClearLogScalarFieldEnum[] | MissionClearLogScalarFieldEnum
    having?: MissionClearLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MissionClearLogCountAggregateInputType | true
    _avg?: MissionClearLogAvgAggregateInputType
    _sum?: MissionClearLogSumAggregateInputType
    _min?: MissionClearLogMinAggregateInputType
    _max?: MissionClearLogMaxAggregateInputType
  }

  export type MissionClearLogGroupByOutputType = {
    id: number
    userId: number
    dinerMissionId: number
    pointHistoryId: number | null
    status: string
    startedAt: Date
    completedAt: Date | null
    _count: MissionClearLogCountAggregateOutputType | null
    _avg: MissionClearLogAvgAggregateOutputType | null
    _sum: MissionClearLogSumAggregateOutputType | null
    _min: MissionClearLogMinAggregateOutputType | null
    _max: MissionClearLogMaxAggregateOutputType | null
  }

  type GetMissionClearLogGroupByPayload<T extends MissionClearLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MissionClearLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MissionClearLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MissionClearLogGroupByOutputType[P]>
            : GetScalarType<T[P], MissionClearLogGroupByOutputType[P]>
        }
      >
    >


  export type MissionClearLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    dinerMissionId?: boolean
    pointHistoryId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    dinerMission?: boolean | DinerMissionDefaultArgs<ExtArgs>
    pointHistory?: boolean | MissionClearLog$pointHistoryArgs<ExtArgs>
  }, ExtArgs["result"]["missionClearLog"]>



  export type MissionClearLogSelectScalar = {
    id?: boolean
    userId?: boolean
    dinerMissionId?: boolean
    pointHistoryId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type MissionClearLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "dinerMissionId" | "pointHistoryId" | "status" | "startedAt" | "completedAt", ExtArgs["result"]["missionClearLog"]>
  export type MissionClearLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    dinerMission?: boolean | DinerMissionDefaultArgs<ExtArgs>
    pointHistory?: boolean | MissionClearLog$pointHistoryArgs<ExtArgs>
  }

  export type $MissionClearLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MissionClearLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      dinerMission: Prisma.$DinerMissionPayload<ExtArgs>
      pointHistory: Prisma.$PointHistoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      dinerMissionId: number
      pointHistoryId: number | null
      status: string
      startedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["missionClearLog"]>
    composites: {}
  }

  type MissionClearLogGetPayload<S extends boolean | null | undefined | MissionClearLogDefaultArgs> = $Result.GetResult<Prisma.$MissionClearLogPayload, S>

  type MissionClearLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MissionClearLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MissionClearLogCountAggregateInputType | true
    }

  export interface MissionClearLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MissionClearLog'], meta: { name: 'MissionClearLog' } }
    /**
     * Find zero or one MissionClearLog that matches the filter.
     * @param {MissionClearLogFindUniqueArgs} args - Arguments to find a MissionClearLog
     * @example
     * // Get one MissionClearLog
     * const missionClearLog = await prisma.missionClearLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MissionClearLogFindUniqueArgs>(args: SelectSubset<T, MissionClearLogFindUniqueArgs<ExtArgs>>): Prisma__MissionClearLogClient<$Result.GetResult<Prisma.$MissionClearLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MissionClearLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MissionClearLogFindUniqueOrThrowArgs} args - Arguments to find a MissionClearLog
     * @example
     * // Get one MissionClearLog
     * const missionClearLog = await prisma.missionClearLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MissionClearLogFindUniqueOrThrowArgs>(args: SelectSubset<T, MissionClearLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MissionClearLogClient<$Result.GetResult<Prisma.$MissionClearLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MissionClearLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionClearLogFindFirstArgs} args - Arguments to find a MissionClearLog
     * @example
     * // Get one MissionClearLog
     * const missionClearLog = await prisma.missionClearLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MissionClearLogFindFirstArgs>(args?: SelectSubset<T, MissionClearLogFindFirstArgs<ExtArgs>>): Prisma__MissionClearLogClient<$Result.GetResult<Prisma.$MissionClearLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MissionClearLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionClearLogFindFirstOrThrowArgs} args - Arguments to find a MissionClearLog
     * @example
     * // Get one MissionClearLog
     * const missionClearLog = await prisma.missionClearLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MissionClearLogFindFirstOrThrowArgs>(args?: SelectSubset<T, MissionClearLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__MissionClearLogClient<$Result.GetResult<Prisma.$MissionClearLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MissionClearLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionClearLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MissionClearLogs
     * const missionClearLogs = await prisma.missionClearLog.findMany()
     * 
     * // Get first 10 MissionClearLogs
     * const missionClearLogs = await prisma.missionClearLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const missionClearLogWithIdOnly = await prisma.missionClearLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MissionClearLogFindManyArgs>(args?: SelectSubset<T, MissionClearLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionClearLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MissionClearLog.
     * @param {MissionClearLogCreateArgs} args - Arguments to create a MissionClearLog.
     * @example
     * // Create one MissionClearLog
     * const MissionClearLog = await prisma.missionClearLog.create({
     *   data: {
     *     // ... data to create a MissionClearLog
     *   }
     * })
     * 
     */
    create<T extends MissionClearLogCreateArgs>(args: SelectSubset<T, MissionClearLogCreateArgs<ExtArgs>>): Prisma__MissionClearLogClient<$Result.GetResult<Prisma.$MissionClearLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MissionClearLogs.
     * @param {MissionClearLogCreateManyArgs} args - Arguments to create many MissionClearLogs.
     * @example
     * // Create many MissionClearLogs
     * const missionClearLog = await prisma.missionClearLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MissionClearLogCreateManyArgs>(args?: SelectSubset<T, MissionClearLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MissionClearLog.
     * @param {MissionClearLogDeleteArgs} args - Arguments to delete one MissionClearLog.
     * @example
     * // Delete one MissionClearLog
     * const MissionClearLog = await prisma.missionClearLog.delete({
     *   where: {
     *     // ... filter to delete one MissionClearLog
     *   }
     * })
     * 
     */
    delete<T extends MissionClearLogDeleteArgs>(args: SelectSubset<T, MissionClearLogDeleteArgs<ExtArgs>>): Prisma__MissionClearLogClient<$Result.GetResult<Prisma.$MissionClearLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MissionClearLog.
     * @param {MissionClearLogUpdateArgs} args - Arguments to update one MissionClearLog.
     * @example
     * // Update one MissionClearLog
     * const missionClearLog = await prisma.missionClearLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MissionClearLogUpdateArgs>(args: SelectSubset<T, MissionClearLogUpdateArgs<ExtArgs>>): Prisma__MissionClearLogClient<$Result.GetResult<Prisma.$MissionClearLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MissionClearLogs.
     * @param {MissionClearLogDeleteManyArgs} args - Arguments to filter MissionClearLogs to delete.
     * @example
     * // Delete a few MissionClearLogs
     * const { count } = await prisma.missionClearLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MissionClearLogDeleteManyArgs>(args?: SelectSubset<T, MissionClearLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MissionClearLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionClearLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MissionClearLogs
     * const missionClearLog = await prisma.missionClearLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MissionClearLogUpdateManyArgs>(args: SelectSubset<T, MissionClearLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MissionClearLog.
     * @param {MissionClearLogUpsertArgs} args - Arguments to update or create a MissionClearLog.
     * @example
     * // Update or create a MissionClearLog
     * const missionClearLog = await prisma.missionClearLog.upsert({
     *   create: {
     *     // ... data to create a MissionClearLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MissionClearLog we want to update
     *   }
     * })
     */
    upsert<T extends MissionClearLogUpsertArgs>(args: SelectSubset<T, MissionClearLogUpsertArgs<ExtArgs>>): Prisma__MissionClearLogClient<$Result.GetResult<Prisma.$MissionClearLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MissionClearLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionClearLogCountArgs} args - Arguments to filter MissionClearLogs to count.
     * @example
     * // Count the number of MissionClearLogs
     * const count = await prisma.missionClearLog.count({
     *   where: {
     *     // ... the filter for the MissionClearLogs we want to count
     *   }
     * })
    **/
    count<T extends MissionClearLogCountArgs>(
      args?: Subset<T, MissionClearLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MissionClearLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MissionClearLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionClearLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MissionClearLogAggregateArgs>(args: Subset<T, MissionClearLogAggregateArgs>): Prisma.PrismaPromise<GetMissionClearLogAggregateType<T>>

    /**
     * Group by MissionClearLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionClearLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MissionClearLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MissionClearLogGroupByArgs['orderBy'] }
        : { orderBy?: MissionClearLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MissionClearLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMissionClearLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MissionClearLog model
   */
  readonly fields: MissionClearLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MissionClearLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MissionClearLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dinerMission<T extends DinerMissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DinerMissionDefaultArgs<ExtArgs>>): Prisma__DinerMissionClient<$Result.GetResult<Prisma.$DinerMissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pointHistory<T extends MissionClearLog$pointHistoryArgs<ExtArgs> = {}>(args?: Subset<T, MissionClearLog$pointHistoryArgs<ExtArgs>>): Prisma__PointHistoryClient<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MissionClearLog model
   */
  interface MissionClearLogFieldRefs {
    readonly id: FieldRef<"MissionClearLog", 'Int'>
    readonly userId: FieldRef<"MissionClearLog", 'Int'>
    readonly dinerMissionId: FieldRef<"MissionClearLog", 'Int'>
    readonly pointHistoryId: FieldRef<"MissionClearLog", 'Int'>
    readonly status: FieldRef<"MissionClearLog", 'String'>
    readonly startedAt: FieldRef<"MissionClearLog", 'DateTime'>
    readonly completedAt: FieldRef<"MissionClearLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MissionClearLog findUnique
   */
  export type MissionClearLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionClearLog
     */
    select?: MissionClearLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissionClearLog
     */
    omit?: MissionClearLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionClearLogInclude<ExtArgs> | null
    /**
     * Filter, which MissionClearLog to fetch.
     */
    where: MissionClearLogWhereUniqueInput
  }

  /**
   * MissionClearLog findUniqueOrThrow
   */
  export type MissionClearLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionClearLog
     */
    select?: MissionClearLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissionClearLog
     */
    omit?: MissionClearLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionClearLogInclude<ExtArgs> | null
    /**
     * Filter, which MissionClearLog to fetch.
     */
    where: MissionClearLogWhereUniqueInput
  }

  /**
   * MissionClearLog findFirst
   */
  export type MissionClearLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionClearLog
     */
    select?: MissionClearLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissionClearLog
     */
    omit?: MissionClearLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionClearLogInclude<ExtArgs> | null
    /**
     * Filter, which MissionClearLog to fetch.
     */
    where?: MissionClearLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionClearLogs to fetch.
     */
    orderBy?: MissionClearLogOrderByWithRelationInput | MissionClearLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MissionClearLogs.
     */
    cursor?: MissionClearLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionClearLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionClearLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MissionClearLogs.
     */
    distinct?: MissionClearLogScalarFieldEnum | MissionClearLogScalarFieldEnum[]
  }

  /**
   * MissionClearLog findFirstOrThrow
   */
  export type MissionClearLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionClearLog
     */
    select?: MissionClearLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissionClearLog
     */
    omit?: MissionClearLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionClearLogInclude<ExtArgs> | null
    /**
     * Filter, which MissionClearLog to fetch.
     */
    where?: MissionClearLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionClearLogs to fetch.
     */
    orderBy?: MissionClearLogOrderByWithRelationInput | MissionClearLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MissionClearLogs.
     */
    cursor?: MissionClearLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionClearLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionClearLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MissionClearLogs.
     */
    distinct?: MissionClearLogScalarFieldEnum | MissionClearLogScalarFieldEnum[]
  }

  /**
   * MissionClearLog findMany
   */
  export type MissionClearLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionClearLog
     */
    select?: MissionClearLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissionClearLog
     */
    omit?: MissionClearLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionClearLogInclude<ExtArgs> | null
    /**
     * Filter, which MissionClearLogs to fetch.
     */
    where?: MissionClearLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionClearLogs to fetch.
     */
    orderBy?: MissionClearLogOrderByWithRelationInput | MissionClearLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MissionClearLogs.
     */
    cursor?: MissionClearLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionClearLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionClearLogs.
     */
    skip?: number
    distinct?: MissionClearLogScalarFieldEnum | MissionClearLogScalarFieldEnum[]
  }

  /**
   * MissionClearLog create
   */
  export type MissionClearLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionClearLog
     */
    select?: MissionClearLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissionClearLog
     */
    omit?: MissionClearLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionClearLogInclude<ExtArgs> | null
    /**
     * The data needed to create a MissionClearLog.
     */
    data: XOR<MissionClearLogCreateInput, MissionClearLogUncheckedCreateInput>
  }

  /**
   * MissionClearLog createMany
   */
  export type MissionClearLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MissionClearLogs.
     */
    data: MissionClearLogCreateManyInput | MissionClearLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MissionClearLog update
   */
  export type MissionClearLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionClearLog
     */
    select?: MissionClearLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissionClearLog
     */
    omit?: MissionClearLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionClearLogInclude<ExtArgs> | null
    /**
     * The data needed to update a MissionClearLog.
     */
    data: XOR<MissionClearLogUpdateInput, MissionClearLogUncheckedUpdateInput>
    /**
     * Choose, which MissionClearLog to update.
     */
    where: MissionClearLogWhereUniqueInput
  }

  /**
   * MissionClearLog updateMany
   */
  export type MissionClearLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MissionClearLogs.
     */
    data: XOR<MissionClearLogUpdateManyMutationInput, MissionClearLogUncheckedUpdateManyInput>
    /**
     * Filter which MissionClearLogs to update
     */
    where?: MissionClearLogWhereInput
    /**
     * Limit how many MissionClearLogs to update.
     */
    limit?: number
  }

  /**
   * MissionClearLog upsert
   */
  export type MissionClearLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionClearLog
     */
    select?: MissionClearLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissionClearLog
     */
    omit?: MissionClearLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionClearLogInclude<ExtArgs> | null
    /**
     * The filter to search for the MissionClearLog to update in case it exists.
     */
    where: MissionClearLogWhereUniqueInput
    /**
     * In case the MissionClearLog found by the `where` argument doesn't exist, create a new MissionClearLog with this data.
     */
    create: XOR<MissionClearLogCreateInput, MissionClearLogUncheckedCreateInput>
    /**
     * In case the MissionClearLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MissionClearLogUpdateInput, MissionClearLogUncheckedUpdateInput>
  }

  /**
   * MissionClearLog delete
   */
  export type MissionClearLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionClearLog
     */
    select?: MissionClearLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissionClearLog
     */
    omit?: MissionClearLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionClearLogInclude<ExtArgs> | null
    /**
     * Filter which MissionClearLog to delete.
     */
    where: MissionClearLogWhereUniqueInput
  }

  /**
   * MissionClearLog deleteMany
   */
  export type MissionClearLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MissionClearLogs to delete
     */
    where?: MissionClearLogWhereInput
    /**
     * Limit how many MissionClearLogs to delete.
     */
    limit?: number
  }

  /**
   * MissionClearLog.pointHistory
   */
  export type MissionClearLog$pointHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    where?: PointHistoryWhereInput
  }

  /**
   * MissionClearLog without action
   */
  export type MissionClearLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionClearLog
     */
    select?: MissionClearLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MissionClearLog
     */
    omit?: MissionClearLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionClearLogInclude<ExtArgs> | null
  }


  /**
   * Model Inquiry
   */

  export type AggregateInquiry = {
    _count: InquiryCountAggregateOutputType | null
    _avg: InquiryAvgAggregateOutputType | null
    _sum: InquirySumAggregateOutputType | null
    _min: InquiryMinAggregateOutputType | null
    _max: InquiryMaxAggregateOutputType | null
  }

  export type InquiryAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type InquirySumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type InquiryMinAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    content: string | null
    createdAt: Date | null
  }

  export type InquiryMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    content: string | null
    createdAt: Date | null
  }

  export type InquiryCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    content: number
    createdAt: number
    _all: number
  }


  export type InquiryAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type InquirySumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type InquiryMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    createdAt?: true
  }

  export type InquiryMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    createdAt?: true
  }

  export type InquiryCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type InquiryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inquiry to aggregate.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inquiries
    **/
    _count?: true | InquiryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InquiryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InquirySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InquiryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InquiryMaxAggregateInputType
  }

  export type GetInquiryAggregateType<T extends InquiryAggregateArgs> = {
        [P in keyof T & keyof AggregateInquiry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInquiry[P]>
      : GetScalarType<T[P], AggregateInquiry[P]>
  }




  export type InquiryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryWhereInput
    orderBy?: InquiryOrderByWithAggregationInput | InquiryOrderByWithAggregationInput[]
    by: InquiryScalarFieldEnum[] | InquiryScalarFieldEnum
    having?: InquiryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InquiryCountAggregateInputType | true
    _avg?: InquiryAvgAggregateInputType
    _sum?: InquirySumAggregateInputType
    _min?: InquiryMinAggregateInputType
    _max?: InquiryMaxAggregateInputType
  }

  export type InquiryGroupByOutputType = {
    id: number
    userId: number
    title: string
    content: string | null
    createdAt: Date
    _count: InquiryCountAggregateOutputType | null
    _avg: InquiryAvgAggregateOutputType | null
    _sum: InquirySumAggregateOutputType | null
    _min: InquiryMinAggregateOutputType | null
    _max: InquiryMaxAggregateOutputType | null
  }

  type GetInquiryGroupByPayload<T extends InquiryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InquiryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InquiryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InquiryGroupByOutputType[P]>
            : GetScalarType<T[P], InquiryGroupByOutputType[P]>
        }
      >
    >


  export type InquirySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inquiry"]>



  export type InquirySelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type InquiryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "content" | "createdAt", ExtArgs["result"]["inquiry"]>
  export type InquiryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InquiryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inquiry"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      title: string
      content: string | null
      createdAt: Date
    }, ExtArgs["result"]["inquiry"]>
    composites: {}
  }

  type InquiryGetPayload<S extends boolean | null | undefined | InquiryDefaultArgs> = $Result.GetResult<Prisma.$InquiryPayload, S>

  type InquiryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InquiryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InquiryCountAggregateInputType | true
    }

  export interface InquiryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inquiry'], meta: { name: 'Inquiry' } }
    /**
     * Find zero or one Inquiry that matches the filter.
     * @param {InquiryFindUniqueArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InquiryFindUniqueArgs>(args: SelectSubset<T, InquiryFindUniqueArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inquiry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InquiryFindUniqueOrThrowArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InquiryFindUniqueOrThrowArgs>(args: SelectSubset<T, InquiryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inquiry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindFirstArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InquiryFindFirstArgs>(args?: SelectSubset<T, InquiryFindFirstArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inquiry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindFirstOrThrowArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InquiryFindFirstOrThrowArgs>(args?: SelectSubset<T, InquiryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inquiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inquiries
     * const inquiries = await prisma.inquiry.findMany()
     * 
     * // Get first 10 Inquiries
     * const inquiries = await prisma.inquiry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inquiryWithIdOnly = await prisma.inquiry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InquiryFindManyArgs>(args?: SelectSubset<T, InquiryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inquiry.
     * @param {InquiryCreateArgs} args - Arguments to create a Inquiry.
     * @example
     * // Create one Inquiry
     * const Inquiry = await prisma.inquiry.create({
     *   data: {
     *     // ... data to create a Inquiry
     *   }
     * })
     * 
     */
    create<T extends InquiryCreateArgs>(args: SelectSubset<T, InquiryCreateArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inquiries.
     * @param {InquiryCreateManyArgs} args - Arguments to create many Inquiries.
     * @example
     * // Create many Inquiries
     * const inquiry = await prisma.inquiry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InquiryCreateManyArgs>(args?: SelectSubset<T, InquiryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inquiry.
     * @param {InquiryDeleteArgs} args - Arguments to delete one Inquiry.
     * @example
     * // Delete one Inquiry
     * const Inquiry = await prisma.inquiry.delete({
     *   where: {
     *     // ... filter to delete one Inquiry
     *   }
     * })
     * 
     */
    delete<T extends InquiryDeleteArgs>(args: SelectSubset<T, InquiryDeleteArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inquiry.
     * @param {InquiryUpdateArgs} args - Arguments to update one Inquiry.
     * @example
     * // Update one Inquiry
     * const inquiry = await prisma.inquiry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InquiryUpdateArgs>(args: SelectSubset<T, InquiryUpdateArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inquiries.
     * @param {InquiryDeleteManyArgs} args - Arguments to filter Inquiries to delete.
     * @example
     * // Delete a few Inquiries
     * const { count } = await prisma.inquiry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InquiryDeleteManyArgs>(args?: SelectSubset<T, InquiryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inquiries
     * const inquiry = await prisma.inquiry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InquiryUpdateManyArgs>(args: SelectSubset<T, InquiryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inquiry.
     * @param {InquiryUpsertArgs} args - Arguments to update or create a Inquiry.
     * @example
     * // Update or create a Inquiry
     * const inquiry = await prisma.inquiry.upsert({
     *   create: {
     *     // ... data to create a Inquiry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inquiry we want to update
     *   }
     * })
     */
    upsert<T extends InquiryUpsertArgs>(args: SelectSubset<T, InquiryUpsertArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryCountArgs} args - Arguments to filter Inquiries to count.
     * @example
     * // Count the number of Inquiries
     * const count = await prisma.inquiry.count({
     *   where: {
     *     // ... the filter for the Inquiries we want to count
     *   }
     * })
    **/
    count<T extends InquiryCountArgs>(
      args?: Subset<T, InquiryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InquiryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InquiryAggregateArgs>(args: Subset<T, InquiryAggregateArgs>): Prisma.PrismaPromise<GetInquiryAggregateType<T>>

    /**
     * Group by Inquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InquiryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InquiryGroupByArgs['orderBy'] }
        : { orderBy?: InquiryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InquiryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInquiryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inquiry model
   */
  readonly fields: InquiryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inquiry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InquiryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inquiry model
   */
  interface InquiryFieldRefs {
    readonly id: FieldRef<"Inquiry", 'Int'>
    readonly userId: FieldRef<"Inquiry", 'Int'>
    readonly title: FieldRef<"Inquiry", 'String'>
    readonly content: FieldRef<"Inquiry", 'String'>
    readonly createdAt: FieldRef<"Inquiry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inquiry findUnique
   */
  export type InquiryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry findUniqueOrThrow
   */
  export type InquiryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry findFirst
   */
  export type InquiryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inquiries.
     */
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry findFirstOrThrow
   */
  export type InquiryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inquiries.
     */
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry findMany
   */
  export type InquiryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiries to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry create
   */
  export type InquiryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inquiry.
     */
    data: XOR<InquiryCreateInput, InquiryUncheckedCreateInput>
  }

  /**
   * Inquiry createMany
   */
  export type InquiryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inquiries.
     */
    data: InquiryCreateManyInput | InquiryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inquiry update
   */
  export type InquiryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inquiry.
     */
    data: XOR<InquiryUpdateInput, InquiryUncheckedUpdateInput>
    /**
     * Choose, which Inquiry to update.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry updateMany
   */
  export type InquiryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inquiries.
     */
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyInput>
    /**
     * Filter which Inquiries to update
     */
    where?: InquiryWhereInput
    /**
     * Limit how many Inquiries to update.
     */
    limit?: number
  }

  /**
   * Inquiry upsert
   */
  export type InquiryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inquiry to update in case it exists.
     */
    where: InquiryWhereUniqueInput
    /**
     * In case the Inquiry found by the `where` argument doesn't exist, create a new Inquiry with this data.
     */
    create: XOR<InquiryCreateInput, InquiryUncheckedCreateInput>
    /**
     * In case the Inquiry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InquiryUpdateInput, InquiryUncheckedUpdateInput>
  }

  /**
   * Inquiry delete
   */
  export type InquiryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter which Inquiry to delete.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry deleteMany
   */
  export type InquiryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inquiries to delete
     */
    where?: InquiryWhereInput
    /**
     * Limit how many Inquiries to delete.
     */
    limit?: number
  }

  /**
   * Inquiry without action
   */
  export type InquiryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
  }


  /**
   * Model RegionMissionCounter
   */

  export type AggregateRegionMissionCounter = {
    _count: RegionMissionCounterCountAggregateOutputType | null
    _avg: RegionMissionCounterAvgAggregateOutputType | null
    _sum: RegionMissionCounterSumAggregateOutputType | null
    _min: RegionMissionCounterMinAggregateOutputType | null
    _max: RegionMissionCounterMaxAggregateOutputType | null
  }

  export type RegionMissionCounterAvgAggregateOutputType = {
    id: number | null
    regionId: number | null
    userId: number | null
    missionCount: number | null
  }

  export type RegionMissionCounterSumAggregateOutputType = {
    id: number | null
    regionId: number | null
    userId: number | null
    missionCount: number | null
  }

  export type RegionMissionCounterMinAggregateOutputType = {
    id: number | null
    regionId: number | null
    userId: number | null
    missionCount: number | null
  }

  export type RegionMissionCounterMaxAggregateOutputType = {
    id: number | null
    regionId: number | null
    userId: number | null
    missionCount: number | null
  }

  export type RegionMissionCounterCountAggregateOutputType = {
    id: number
    regionId: number
    userId: number
    missionCount: number
    _all: number
  }


  export type RegionMissionCounterAvgAggregateInputType = {
    id?: true
    regionId?: true
    userId?: true
    missionCount?: true
  }

  export type RegionMissionCounterSumAggregateInputType = {
    id?: true
    regionId?: true
    userId?: true
    missionCount?: true
  }

  export type RegionMissionCounterMinAggregateInputType = {
    id?: true
    regionId?: true
    userId?: true
    missionCount?: true
  }

  export type RegionMissionCounterMaxAggregateInputType = {
    id?: true
    regionId?: true
    userId?: true
    missionCount?: true
  }

  export type RegionMissionCounterCountAggregateInputType = {
    id?: true
    regionId?: true
    userId?: true
    missionCount?: true
    _all?: true
  }

  export type RegionMissionCounterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegionMissionCounter to aggregate.
     */
    where?: RegionMissionCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionMissionCounters to fetch.
     */
    orderBy?: RegionMissionCounterOrderByWithRelationInput | RegionMissionCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionMissionCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionMissionCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionMissionCounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegionMissionCounters
    **/
    _count?: true | RegionMissionCounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionMissionCounterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionMissionCounterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionMissionCounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionMissionCounterMaxAggregateInputType
  }

  export type GetRegionMissionCounterAggregateType<T extends RegionMissionCounterAggregateArgs> = {
        [P in keyof T & keyof AggregateRegionMissionCounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegionMissionCounter[P]>
      : GetScalarType<T[P], AggregateRegionMissionCounter[P]>
  }




  export type RegionMissionCounterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionMissionCounterWhereInput
    orderBy?: RegionMissionCounterOrderByWithAggregationInput | RegionMissionCounterOrderByWithAggregationInput[]
    by: RegionMissionCounterScalarFieldEnum[] | RegionMissionCounterScalarFieldEnum
    having?: RegionMissionCounterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionMissionCounterCountAggregateInputType | true
    _avg?: RegionMissionCounterAvgAggregateInputType
    _sum?: RegionMissionCounterSumAggregateInputType
    _min?: RegionMissionCounterMinAggregateInputType
    _max?: RegionMissionCounterMaxAggregateInputType
  }

  export type RegionMissionCounterGroupByOutputType = {
    id: number
    regionId: number
    userId: number
    missionCount: number
    _count: RegionMissionCounterCountAggregateOutputType | null
    _avg: RegionMissionCounterAvgAggregateOutputType | null
    _sum: RegionMissionCounterSumAggregateOutputType | null
    _min: RegionMissionCounterMinAggregateOutputType | null
    _max: RegionMissionCounterMaxAggregateOutputType | null
  }

  type GetRegionMissionCounterGroupByPayload<T extends RegionMissionCounterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionMissionCounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionMissionCounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionMissionCounterGroupByOutputType[P]>
            : GetScalarType<T[P], RegionMissionCounterGroupByOutputType[P]>
        }
      >
    >


  export type RegionMissionCounterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionId?: boolean
    userId?: boolean
    missionCount?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["regionMissionCounter"]>



  export type RegionMissionCounterSelectScalar = {
    id?: boolean
    regionId?: boolean
    userId?: boolean
    missionCount?: boolean
  }

  export type RegionMissionCounterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "regionId" | "userId" | "missionCount", ExtArgs["result"]["regionMissionCounter"]>
  export type RegionMissionCounterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RegionMissionCounterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RegionMissionCounter"
    objects: {
      region: Prisma.$RegionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      regionId: number
      userId: number
      missionCount: number
    }, ExtArgs["result"]["regionMissionCounter"]>
    composites: {}
  }

  type RegionMissionCounterGetPayload<S extends boolean | null | undefined | RegionMissionCounterDefaultArgs> = $Result.GetResult<Prisma.$RegionMissionCounterPayload, S>

  type RegionMissionCounterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegionMissionCounterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegionMissionCounterCountAggregateInputType | true
    }

  export interface RegionMissionCounterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RegionMissionCounter'], meta: { name: 'RegionMissionCounter' } }
    /**
     * Find zero or one RegionMissionCounter that matches the filter.
     * @param {RegionMissionCounterFindUniqueArgs} args - Arguments to find a RegionMissionCounter
     * @example
     * // Get one RegionMissionCounter
     * const regionMissionCounter = await prisma.regionMissionCounter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegionMissionCounterFindUniqueArgs>(args: SelectSubset<T, RegionMissionCounterFindUniqueArgs<ExtArgs>>): Prisma__RegionMissionCounterClient<$Result.GetResult<Prisma.$RegionMissionCounterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RegionMissionCounter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegionMissionCounterFindUniqueOrThrowArgs} args - Arguments to find a RegionMissionCounter
     * @example
     * // Get one RegionMissionCounter
     * const regionMissionCounter = await prisma.regionMissionCounter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegionMissionCounterFindUniqueOrThrowArgs>(args: SelectSubset<T, RegionMissionCounterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegionMissionCounterClient<$Result.GetResult<Prisma.$RegionMissionCounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegionMissionCounter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionMissionCounterFindFirstArgs} args - Arguments to find a RegionMissionCounter
     * @example
     * // Get one RegionMissionCounter
     * const regionMissionCounter = await prisma.regionMissionCounter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegionMissionCounterFindFirstArgs>(args?: SelectSubset<T, RegionMissionCounterFindFirstArgs<ExtArgs>>): Prisma__RegionMissionCounterClient<$Result.GetResult<Prisma.$RegionMissionCounterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegionMissionCounter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionMissionCounterFindFirstOrThrowArgs} args - Arguments to find a RegionMissionCounter
     * @example
     * // Get one RegionMissionCounter
     * const regionMissionCounter = await prisma.regionMissionCounter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegionMissionCounterFindFirstOrThrowArgs>(args?: SelectSubset<T, RegionMissionCounterFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegionMissionCounterClient<$Result.GetResult<Prisma.$RegionMissionCounterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RegionMissionCounters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionMissionCounterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegionMissionCounters
     * const regionMissionCounters = await prisma.regionMissionCounter.findMany()
     * 
     * // Get first 10 RegionMissionCounters
     * const regionMissionCounters = await prisma.regionMissionCounter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionMissionCounterWithIdOnly = await prisma.regionMissionCounter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegionMissionCounterFindManyArgs>(args?: SelectSubset<T, RegionMissionCounterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionMissionCounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RegionMissionCounter.
     * @param {RegionMissionCounterCreateArgs} args - Arguments to create a RegionMissionCounter.
     * @example
     * // Create one RegionMissionCounter
     * const RegionMissionCounter = await prisma.regionMissionCounter.create({
     *   data: {
     *     // ... data to create a RegionMissionCounter
     *   }
     * })
     * 
     */
    create<T extends RegionMissionCounterCreateArgs>(args: SelectSubset<T, RegionMissionCounterCreateArgs<ExtArgs>>): Prisma__RegionMissionCounterClient<$Result.GetResult<Prisma.$RegionMissionCounterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RegionMissionCounters.
     * @param {RegionMissionCounterCreateManyArgs} args - Arguments to create many RegionMissionCounters.
     * @example
     * // Create many RegionMissionCounters
     * const regionMissionCounter = await prisma.regionMissionCounter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegionMissionCounterCreateManyArgs>(args?: SelectSubset<T, RegionMissionCounterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RegionMissionCounter.
     * @param {RegionMissionCounterDeleteArgs} args - Arguments to delete one RegionMissionCounter.
     * @example
     * // Delete one RegionMissionCounter
     * const RegionMissionCounter = await prisma.regionMissionCounter.delete({
     *   where: {
     *     // ... filter to delete one RegionMissionCounter
     *   }
     * })
     * 
     */
    delete<T extends RegionMissionCounterDeleteArgs>(args: SelectSubset<T, RegionMissionCounterDeleteArgs<ExtArgs>>): Prisma__RegionMissionCounterClient<$Result.GetResult<Prisma.$RegionMissionCounterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RegionMissionCounter.
     * @param {RegionMissionCounterUpdateArgs} args - Arguments to update one RegionMissionCounter.
     * @example
     * // Update one RegionMissionCounter
     * const regionMissionCounter = await prisma.regionMissionCounter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegionMissionCounterUpdateArgs>(args: SelectSubset<T, RegionMissionCounterUpdateArgs<ExtArgs>>): Prisma__RegionMissionCounterClient<$Result.GetResult<Prisma.$RegionMissionCounterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RegionMissionCounters.
     * @param {RegionMissionCounterDeleteManyArgs} args - Arguments to filter RegionMissionCounters to delete.
     * @example
     * // Delete a few RegionMissionCounters
     * const { count } = await prisma.regionMissionCounter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegionMissionCounterDeleteManyArgs>(args?: SelectSubset<T, RegionMissionCounterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegionMissionCounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionMissionCounterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegionMissionCounters
     * const regionMissionCounter = await prisma.regionMissionCounter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegionMissionCounterUpdateManyArgs>(args: SelectSubset<T, RegionMissionCounterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RegionMissionCounter.
     * @param {RegionMissionCounterUpsertArgs} args - Arguments to update or create a RegionMissionCounter.
     * @example
     * // Update or create a RegionMissionCounter
     * const regionMissionCounter = await prisma.regionMissionCounter.upsert({
     *   create: {
     *     // ... data to create a RegionMissionCounter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegionMissionCounter we want to update
     *   }
     * })
     */
    upsert<T extends RegionMissionCounterUpsertArgs>(args: SelectSubset<T, RegionMissionCounterUpsertArgs<ExtArgs>>): Prisma__RegionMissionCounterClient<$Result.GetResult<Prisma.$RegionMissionCounterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RegionMissionCounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionMissionCounterCountArgs} args - Arguments to filter RegionMissionCounters to count.
     * @example
     * // Count the number of RegionMissionCounters
     * const count = await prisma.regionMissionCounter.count({
     *   where: {
     *     // ... the filter for the RegionMissionCounters we want to count
     *   }
     * })
    **/
    count<T extends RegionMissionCounterCountArgs>(
      args?: Subset<T, RegionMissionCounterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionMissionCounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegionMissionCounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionMissionCounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionMissionCounterAggregateArgs>(args: Subset<T, RegionMissionCounterAggregateArgs>): Prisma.PrismaPromise<GetRegionMissionCounterAggregateType<T>>

    /**
     * Group by RegionMissionCounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionMissionCounterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionMissionCounterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionMissionCounterGroupByArgs['orderBy'] }
        : { orderBy?: RegionMissionCounterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionMissionCounterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionMissionCounterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RegionMissionCounter model
   */
  readonly fields: RegionMissionCounterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RegionMissionCounter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionMissionCounterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    region<T extends RegionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionDefaultArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RegionMissionCounter model
   */
  interface RegionMissionCounterFieldRefs {
    readonly id: FieldRef<"RegionMissionCounter", 'Int'>
    readonly regionId: FieldRef<"RegionMissionCounter", 'Int'>
    readonly userId: FieldRef<"RegionMissionCounter", 'Int'>
    readonly missionCount: FieldRef<"RegionMissionCounter", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RegionMissionCounter findUnique
   */
  export type RegionMissionCounterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMissionCounter
     */
    select?: RegionMissionCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMissionCounter
     */
    omit?: RegionMissionCounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMissionCounterInclude<ExtArgs> | null
    /**
     * Filter, which RegionMissionCounter to fetch.
     */
    where: RegionMissionCounterWhereUniqueInput
  }

  /**
   * RegionMissionCounter findUniqueOrThrow
   */
  export type RegionMissionCounterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMissionCounter
     */
    select?: RegionMissionCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMissionCounter
     */
    omit?: RegionMissionCounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMissionCounterInclude<ExtArgs> | null
    /**
     * Filter, which RegionMissionCounter to fetch.
     */
    where: RegionMissionCounterWhereUniqueInput
  }

  /**
   * RegionMissionCounter findFirst
   */
  export type RegionMissionCounterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMissionCounter
     */
    select?: RegionMissionCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMissionCounter
     */
    omit?: RegionMissionCounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMissionCounterInclude<ExtArgs> | null
    /**
     * Filter, which RegionMissionCounter to fetch.
     */
    where?: RegionMissionCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionMissionCounters to fetch.
     */
    orderBy?: RegionMissionCounterOrderByWithRelationInput | RegionMissionCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegionMissionCounters.
     */
    cursor?: RegionMissionCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionMissionCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionMissionCounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegionMissionCounters.
     */
    distinct?: RegionMissionCounterScalarFieldEnum | RegionMissionCounterScalarFieldEnum[]
  }

  /**
   * RegionMissionCounter findFirstOrThrow
   */
  export type RegionMissionCounterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMissionCounter
     */
    select?: RegionMissionCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMissionCounter
     */
    omit?: RegionMissionCounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMissionCounterInclude<ExtArgs> | null
    /**
     * Filter, which RegionMissionCounter to fetch.
     */
    where?: RegionMissionCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionMissionCounters to fetch.
     */
    orderBy?: RegionMissionCounterOrderByWithRelationInput | RegionMissionCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegionMissionCounters.
     */
    cursor?: RegionMissionCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionMissionCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionMissionCounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegionMissionCounters.
     */
    distinct?: RegionMissionCounterScalarFieldEnum | RegionMissionCounterScalarFieldEnum[]
  }

  /**
   * RegionMissionCounter findMany
   */
  export type RegionMissionCounterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMissionCounter
     */
    select?: RegionMissionCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMissionCounter
     */
    omit?: RegionMissionCounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMissionCounterInclude<ExtArgs> | null
    /**
     * Filter, which RegionMissionCounters to fetch.
     */
    where?: RegionMissionCounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegionMissionCounters to fetch.
     */
    orderBy?: RegionMissionCounterOrderByWithRelationInput | RegionMissionCounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegionMissionCounters.
     */
    cursor?: RegionMissionCounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegionMissionCounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegionMissionCounters.
     */
    skip?: number
    distinct?: RegionMissionCounterScalarFieldEnum | RegionMissionCounterScalarFieldEnum[]
  }

  /**
   * RegionMissionCounter create
   */
  export type RegionMissionCounterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMissionCounter
     */
    select?: RegionMissionCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMissionCounter
     */
    omit?: RegionMissionCounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMissionCounterInclude<ExtArgs> | null
    /**
     * The data needed to create a RegionMissionCounter.
     */
    data: XOR<RegionMissionCounterCreateInput, RegionMissionCounterUncheckedCreateInput>
  }

  /**
   * RegionMissionCounter createMany
   */
  export type RegionMissionCounterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RegionMissionCounters.
     */
    data: RegionMissionCounterCreateManyInput | RegionMissionCounterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RegionMissionCounter update
   */
  export type RegionMissionCounterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMissionCounter
     */
    select?: RegionMissionCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMissionCounter
     */
    omit?: RegionMissionCounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMissionCounterInclude<ExtArgs> | null
    /**
     * The data needed to update a RegionMissionCounter.
     */
    data: XOR<RegionMissionCounterUpdateInput, RegionMissionCounterUncheckedUpdateInput>
    /**
     * Choose, which RegionMissionCounter to update.
     */
    where: RegionMissionCounterWhereUniqueInput
  }

  /**
   * RegionMissionCounter updateMany
   */
  export type RegionMissionCounterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RegionMissionCounters.
     */
    data: XOR<RegionMissionCounterUpdateManyMutationInput, RegionMissionCounterUncheckedUpdateManyInput>
    /**
     * Filter which RegionMissionCounters to update
     */
    where?: RegionMissionCounterWhereInput
    /**
     * Limit how many RegionMissionCounters to update.
     */
    limit?: number
  }

  /**
   * RegionMissionCounter upsert
   */
  export type RegionMissionCounterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMissionCounter
     */
    select?: RegionMissionCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMissionCounter
     */
    omit?: RegionMissionCounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMissionCounterInclude<ExtArgs> | null
    /**
     * The filter to search for the RegionMissionCounter to update in case it exists.
     */
    where: RegionMissionCounterWhereUniqueInput
    /**
     * In case the RegionMissionCounter found by the `where` argument doesn't exist, create a new RegionMissionCounter with this data.
     */
    create: XOR<RegionMissionCounterCreateInput, RegionMissionCounterUncheckedCreateInput>
    /**
     * In case the RegionMissionCounter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionMissionCounterUpdateInput, RegionMissionCounterUncheckedUpdateInput>
  }

  /**
   * RegionMissionCounter delete
   */
  export type RegionMissionCounterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMissionCounter
     */
    select?: RegionMissionCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMissionCounter
     */
    omit?: RegionMissionCounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMissionCounterInclude<ExtArgs> | null
    /**
     * Filter which RegionMissionCounter to delete.
     */
    where: RegionMissionCounterWhereUniqueInput
  }

  /**
   * RegionMissionCounter deleteMany
   */
  export type RegionMissionCounterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegionMissionCounters to delete
     */
    where?: RegionMissionCounterWhereInput
    /**
     * Limit how many RegionMissionCounters to delete.
     */
    limit?: number
  }

  /**
   * RegionMissionCounter without action
   */
  export type RegionMissionCounterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionMissionCounter
     */
    select?: RegionMissionCounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegionMissionCounter
     */
    omit?: RegionMissionCounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionMissionCounterInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    role: 'role',
    gender: 'gender',
    birth: 'birth',
    address: 'address',
    detailAddress: 'detailAddress',
    phoneNumber: 'phoneNumber'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const FoodCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type FoodCategoryScalarFieldEnum = (typeof FoodCategoryScalarFieldEnum)[keyof typeof FoodCategoryScalarFieldEnum]


  export const UserFavorCategoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    foodCategoryId: 'foodCategoryId'
  };

  export type UserFavorCategoryScalarFieldEnum = (typeof UserFavorCategoryScalarFieldEnum)[keyof typeof UserFavorCategoryScalarFieldEnum]


  export const RegionScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RegionScalarFieldEnum = (typeof RegionScalarFieldEnum)[keyof typeof RegionScalarFieldEnum]


  export const DinerScalarFieldEnum: {
    id: 'id',
    regionId: 'regionId',
    categoryId: 'categoryId',
    name: 'name',
    phoneNumber: 'phoneNumber',
    address: 'address',
    rating: 'rating'
  };

  export type DinerScalarFieldEnum = (typeof DinerScalarFieldEnum)[keyof typeof DinerScalarFieldEnum]


  export const MissionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    pointReward: 'pointReward'
  };

  export type MissionScalarFieldEnum = (typeof MissionScalarFieldEnum)[keyof typeof MissionScalarFieldEnum]


  export const DinerMissionScalarFieldEnum: {
    id: 'id',
    dinerId: 'dinerId',
    missionId: 'missionId',
    startDate: 'startDate',
    endDate: 'endDate'
  };

  export type DinerMissionScalarFieldEnum = (typeof DinerMissionScalarFieldEnum)[keyof typeof DinerMissionScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    dinerId: 'dinerId',
    userId: 'userId',
    rating: 'rating',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const PointHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    historyDate: 'historyDate',
    description: 'description',
    amount: 'amount'
  };

  export type PointHistoryScalarFieldEnum = (typeof PointHistoryScalarFieldEnum)[keyof typeof PointHistoryScalarFieldEnum]


  export const MissionClearLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    dinerMissionId: 'dinerMissionId',
    pointHistoryId: 'pointHistoryId',
    status: 'status',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type MissionClearLogScalarFieldEnum = (typeof MissionClearLogScalarFieldEnum)[keyof typeof MissionClearLogScalarFieldEnum]


  export const InquiryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type InquiryScalarFieldEnum = (typeof InquiryScalarFieldEnum)[keyof typeof InquiryScalarFieldEnum]


  export const RegionMissionCounterScalarFieldEnum: {
    id: 'id',
    regionId: 'regionId',
    userId: 'userId',
    missionCount: 'missionCount'
  };

  export type RegionMissionCounterScalarFieldEnum = (typeof RegionMissionCounterScalarFieldEnum)[keyof typeof RegionMissionCounterScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    email: 'email',
    name: 'name',
    gender: 'gender',
    address: 'address',
    detailAddress: 'detailAddress',
    phoneNumber: 'phoneNumber'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const FoodCategoryOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type FoodCategoryOrderByRelevanceFieldEnum = (typeof FoodCategoryOrderByRelevanceFieldEnum)[keyof typeof FoodCategoryOrderByRelevanceFieldEnum]


  export const RegionOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type RegionOrderByRelevanceFieldEnum = (typeof RegionOrderByRelevanceFieldEnum)[keyof typeof RegionOrderByRelevanceFieldEnum]


  export const DinerOrderByRelevanceFieldEnum: {
    name: 'name',
    phoneNumber: 'phoneNumber',
    address: 'address'
  };

  export type DinerOrderByRelevanceFieldEnum = (typeof DinerOrderByRelevanceFieldEnum)[keyof typeof DinerOrderByRelevanceFieldEnum]


  export const MissionOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description'
  };

  export type MissionOrderByRelevanceFieldEnum = (typeof MissionOrderByRelevanceFieldEnum)[keyof typeof MissionOrderByRelevanceFieldEnum]


  export const ReviewOrderByRelevanceFieldEnum: {
    content: 'content'
  };

  export type ReviewOrderByRelevanceFieldEnum = (typeof ReviewOrderByRelevanceFieldEnum)[keyof typeof ReviewOrderByRelevanceFieldEnum]


  export const PointHistoryOrderByRelevanceFieldEnum: {
    description: 'description'
  };

  export type PointHistoryOrderByRelevanceFieldEnum = (typeof PointHistoryOrderByRelevanceFieldEnum)[keyof typeof PointHistoryOrderByRelevanceFieldEnum]


  export const MissionClearLogOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type MissionClearLogOrderByRelevanceFieldEnum = (typeof MissionClearLogOrderByRelevanceFieldEnum)[keyof typeof MissionClearLogOrderByRelevanceFieldEnum]


  export const InquiryOrderByRelevanceFieldEnum: {
    title: 'title',
    content: 'content'
  };

  export type InquiryOrderByRelevanceFieldEnum = (typeof InquiryOrderByRelevanceFieldEnum)[keyof typeof InquiryOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    gender?: StringFilter<"User"> | string
    birth?: DateTimeFilter<"User"> | Date | string
    address?: StringFilter<"User"> | string
    detailAddress?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringFilter<"User"> | string
    userFavorCategories?: UserFavorCategoryListRelationFilter
    reviews?: ReviewListRelationFilter
    pointHistories?: PointHistoryListRelationFilter
    missionClearLogs?: MissionClearLogListRelationFilter
    inquiries?: InquiryListRelationFilter
    regionMissionCounts?: RegionMissionCounterListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    gender?: SortOrder
    birth?: SortOrder
    address?: SortOrder
    detailAddress?: SortOrderInput | SortOrder
    phoneNumber?: SortOrder
    userFavorCategories?: UserFavorCategoryOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    pointHistories?: PointHistoryOrderByRelationAggregateInput
    missionClearLogs?: MissionClearLogOrderByRelationAggregateInput
    inquiries?: InquiryOrderByRelationAggregateInput
    regionMissionCounts?: RegionMissionCounterOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    gender?: StringFilter<"User"> | string
    birth?: DateTimeFilter<"User"> | Date | string
    address?: StringFilter<"User"> | string
    detailAddress?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringFilter<"User"> | string
    userFavorCategories?: UserFavorCategoryListRelationFilter
    reviews?: ReviewListRelationFilter
    pointHistories?: PointHistoryListRelationFilter
    missionClearLogs?: MissionClearLogListRelationFilter
    inquiries?: InquiryListRelationFilter
    regionMissionCounts?: RegionMissionCounterListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    gender?: SortOrder
    birth?: SortOrder
    address?: SortOrder
    detailAddress?: SortOrderInput | SortOrder
    phoneNumber?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    gender?: StringWithAggregatesFilter<"User"> | string
    birth?: DateTimeWithAggregatesFilter<"User"> | Date | string
    address?: StringWithAggregatesFilter<"User"> | string
    detailAddress?: StringNullableWithAggregatesFilter<"User"> | string | null
    phoneNumber?: StringWithAggregatesFilter<"User"> | string
  }

  export type FoodCategoryWhereInput = {
    AND?: FoodCategoryWhereInput | FoodCategoryWhereInput[]
    OR?: FoodCategoryWhereInput[]
    NOT?: FoodCategoryWhereInput | FoodCategoryWhereInput[]
    id?: IntFilter<"FoodCategory"> | number
    name?: StringFilter<"FoodCategory"> | string
    diners?: DinerListRelationFilter
    userFavorCategories?: UserFavorCategoryListRelationFilter
  }

  export type FoodCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    diners?: DinerOrderByRelationAggregateInput
    userFavorCategories?: UserFavorCategoryOrderByRelationAggregateInput
    _relevance?: FoodCategoryOrderByRelevanceInput
  }

  export type FoodCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoodCategoryWhereInput | FoodCategoryWhereInput[]
    OR?: FoodCategoryWhereInput[]
    NOT?: FoodCategoryWhereInput | FoodCategoryWhereInput[]
    name?: StringFilter<"FoodCategory"> | string
    diners?: DinerListRelationFilter
    userFavorCategories?: UserFavorCategoryListRelationFilter
  }, "id">

  export type FoodCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: FoodCategoryCountOrderByAggregateInput
    _avg?: FoodCategoryAvgOrderByAggregateInput
    _max?: FoodCategoryMaxOrderByAggregateInput
    _min?: FoodCategoryMinOrderByAggregateInput
    _sum?: FoodCategorySumOrderByAggregateInput
  }

  export type FoodCategoryScalarWhereWithAggregatesInput = {
    AND?: FoodCategoryScalarWhereWithAggregatesInput | FoodCategoryScalarWhereWithAggregatesInput[]
    OR?: FoodCategoryScalarWhereWithAggregatesInput[]
    NOT?: FoodCategoryScalarWhereWithAggregatesInput | FoodCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoodCategory"> | number
    name?: StringWithAggregatesFilter<"FoodCategory"> | string
  }

  export type UserFavorCategoryWhereInput = {
    AND?: UserFavorCategoryWhereInput | UserFavorCategoryWhereInput[]
    OR?: UserFavorCategoryWhereInput[]
    NOT?: UserFavorCategoryWhereInput | UserFavorCategoryWhereInput[]
    id?: IntFilter<"UserFavorCategory"> | number
    userId?: IntFilter<"UserFavorCategory"> | number
    foodCategoryId?: IntFilter<"UserFavorCategory"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    foodCategory?: XOR<FoodCategoryScalarRelationFilter, FoodCategoryWhereInput>
  }

  export type UserFavorCategoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    foodCategoryId?: SortOrder
    user?: UserOrderByWithRelationInput
    foodCategory?: FoodCategoryOrderByWithRelationInput
  }

  export type UserFavorCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserFavorCategoryWhereInput | UserFavorCategoryWhereInput[]
    OR?: UserFavorCategoryWhereInput[]
    NOT?: UserFavorCategoryWhereInput | UserFavorCategoryWhereInput[]
    userId?: IntFilter<"UserFavorCategory"> | number
    foodCategoryId?: IntFilter<"UserFavorCategory"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    foodCategory?: XOR<FoodCategoryScalarRelationFilter, FoodCategoryWhereInput>
  }, "id">

  export type UserFavorCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    foodCategoryId?: SortOrder
    _count?: UserFavorCategoryCountOrderByAggregateInput
    _avg?: UserFavorCategoryAvgOrderByAggregateInput
    _max?: UserFavorCategoryMaxOrderByAggregateInput
    _min?: UserFavorCategoryMinOrderByAggregateInput
    _sum?: UserFavorCategorySumOrderByAggregateInput
  }

  export type UserFavorCategoryScalarWhereWithAggregatesInput = {
    AND?: UserFavorCategoryScalarWhereWithAggregatesInput | UserFavorCategoryScalarWhereWithAggregatesInput[]
    OR?: UserFavorCategoryScalarWhereWithAggregatesInput[]
    NOT?: UserFavorCategoryScalarWhereWithAggregatesInput | UserFavorCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserFavorCategory"> | number
    userId?: IntWithAggregatesFilter<"UserFavorCategory"> | number
    foodCategoryId?: IntWithAggregatesFilter<"UserFavorCategory"> | number
  }

  export type RegionWhereInput = {
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    id?: IntFilter<"Region"> | number
    name?: StringFilter<"Region"> | string
    diners?: DinerListRelationFilter
    regionMissionCounters?: RegionMissionCounterListRelationFilter
  }

  export type RegionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    diners?: DinerOrderByRelationAggregateInput
    regionMissionCounters?: RegionMissionCounterOrderByRelationAggregateInput
    _relevance?: RegionOrderByRelevanceInput
  }

  export type RegionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    name?: StringFilter<"Region"> | string
    diners?: DinerListRelationFilter
    regionMissionCounters?: RegionMissionCounterListRelationFilter
  }, "id">

  export type RegionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RegionCountOrderByAggregateInput
    _avg?: RegionAvgOrderByAggregateInput
    _max?: RegionMaxOrderByAggregateInput
    _min?: RegionMinOrderByAggregateInput
    _sum?: RegionSumOrderByAggregateInput
  }

  export type RegionScalarWhereWithAggregatesInput = {
    AND?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    OR?: RegionScalarWhereWithAggregatesInput[]
    NOT?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Region"> | number
    name?: StringWithAggregatesFilter<"Region"> | string
  }

  export type DinerWhereInput = {
    AND?: DinerWhereInput | DinerWhereInput[]
    OR?: DinerWhereInput[]
    NOT?: DinerWhereInput | DinerWhereInput[]
    id?: IntFilter<"Diner"> | number
    regionId?: IntFilter<"Diner"> | number
    categoryId?: IntFilter<"Diner"> | number
    name?: StringFilter<"Diner"> | string
    phoneNumber?: StringNullableFilter<"Diner"> | string | null
    address?: StringNullableFilter<"Diner"> | string | null
    rating?: FloatNullableFilter<"Diner"> | number | null
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    category?: XOR<FoodCategoryScalarRelationFilter, FoodCategoryWhereInput>
    dinerMissions?: DinerMissionListRelationFilter
    reviews?: ReviewListRelationFilter
  }

  export type DinerOrderByWithRelationInput = {
    id?: SortOrder
    regionId?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    region?: RegionOrderByWithRelationInput
    category?: FoodCategoryOrderByWithRelationInput
    dinerMissions?: DinerMissionOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    _relevance?: DinerOrderByRelevanceInput
  }

  export type DinerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DinerWhereInput | DinerWhereInput[]
    OR?: DinerWhereInput[]
    NOT?: DinerWhereInput | DinerWhereInput[]
    regionId?: IntFilter<"Diner"> | number
    categoryId?: IntFilter<"Diner"> | number
    name?: StringFilter<"Diner"> | string
    phoneNumber?: StringNullableFilter<"Diner"> | string | null
    address?: StringNullableFilter<"Diner"> | string | null
    rating?: FloatNullableFilter<"Diner"> | number | null
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    category?: XOR<FoodCategoryScalarRelationFilter, FoodCategoryWhereInput>
    dinerMissions?: DinerMissionListRelationFilter
    reviews?: ReviewListRelationFilter
  }, "id">

  export type DinerOrderByWithAggregationInput = {
    id?: SortOrder
    regionId?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    _count?: DinerCountOrderByAggregateInput
    _avg?: DinerAvgOrderByAggregateInput
    _max?: DinerMaxOrderByAggregateInput
    _min?: DinerMinOrderByAggregateInput
    _sum?: DinerSumOrderByAggregateInput
  }

  export type DinerScalarWhereWithAggregatesInput = {
    AND?: DinerScalarWhereWithAggregatesInput | DinerScalarWhereWithAggregatesInput[]
    OR?: DinerScalarWhereWithAggregatesInput[]
    NOT?: DinerScalarWhereWithAggregatesInput | DinerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Diner"> | number
    regionId?: IntWithAggregatesFilter<"Diner"> | number
    categoryId?: IntWithAggregatesFilter<"Diner"> | number
    name?: StringWithAggregatesFilter<"Diner"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"Diner"> | string | null
    address?: StringNullableWithAggregatesFilter<"Diner"> | string | null
    rating?: FloatNullableWithAggregatesFilter<"Diner"> | number | null
  }

  export type MissionWhereInput = {
    AND?: MissionWhereInput | MissionWhereInput[]
    OR?: MissionWhereInput[]
    NOT?: MissionWhereInput | MissionWhereInput[]
    id?: IntFilter<"Mission"> | number
    title?: StringFilter<"Mission"> | string
    description?: StringNullableFilter<"Mission"> | string | null
    pointReward?: IntFilter<"Mission"> | number
    dinerMissions?: DinerMissionListRelationFilter
  }

  export type MissionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    pointReward?: SortOrder
    dinerMissions?: DinerMissionOrderByRelationAggregateInput
    _relevance?: MissionOrderByRelevanceInput
  }

  export type MissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MissionWhereInput | MissionWhereInput[]
    OR?: MissionWhereInput[]
    NOT?: MissionWhereInput | MissionWhereInput[]
    title?: StringFilter<"Mission"> | string
    description?: StringNullableFilter<"Mission"> | string | null
    pointReward?: IntFilter<"Mission"> | number
    dinerMissions?: DinerMissionListRelationFilter
  }, "id">

  export type MissionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    pointReward?: SortOrder
    _count?: MissionCountOrderByAggregateInput
    _avg?: MissionAvgOrderByAggregateInput
    _max?: MissionMaxOrderByAggregateInput
    _min?: MissionMinOrderByAggregateInput
    _sum?: MissionSumOrderByAggregateInput
  }

  export type MissionScalarWhereWithAggregatesInput = {
    AND?: MissionScalarWhereWithAggregatesInput | MissionScalarWhereWithAggregatesInput[]
    OR?: MissionScalarWhereWithAggregatesInput[]
    NOT?: MissionScalarWhereWithAggregatesInput | MissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Mission"> | number
    title?: StringWithAggregatesFilter<"Mission"> | string
    description?: StringNullableWithAggregatesFilter<"Mission"> | string | null
    pointReward?: IntWithAggregatesFilter<"Mission"> | number
  }

  export type DinerMissionWhereInput = {
    AND?: DinerMissionWhereInput | DinerMissionWhereInput[]
    OR?: DinerMissionWhereInput[]
    NOT?: DinerMissionWhereInput | DinerMissionWhereInput[]
    id?: IntFilter<"DinerMission"> | number
    dinerId?: IntFilter<"DinerMission"> | number
    missionId?: IntFilter<"DinerMission"> | number
    startDate?: DateTimeFilter<"DinerMission"> | Date | string
    endDate?: DateTimeNullableFilter<"DinerMission"> | Date | string | null
    diner?: XOR<DinerScalarRelationFilter, DinerWhereInput>
    mission?: XOR<MissionScalarRelationFilter, MissionWhereInput>
    missionClearLogs?: MissionClearLogListRelationFilter
  }

  export type DinerMissionOrderByWithRelationInput = {
    id?: SortOrder
    dinerId?: SortOrder
    missionId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    diner?: DinerOrderByWithRelationInput
    mission?: MissionOrderByWithRelationInput
    missionClearLogs?: MissionClearLogOrderByRelationAggregateInput
  }

  export type DinerMissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DinerMissionWhereInput | DinerMissionWhereInput[]
    OR?: DinerMissionWhereInput[]
    NOT?: DinerMissionWhereInput | DinerMissionWhereInput[]
    dinerId?: IntFilter<"DinerMission"> | number
    missionId?: IntFilter<"DinerMission"> | number
    startDate?: DateTimeFilter<"DinerMission"> | Date | string
    endDate?: DateTimeNullableFilter<"DinerMission"> | Date | string | null
    diner?: XOR<DinerScalarRelationFilter, DinerWhereInput>
    mission?: XOR<MissionScalarRelationFilter, MissionWhereInput>
    missionClearLogs?: MissionClearLogListRelationFilter
  }, "id">

  export type DinerMissionOrderByWithAggregationInput = {
    id?: SortOrder
    dinerId?: SortOrder
    missionId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    _count?: DinerMissionCountOrderByAggregateInput
    _avg?: DinerMissionAvgOrderByAggregateInput
    _max?: DinerMissionMaxOrderByAggregateInput
    _min?: DinerMissionMinOrderByAggregateInput
    _sum?: DinerMissionSumOrderByAggregateInput
  }

  export type DinerMissionScalarWhereWithAggregatesInput = {
    AND?: DinerMissionScalarWhereWithAggregatesInput | DinerMissionScalarWhereWithAggregatesInput[]
    OR?: DinerMissionScalarWhereWithAggregatesInput[]
    NOT?: DinerMissionScalarWhereWithAggregatesInput | DinerMissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DinerMission"> | number
    dinerId?: IntWithAggregatesFilter<"DinerMission"> | number
    missionId?: IntWithAggregatesFilter<"DinerMission"> | number
    startDate?: DateTimeWithAggregatesFilter<"DinerMission"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"DinerMission"> | Date | string | null
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: IntFilter<"Review"> | number
    dinerId?: IntFilter<"Review"> | number
    userId?: IntFilter<"Review"> | number
    rating?: IntFilter<"Review"> | number
    content?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    diner?: XOR<DinerScalarRelationFilter, DinerWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    dinerId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    diner?: DinerOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: ReviewOrderByRelevanceInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    dinerId?: IntFilter<"Review"> | number
    userId?: IntFilter<"Review"> | number
    rating?: IntFilter<"Review"> | number
    content?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    diner?: XOR<DinerScalarRelationFilter, DinerWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    dinerId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Review"> | number
    dinerId?: IntWithAggregatesFilter<"Review"> | number
    userId?: IntWithAggregatesFilter<"Review"> | number
    rating?: IntWithAggregatesFilter<"Review"> | number
    content?: StringNullableWithAggregatesFilter<"Review"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type PointHistoryWhereInput = {
    AND?: PointHistoryWhereInput | PointHistoryWhereInput[]
    OR?: PointHistoryWhereInput[]
    NOT?: PointHistoryWhereInput | PointHistoryWhereInput[]
    id?: IntFilter<"PointHistory"> | number
    userId?: IntFilter<"PointHistory"> | number
    historyDate?: DateTimeFilter<"PointHistory"> | Date | string
    description?: StringNullableFilter<"PointHistory"> | string | null
    amount?: IntFilter<"PointHistory"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    missionClearLogs?: MissionClearLogListRelationFilter
  }

  export type PointHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    historyDate?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    user?: UserOrderByWithRelationInput
    missionClearLogs?: MissionClearLogOrderByRelationAggregateInput
    _relevance?: PointHistoryOrderByRelevanceInput
  }

  export type PointHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PointHistoryWhereInput | PointHistoryWhereInput[]
    OR?: PointHistoryWhereInput[]
    NOT?: PointHistoryWhereInput | PointHistoryWhereInput[]
    userId?: IntFilter<"PointHistory"> | number
    historyDate?: DateTimeFilter<"PointHistory"> | Date | string
    description?: StringNullableFilter<"PointHistory"> | string | null
    amount?: IntFilter<"PointHistory"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    missionClearLogs?: MissionClearLogListRelationFilter
  }, "id">

  export type PointHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    historyDate?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    _count?: PointHistoryCountOrderByAggregateInput
    _avg?: PointHistoryAvgOrderByAggregateInput
    _max?: PointHistoryMaxOrderByAggregateInput
    _min?: PointHistoryMinOrderByAggregateInput
    _sum?: PointHistorySumOrderByAggregateInput
  }

  export type PointHistoryScalarWhereWithAggregatesInput = {
    AND?: PointHistoryScalarWhereWithAggregatesInput | PointHistoryScalarWhereWithAggregatesInput[]
    OR?: PointHistoryScalarWhereWithAggregatesInput[]
    NOT?: PointHistoryScalarWhereWithAggregatesInput | PointHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PointHistory"> | number
    userId?: IntWithAggregatesFilter<"PointHistory"> | number
    historyDate?: DateTimeWithAggregatesFilter<"PointHistory"> | Date | string
    description?: StringNullableWithAggregatesFilter<"PointHistory"> | string | null
    amount?: IntWithAggregatesFilter<"PointHistory"> | number
  }

  export type MissionClearLogWhereInput = {
    AND?: MissionClearLogWhereInput | MissionClearLogWhereInput[]
    OR?: MissionClearLogWhereInput[]
    NOT?: MissionClearLogWhereInput | MissionClearLogWhereInput[]
    id?: IntFilter<"MissionClearLog"> | number
    userId?: IntFilter<"MissionClearLog"> | number
    dinerMissionId?: IntFilter<"MissionClearLog"> | number
    pointHistoryId?: IntNullableFilter<"MissionClearLog"> | number | null
    status?: StringFilter<"MissionClearLog"> | string
    startedAt?: DateTimeFilter<"MissionClearLog"> | Date | string
    completedAt?: DateTimeNullableFilter<"MissionClearLog"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    dinerMission?: XOR<DinerMissionScalarRelationFilter, DinerMissionWhereInput>
    pointHistory?: XOR<PointHistoryNullableScalarRelationFilter, PointHistoryWhereInput> | null
  }

  export type MissionClearLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    dinerMissionId?: SortOrder
    pointHistoryId?: SortOrderInput | SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    dinerMission?: DinerMissionOrderByWithRelationInput
    pointHistory?: PointHistoryOrderByWithRelationInput
    _relevance?: MissionClearLogOrderByRelevanceInput
  }

  export type MissionClearLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MissionClearLogWhereInput | MissionClearLogWhereInput[]
    OR?: MissionClearLogWhereInput[]
    NOT?: MissionClearLogWhereInput | MissionClearLogWhereInput[]
    userId?: IntFilter<"MissionClearLog"> | number
    dinerMissionId?: IntFilter<"MissionClearLog"> | number
    pointHistoryId?: IntNullableFilter<"MissionClearLog"> | number | null
    status?: StringFilter<"MissionClearLog"> | string
    startedAt?: DateTimeFilter<"MissionClearLog"> | Date | string
    completedAt?: DateTimeNullableFilter<"MissionClearLog"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    dinerMission?: XOR<DinerMissionScalarRelationFilter, DinerMissionWhereInput>
    pointHistory?: XOR<PointHistoryNullableScalarRelationFilter, PointHistoryWhereInput> | null
  }, "id">

  export type MissionClearLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    dinerMissionId?: SortOrder
    pointHistoryId?: SortOrderInput | SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: MissionClearLogCountOrderByAggregateInput
    _avg?: MissionClearLogAvgOrderByAggregateInput
    _max?: MissionClearLogMaxOrderByAggregateInput
    _min?: MissionClearLogMinOrderByAggregateInput
    _sum?: MissionClearLogSumOrderByAggregateInput
  }

  export type MissionClearLogScalarWhereWithAggregatesInput = {
    AND?: MissionClearLogScalarWhereWithAggregatesInput | MissionClearLogScalarWhereWithAggregatesInput[]
    OR?: MissionClearLogScalarWhereWithAggregatesInput[]
    NOT?: MissionClearLogScalarWhereWithAggregatesInput | MissionClearLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MissionClearLog"> | number
    userId?: IntWithAggregatesFilter<"MissionClearLog"> | number
    dinerMissionId?: IntWithAggregatesFilter<"MissionClearLog"> | number
    pointHistoryId?: IntNullableWithAggregatesFilter<"MissionClearLog"> | number | null
    status?: StringWithAggregatesFilter<"MissionClearLog"> | string
    startedAt?: DateTimeWithAggregatesFilter<"MissionClearLog"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"MissionClearLog"> | Date | string | null
  }

  export type InquiryWhereInput = {
    AND?: InquiryWhereInput | InquiryWhereInput[]
    OR?: InquiryWhereInput[]
    NOT?: InquiryWhereInput | InquiryWhereInput[]
    id?: IntFilter<"Inquiry"> | number
    userId?: IntFilter<"Inquiry"> | number
    title?: StringFilter<"Inquiry"> | string
    content?: StringNullableFilter<"Inquiry"> | string | null
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InquiryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: InquiryOrderByRelevanceInput
  }

  export type InquiryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InquiryWhereInput | InquiryWhereInput[]
    OR?: InquiryWhereInput[]
    NOT?: InquiryWhereInput | InquiryWhereInput[]
    userId?: IntFilter<"Inquiry"> | number
    title?: StringFilter<"Inquiry"> | string
    content?: StringNullableFilter<"Inquiry"> | string | null
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type InquiryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InquiryCountOrderByAggregateInput
    _avg?: InquiryAvgOrderByAggregateInput
    _max?: InquiryMaxOrderByAggregateInput
    _min?: InquiryMinOrderByAggregateInput
    _sum?: InquirySumOrderByAggregateInput
  }

  export type InquiryScalarWhereWithAggregatesInput = {
    AND?: InquiryScalarWhereWithAggregatesInput | InquiryScalarWhereWithAggregatesInput[]
    OR?: InquiryScalarWhereWithAggregatesInput[]
    NOT?: InquiryScalarWhereWithAggregatesInput | InquiryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Inquiry"> | number
    userId?: IntWithAggregatesFilter<"Inquiry"> | number
    title?: StringWithAggregatesFilter<"Inquiry"> | string
    content?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Inquiry"> | Date | string
  }

  export type RegionMissionCounterWhereInput = {
    AND?: RegionMissionCounterWhereInput | RegionMissionCounterWhereInput[]
    OR?: RegionMissionCounterWhereInput[]
    NOT?: RegionMissionCounterWhereInput | RegionMissionCounterWhereInput[]
    id?: IntFilter<"RegionMissionCounter"> | number
    regionId?: IntFilter<"RegionMissionCounter"> | number
    userId?: IntFilter<"RegionMissionCounter"> | number
    missionCount?: IntFilter<"RegionMissionCounter"> | number
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RegionMissionCounterOrderByWithRelationInput = {
    id?: SortOrder
    regionId?: SortOrder
    userId?: SortOrder
    missionCount?: SortOrder
    region?: RegionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RegionMissionCounterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RegionMissionCounterWhereInput | RegionMissionCounterWhereInput[]
    OR?: RegionMissionCounterWhereInput[]
    NOT?: RegionMissionCounterWhereInput | RegionMissionCounterWhereInput[]
    regionId?: IntFilter<"RegionMissionCounter"> | number
    userId?: IntFilter<"RegionMissionCounter"> | number
    missionCount?: IntFilter<"RegionMissionCounter"> | number
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RegionMissionCounterOrderByWithAggregationInput = {
    id?: SortOrder
    regionId?: SortOrder
    userId?: SortOrder
    missionCount?: SortOrder
    _count?: RegionMissionCounterCountOrderByAggregateInput
    _avg?: RegionMissionCounterAvgOrderByAggregateInput
    _max?: RegionMissionCounterMaxOrderByAggregateInput
    _min?: RegionMissionCounterMinOrderByAggregateInput
    _sum?: RegionMissionCounterSumOrderByAggregateInput
  }

  export type RegionMissionCounterScalarWhereWithAggregatesInput = {
    AND?: RegionMissionCounterScalarWhereWithAggregatesInput | RegionMissionCounterScalarWhereWithAggregatesInput[]
    OR?: RegionMissionCounterScalarWhereWithAggregatesInput[]
    NOT?: RegionMissionCounterScalarWhereWithAggregatesInput | RegionMissionCounterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RegionMissionCounter"> | number
    regionId?: IntWithAggregatesFilter<"RegionMissionCounter"> | number
    userId?: IntWithAggregatesFilter<"RegionMissionCounter"> | number
    missionCount?: IntWithAggregatesFilter<"RegionMissionCounter"> | number
  }

  export type UserCreateInput = {
    email: string
    name: string
    role?: $Enums.UserRole
    gender: string
    birth: Date | string
    address: string
    detailAddress?: string | null
    phoneNumber: string
    userFavorCategories?: UserFavorCategoryCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    pointHistories?: PointHistoryCreateNestedManyWithoutUserInput
    missionClearLogs?: MissionClearLogCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    regionMissionCounts?: RegionMissionCounterCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    name: string
    role?: $Enums.UserRole
    gender: string
    birth: Date | string
    address: string
    detailAddress?: string | null
    phoneNumber: string
    userFavorCategories?: UserFavorCategoryUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    pointHistories?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    missionClearLogs?: MissionClearLogUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    regionMissionCounts?: RegionMissionCounterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: StringFieldUpdateOperationsInput | string
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    userFavorCategories?: UserFavorCategoryUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    pointHistories?: PointHistoryUpdateManyWithoutUserNestedInput
    missionClearLogs?: MissionClearLogUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    regionMissionCounts?: RegionMissionCounterUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: StringFieldUpdateOperationsInput | string
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    userFavorCategories?: UserFavorCategoryUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    pointHistories?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    missionClearLogs?: MissionClearLogUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    regionMissionCounts?: RegionMissionCounterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    name: string
    role?: $Enums.UserRole
    gender: string
    birth: Date | string
    address: string
    detailAddress?: string | null
    phoneNumber: string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: StringFieldUpdateOperationsInput | string
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: StringFieldUpdateOperationsInput | string
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
  }

  export type FoodCategoryCreateInput = {
    name: string
    diners?: DinerCreateNestedManyWithoutCategoryInput
    userFavorCategories?: UserFavorCategoryCreateNestedManyWithoutFoodCategoryInput
  }

  export type FoodCategoryUncheckedCreateInput = {
    id?: number
    name: string
    diners?: DinerUncheckedCreateNestedManyWithoutCategoryInput
    userFavorCategories?: UserFavorCategoryUncheckedCreateNestedManyWithoutFoodCategoryInput
  }

  export type FoodCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    diners?: DinerUpdateManyWithoutCategoryNestedInput
    userFavorCategories?: UserFavorCategoryUpdateManyWithoutFoodCategoryNestedInput
  }

  export type FoodCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    diners?: DinerUncheckedUpdateManyWithoutCategoryNestedInput
    userFavorCategories?: UserFavorCategoryUncheckedUpdateManyWithoutFoodCategoryNestedInput
  }

  export type FoodCategoryCreateManyInput = {
    id?: number
    name: string
  }

  export type FoodCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FoodCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserFavorCategoryCreateInput = {
    user: UserCreateNestedOneWithoutUserFavorCategoriesInput
    foodCategory: FoodCategoryCreateNestedOneWithoutUserFavorCategoriesInput
  }

  export type UserFavorCategoryUncheckedCreateInput = {
    id?: number
    userId: number
    foodCategoryId: number
  }

  export type UserFavorCategoryUpdateInput = {
    user?: UserUpdateOneRequiredWithoutUserFavorCategoriesNestedInput
    foodCategory?: FoodCategoryUpdateOneRequiredWithoutUserFavorCategoriesNestedInput
  }

  export type UserFavorCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    foodCategoryId?: IntFieldUpdateOperationsInput | number
  }

  export type UserFavorCategoryCreateManyInput = {
    id?: number
    userId: number
    foodCategoryId: number
  }

  export type UserFavorCategoryUpdateManyMutationInput = {

  }

  export type UserFavorCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    foodCategoryId?: IntFieldUpdateOperationsInput | number
  }

  export type RegionCreateInput = {
    name: string
    diners?: DinerCreateNestedManyWithoutRegionInput
    regionMissionCounters?: RegionMissionCounterCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateInput = {
    id?: number
    name: string
    diners?: DinerUncheckedCreateNestedManyWithoutRegionInput
    regionMissionCounters?: RegionMissionCounterUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    diners?: DinerUpdateManyWithoutRegionNestedInput
    regionMissionCounters?: RegionMissionCounterUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    diners?: DinerUncheckedUpdateManyWithoutRegionNestedInput
    regionMissionCounters?: RegionMissionCounterUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type RegionCreateManyInput = {
    id?: number
    name: string
  }

  export type RegionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RegionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DinerCreateInput = {
    name: string
    phoneNumber?: string | null
    address?: string | null
    rating?: number | null
    region: RegionCreateNestedOneWithoutDinersInput
    category: FoodCategoryCreateNestedOneWithoutDinersInput
    dinerMissions?: DinerMissionCreateNestedManyWithoutDinerInput
    reviews?: ReviewCreateNestedManyWithoutDinerInput
  }

  export type DinerUncheckedCreateInput = {
    id?: number
    regionId: number
    categoryId: number
    name: string
    phoneNumber?: string | null
    address?: string | null
    rating?: number | null
    dinerMissions?: DinerMissionUncheckedCreateNestedManyWithoutDinerInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutDinerInput
  }

  export type DinerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    region?: RegionUpdateOneRequiredWithoutDinersNestedInput
    category?: FoodCategoryUpdateOneRequiredWithoutDinersNestedInput
    dinerMissions?: DinerMissionUpdateManyWithoutDinerNestedInput
    reviews?: ReviewUpdateManyWithoutDinerNestedInput
  }

  export type DinerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    dinerMissions?: DinerMissionUncheckedUpdateManyWithoutDinerNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutDinerNestedInput
  }

  export type DinerCreateManyInput = {
    id?: number
    regionId: number
    categoryId: number
    name: string
    phoneNumber?: string | null
    address?: string | null
    rating?: number | null
  }

  export type DinerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DinerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type MissionCreateInput = {
    title: string
    description?: string | null
    pointReward?: number
    dinerMissions?: DinerMissionCreateNestedManyWithoutMissionInput
  }

  export type MissionUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    pointReward?: number
    dinerMissions?: DinerMissionUncheckedCreateNestedManyWithoutMissionInput
  }

  export type MissionUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointReward?: IntFieldUpdateOperationsInput | number
    dinerMissions?: DinerMissionUpdateManyWithoutMissionNestedInput
  }

  export type MissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointReward?: IntFieldUpdateOperationsInput | number
    dinerMissions?: DinerMissionUncheckedUpdateManyWithoutMissionNestedInput
  }

  export type MissionCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    pointReward?: number
  }

  export type MissionUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointReward?: IntFieldUpdateOperationsInput | number
  }

  export type MissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointReward?: IntFieldUpdateOperationsInput | number
  }

  export type DinerMissionCreateInput = {
    startDate: Date | string
    endDate?: Date | string | null
    diner: DinerCreateNestedOneWithoutDinerMissionsInput
    mission: MissionCreateNestedOneWithoutDinerMissionsInput
    missionClearLogs?: MissionClearLogCreateNestedManyWithoutDinerMissionInput
  }

  export type DinerMissionUncheckedCreateInput = {
    id?: number
    dinerId: number
    missionId: number
    startDate: Date | string
    endDate?: Date | string | null
    missionClearLogs?: MissionClearLogUncheckedCreateNestedManyWithoutDinerMissionInput
  }

  export type DinerMissionUpdateInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diner?: DinerUpdateOneRequiredWithoutDinerMissionsNestedInput
    mission?: MissionUpdateOneRequiredWithoutDinerMissionsNestedInput
    missionClearLogs?: MissionClearLogUpdateManyWithoutDinerMissionNestedInput
  }

  export type DinerMissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dinerId?: IntFieldUpdateOperationsInput | number
    missionId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missionClearLogs?: MissionClearLogUncheckedUpdateManyWithoutDinerMissionNestedInput
  }

  export type DinerMissionCreateManyInput = {
    id?: number
    dinerId: number
    missionId: number
    startDate: Date | string
    endDate?: Date | string | null
  }

  export type DinerMissionUpdateManyMutationInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DinerMissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dinerId?: IntFieldUpdateOperationsInput | number
    missionId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewCreateInput = {
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    diner: DinerCreateNestedOneWithoutReviewsInput
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: number
    dinerId: number
    userId: number
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    diner?: DinerUpdateOneRequiredWithoutReviewsNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dinerId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: number
    dinerId: number
    userId: number
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dinerId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointHistoryCreateInput = {
    historyDate?: Date | string
    description?: string | null
    amount: number
    user: UserCreateNestedOneWithoutPointHistoriesInput
    missionClearLogs?: MissionClearLogCreateNestedManyWithoutPointHistoryInput
  }

  export type PointHistoryUncheckedCreateInput = {
    id?: number
    userId: number
    historyDate?: Date | string
    description?: string | null
    amount: number
    missionClearLogs?: MissionClearLogUncheckedCreateNestedManyWithoutPointHistoryInput
  }

  export type PointHistoryUpdateInput = {
    historyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutPointHistoriesNestedInput
    missionClearLogs?: MissionClearLogUpdateManyWithoutPointHistoryNestedInput
  }

  export type PointHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    historyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    missionClearLogs?: MissionClearLogUncheckedUpdateManyWithoutPointHistoryNestedInput
  }

  export type PointHistoryCreateManyInput = {
    id?: number
    userId: number
    historyDate?: Date | string
    description?: string | null
    amount: number
  }

  export type PointHistoryUpdateManyMutationInput = {
    historyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type PointHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    historyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type MissionClearLogCreateInput = {
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutMissionClearLogsInput
    dinerMission: DinerMissionCreateNestedOneWithoutMissionClearLogsInput
    pointHistory?: PointHistoryCreateNestedOneWithoutMissionClearLogsInput
  }

  export type MissionClearLogUncheckedCreateInput = {
    id?: number
    userId: number
    dinerMissionId: number
    pointHistoryId?: number | null
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type MissionClearLogUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMissionClearLogsNestedInput
    dinerMission?: DinerMissionUpdateOneRequiredWithoutMissionClearLogsNestedInput
    pointHistory?: PointHistoryUpdateOneWithoutMissionClearLogsNestedInput
  }

  export type MissionClearLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    dinerMissionId?: IntFieldUpdateOperationsInput | number
    pointHistoryId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MissionClearLogCreateManyInput = {
    id?: number
    userId: number
    dinerMissionId: number
    pointHistoryId?: number | null
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type MissionClearLogUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MissionClearLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    dinerMissionId?: IntFieldUpdateOperationsInput | number
    pointHistoryId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InquiryCreateInput = {
    title: string
    content?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutInquiriesInput
  }

  export type InquiryUncheckedCreateInput = {
    id?: number
    userId: number
    title: string
    content?: string | null
    createdAt?: Date | string
  }

  export type InquiryUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInquiriesNestedInput
  }

  export type InquiryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryCreateManyInput = {
    id?: number
    userId: number
    title: string
    content?: string | null
    createdAt?: Date | string
  }

  export type InquiryUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionMissionCounterCreateInput = {
    missionCount?: number
    region: RegionCreateNestedOneWithoutRegionMissionCountersInput
    user: UserCreateNestedOneWithoutRegionMissionCountsInput
  }

  export type RegionMissionCounterUncheckedCreateInput = {
    id?: number
    regionId: number
    userId: number
    missionCount?: number
  }

  export type RegionMissionCounterUpdateInput = {
    missionCount?: IntFieldUpdateOperationsInput | number
    region?: RegionUpdateOneRequiredWithoutRegionMissionCountersNestedInput
    user?: UserUpdateOneRequiredWithoutRegionMissionCountsNestedInput
  }

  export type RegionMissionCounterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    missionCount?: IntFieldUpdateOperationsInput | number
  }

  export type RegionMissionCounterCreateManyInput = {
    id?: number
    regionId: number
    userId: number
    missionCount?: number
  }

  export type RegionMissionCounterUpdateManyMutationInput = {
    missionCount?: IntFieldUpdateOperationsInput | number
  }

  export type RegionMissionCounterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    missionCount?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserFavorCategoryListRelationFilter = {
    every?: UserFavorCategoryWhereInput
    some?: UserFavorCategoryWhereInput
    none?: UserFavorCategoryWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type PointHistoryListRelationFilter = {
    every?: PointHistoryWhereInput
    some?: PointHistoryWhereInput
    none?: PointHistoryWhereInput
  }

  export type MissionClearLogListRelationFilter = {
    every?: MissionClearLogWhereInput
    some?: MissionClearLogWhereInput
    none?: MissionClearLogWhereInput
  }

  export type InquiryListRelationFilter = {
    every?: InquiryWhereInput
    some?: InquiryWhereInput
    none?: InquiryWhereInput
  }

  export type RegionMissionCounterListRelationFilter = {
    every?: RegionMissionCounterWhereInput
    some?: RegionMissionCounterWhereInput
    none?: RegionMissionCounterWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserFavorCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PointHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MissionClearLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InquiryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionMissionCounterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    gender?: SortOrder
    birth?: SortOrder
    address?: SortOrder
    detailAddress?: SortOrder
    phoneNumber?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    gender?: SortOrder
    birth?: SortOrder
    address?: SortOrder
    detailAddress?: SortOrder
    phoneNumber?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    gender?: SortOrder
    birth?: SortOrder
    address?: SortOrder
    detailAddress?: SortOrder
    phoneNumber?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DinerListRelationFilter = {
    every?: DinerWhereInput
    some?: DinerWhereInput
    none?: DinerWhereInput
  }

  export type DinerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodCategoryOrderByRelevanceInput = {
    fields: FoodCategoryOrderByRelevanceFieldEnum | FoodCategoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FoodCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FoodCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FoodCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FoodCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FoodCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type FoodCategoryScalarRelationFilter = {
    is?: FoodCategoryWhereInput
    isNot?: FoodCategoryWhereInput
  }

  export type UserFavorCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    foodCategoryId?: SortOrder
  }

  export type UserFavorCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    foodCategoryId?: SortOrder
  }

  export type UserFavorCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    foodCategoryId?: SortOrder
  }

  export type UserFavorCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    foodCategoryId?: SortOrder
  }

  export type UserFavorCategorySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    foodCategoryId?: SortOrder
  }

  export type RegionOrderByRelevanceInput = {
    fields: RegionOrderByRelevanceFieldEnum | RegionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RegionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RegionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RegionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RegionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RegionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type RegionScalarRelationFilter = {
    is?: RegionWhereInput
    isNot?: RegionWhereInput
  }

  export type DinerMissionListRelationFilter = {
    every?: DinerMissionWhereInput
    some?: DinerMissionWhereInput
    none?: DinerMissionWhereInput
  }

  export type DinerMissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DinerOrderByRelevanceInput = {
    fields: DinerOrderByRelevanceFieldEnum | DinerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DinerCountOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    rating?: SortOrder
  }

  export type DinerAvgOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    categoryId?: SortOrder
    rating?: SortOrder
  }

  export type DinerMaxOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    rating?: SortOrder
  }

  export type DinerMinOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    rating?: SortOrder
  }

  export type DinerSumOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    categoryId?: SortOrder
    rating?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type MissionOrderByRelevanceInput = {
    fields: MissionOrderByRelevanceFieldEnum | MissionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MissionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    pointReward?: SortOrder
  }

  export type MissionAvgOrderByAggregateInput = {
    id?: SortOrder
    pointReward?: SortOrder
  }

  export type MissionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    pointReward?: SortOrder
  }

  export type MissionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    pointReward?: SortOrder
  }

  export type MissionSumOrderByAggregateInput = {
    id?: SortOrder
    pointReward?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DinerScalarRelationFilter = {
    is?: DinerWhereInput
    isNot?: DinerWhereInput
  }

  export type MissionScalarRelationFilter = {
    is?: MissionWhereInput
    isNot?: MissionWhereInput
  }

  export type DinerMissionCountOrderByAggregateInput = {
    id?: SortOrder
    dinerId?: SortOrder
    missionId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type DinerMissionAvgOrderByAggregateInput = {
    id?: SortOrder
    dinerId?: SortOrder
    missionId?: SortOrder
  }

  export type DinerMissionMaxOrderByAggregateInput = {
    id?: SortOrder
    dinerId?: SortOrder
    missionId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type DinerMissionMinOrderByAggregateInput = {
    id?: SortOrder
    dinerId?: SortOrder
    missionId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type DinerMissionSumOrderByAggregateInput = {
    id?: SortOrder
    dinerId?: SortOrder
    missionId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ReviewOrderByRelevanceInput = {
    fields: ReviewOrderByRelevanceFieldEnum | ReviewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    dinerId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    dinerId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    dinerId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    dinerId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    id?: SortOrder
    dinerId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
  }

  export type PointHistoryOrderByRelevanceInput = {
    fields: PointHistoryOrderByRelevanceFieldEnum | PointHistoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PointHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    historyDate?: SortOrder
    description?: SortOrder
    amount?: SortOrder
  }

  export type PointHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
  }

  export type PointHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    historyDate?: SortOrder
    description?: SortOrder
    amount?: SortOrder
  }

  export type PointHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    historyDate?: SortOrder
    description?: SortOrder
    amount?: SortOrder
  }

  export type PointHistorySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DinerMissionScalarRelationFilter = {
    is?: DinerMissionWhereInput
    isNot?: DinerMissionWhereInput
  }

  export type PointHistoryNullableScalarRelationFilter = {
    is?: PointHistoryWhereInput | null
    isNot?: PointHistoryWhereInput | null
  }

  export type MissionClearLogOrderByRelevanceInput = {
    fields: MissionClearLogOrderByRelevanceFieldEnum | MissionClearLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MissionClearLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dinerMissionId?: SortOrder
    pointHistoryId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type MissionClearLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dinerMissionId?: SortOrder
    pointHistoryId?: SortOrder
  }

  export type MissionClearLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dinerMissionId?: SortOrder
    pointHistoryId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type MissionClearLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dinerMissionId?: SortOrder
    pointHistoryId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type MissionClearLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    dinerMissionId?: SortOrder
    pointHistoryId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type InquiryOrderByRelevanceInput = {
    fields: InquiryOrderByRelevanceFieldEnum | InquiryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InquiryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type InquiryAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type InquiryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type InquiryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type InquirySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type RegionMissionCounterCountOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    userId?: SortOrder
    missionCount?: SortOrder
  }

  export type RegionMissionCounterAvgOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    userId?: SortOrder
    missionCount?: SortOrder
  }

  export type RegionMissionCounterMaxOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    userId?: SortOrder
    missionCount?: SortOrder
  }

  export type RegionMissionCounterMinOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    userId?: SortOrder
    missionCount?: SortOrder
  }

  export type RegionMissionCounterSumOrderByAggregateInput = {
    id?: SortOrder
    regionId?: SortOrder
    userId?: SortOrder
    missionCount?: SortOrder
  }

  export type UserFavorCategoryCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFavorCategoryCreateWithoutUserInput, UserFavorCategoryUncheckedCreateWithoutUserInput> | UserFavorCategoryCreateWithoutUserInput[] | UserFavorCategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavorCategoryCreateOrConnectWithoutUserInput | UserFavorCategoryCreateOrConnectWithoutUserInput[]
    createMany?: UserFavorCategoryCreateManyUserInputEnvelope
    connect?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type PointHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<PointHistoryCreateWithoutUserInput, PointHistoryUncheckedCreateWithoutUserInput> | PointHistoryCreateWithoutUserInput[] | PointHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointHistoryCreateOrConnectWithoutUserInput | PointHistoryCreateOrConnectWithoutUserInput[]
    createMany?: PointHistoryCreateManyUserInputEnvelope
    connect?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
  }

  export type MissionClearLogCreateNestedManyWithoutUserInput = {
    create?: XOR<MissionClearLogCreateWithoutUserInput, MissionClearLogUncheckedCreateWithoutUserInput> | MissionClearLogCreateWithoutUserInput[] | MissionClearLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MissionClearLogCreateOrConnectWithoutUserInput | MissionClearLogCreateOrConnectWithoutUserInput[]
    createMany?: MissionClearLogCreateManyUserInputEnvelope
    connect?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
  }

  export type InquiryCreateNestedManyWithoutUserInput = {
    create?: XOR<InquiryCreateWithoutUserInput, InquiryUncheckedCreateWithoutUserInput> | InquiryCreateWithoutUserInput[] | InquiryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutUserInput | InquiryCreateOrConnectWithoutUserInput[]
    createMany?: InquiryCreateManyUserInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type RegionMissionCounterCreateNestedManyWithoutUserInput = {
    create?: XOR<RegionMissionCounterCreateWithoutUserInput, RegionMissionCounterUncheckedCreateWithoutUserInput> | RegionMissionCounterCreateWithoutUserInput[] | RegionMissionCounterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RegionMissionCounterCreateOrConnectWithoutUserInput | RegionMissionCounterCreateOrConnectWithoutUserInput[]
    createMany?: RegionMissionCounterCreateManyUserInputEnvelope
    connect?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
  }

  export type UserFavorCategoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFavorCategoryCreateWithoutUserInput, UserFavorCategoryUncheckedCreateWithoutUserInput> | UserFavorCategoryCreateWithoutUserInput[] | UserFavorCategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavorCategoryCreateOrConnectWithoutUserInput | UserFavorCategoryCreateOrConnectWithoutUserInput[]
    createMany?: UserFavorCategoryCreateManyUserInputEnvelope
    connect?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type PointHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PointHistoryCreateWithoutUserInput, PointHistoryUncheckedCreateWithoutUserInput> | PointHistoryCreateWithoutUserInput[] | PointHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointHistoryCreateOrConnectWithoutUserInput | PointHistoryCreateOrConnectWithoutUserInput[]
    createMany?: PointHistoryCreateManyUserInputEnvelope
    connect?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
  }

  export type MissionClearLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MissionClearLogCreateWithoutUserInput, MissionClearLogUncheckedCreateWithoutUserInput> | MissionClearLogCreateWithoutUserInput[] | MissionClearLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MissionClearLogCreateOrConnectWithoutUserInput | MissionClearLogCreateOrConnectWithoutUserInput[]
    createMany?: MissionClearLogCreateManyUserInputEnvelope
    connect?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
  }

  export type InquiryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InquiryCreateWithoutUserInput, InquiryUncheckedCreateWithoutUserInput> | InquiryCreateWithoutUserInput[] | InquiryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutUserInput | InquiryCreateOrConnectWithoutUserInput[]
    createMany?: InquiryCreateManyUserInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type RegionMissionCounterUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RegionMissionCounterCreateWithoutUserInput, RegionMissionCounterUncheckedCreateWithoutUserInput> | RegionMissionCounterCreateWithoutUserInput[] | RegionMissionCounterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RegionMissionCounterCreateOrConnectWithoutUserInput | RegionMissionCounterCreateOrConnectWithoutUserInput[]
    createMany?: RegionMissionCounterCreateManyUserInputEnvelope
    connect?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserFavorCategoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFavorCategoryCreateWithoutUserInput, UserFavorCategoryUncheckedCreateWithoutUserInput> | UserFavorCategoryCreateWithoutUserInput[] | UserFavorCategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavorCategoryCreateOrConnectWithoutUserInput | UserFavorCategoryCreateOrConnectWithoutUserInput[]
    upsert?: UserFavorCategoryUpsertWithWhereUniqueWithoutUserInput | UserFavorCategoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFavorCategoryCreateManyUserInputEnvelope
    set?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
    disconnect?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
    delete?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
    connect?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
    update?: UserFavorCategoryUpdateWithWhereUniqueWithoutUserInput | UserFavorCategoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFavorCategoryUpdateManyWithWhereWithoutUserInput | UserFavorCategoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFavorCategoryScalarWhereInput | UserFavorCategoryScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type PointHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<PointHistoryCreateWithoutUserInput, PointHistoryUncheckedCreateWithoutUserInput> | PointHistoryCreateWithoutUserInput[] | PointHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointHistoryCreateOrConnectWithoutUserInput | PointHistoryCreateOrConnectWithoutUserInput[]
    upsert?: PointHistoryUpsertWithWhereUniqueWithoutUserInput | PointHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PointHistoryCreateManyUserInputEnvelope
    set?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
    disconnect?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
    delete?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
    connect?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
    update?: PointHistoryUpdateWithWhereUniqueWithoutUserInput | PointHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PointHistoryUpdateManyWithWhereWithoutUserInput | PointHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PointHistoryScalarWhereInput | PointHistoryScalarWhereInput[]
  }

  export type MissionClearLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<MissionClearLogCreateWithoutUserInput, MissionClearLogUncheckedCreateWithoutUserInput> | MissionClearLogCreateWithoutUserInput[] | MissionClearLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MissionClearLogCreateOrConnectWithoutUserInput | MissionClearLogCreateOrConnectWithoutUserInput[]
    upsert?: MissionClearLogUpsertWithWhereUniqueWithoutUserInput | MissionClearLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MissionClearLogCreateManyUserInputEnvelope
    set?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    disconnect?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    delete?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    connect?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    update?: MissionClearLogUpdateWithWhereUniqueWithoutUserInput | MissionClearLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MissionClearLogUpdateManyWithWhereWithoutUserInput | MissionClearLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MissionClearLogScalarWhereInput | MissionClearLogScalarWhereInput[]
  }

  export type InquiryUpdateManyWithoutUserNestedInput = {
    create?: XOR<InquiryCreateWithoutUserInput, InquiryUncheckedCreateWithoutUserInput> | InquiryCreateWithoutUserInput[] | InquiryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutUserInput | InquiryCreateOrConnectWithoutUserInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutUserInput | InquiryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InquiryCreateManyUserInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutUserInput | InquiryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutUserInput | InquiryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type RegionMissionCounterUpdateManyWithoutUserNestedInput = {
    create?: XOR<RegionMissionCounterCreateWithoutUserInput, RegionMissionCounterUncheckedCreateWithoutUserInput> | RegionMissionCounterCreateWithoutUserInput[] | RegionMissionCounterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RegionMissionCounterCreateOrConnectWithoutUserInput | RegionMissionCounterCreateOrConnectWithoutUserInput[]
    upsert?: RegionMissionCounterUpsertWithWhereUniqueWithoutUserInput | RegionMissionCounterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RegionMissionCounterCreateManyUserInputEnvelope
    set?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
    disconnect?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
    delete?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
    connect?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
    update?: RegionMissionCounterUpdateWithWhereUniqueWithoutUserInput | RegionMissionCounterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RegionMissionCounterUpdateManyWithWhereWithoutUserInput | RegionMissionCounterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RegionMissionCounterScalarWhereInput | RegionMissionCounterScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserFavorCategoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFavorCategoryCreateWithoutUserInput, UserFavorCategoryUncheckedCreateWithoutUserInput> | UserFavorCategoryCreateWithoutUserInput[] | UserFavorCategoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFavorCategoryCreateOrConnectWithoutUserInput | UserFavorCategoryCreateOrConnectWithoutUserInput[]
    upsert?: UserFavorCategoryUpsertWithWhereUniqueWithoutUserInput | UserFavorCategoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFavorCategoryCreateManyUserInputEnvelope
    set?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
    disconnect?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
    delete?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
    connect?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
    update?: UserFavorCategoryUpdateWithWhereUniqueWithoutUserInput | UserFavorCategoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFavorCategoryUpdateManyWithWhereWithoutUserInput | UserFavorCategoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFavorCategoryScalarWhereInput | UserFavorCategoryScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type PointHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PointHistoryCreateWithoutUserInput, PointHistoryUncheckedCreateWithoutUserInput> | PointHistoryCreateWithoutUserInput[] | PointHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointHistoryCreateOrConnectWithoutUserInput | PointHistoryCreateOrConnectWithoutUserInput[]
    upsert?: PointHistoryUpsertWithWhereUniqueWithoutUserInput | PointHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PointHistoryCreateManyUserInputEnvelope
    set?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
    disconnect?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
    delete?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
    connect?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
    update?: PointHistoryUpdateWithWhereUniqueWithoutUserInput | PointHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PointHistoryUpdateManyWithWhereWithoutUserInput | PointHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PointHistoryScalarWhereInput | PointHistoryScalarWhereInput[]
  }

  export type MissionClearLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MissionClearLogCreateWithoutUserInput, MissionClearLogUncheckedCreateWithoutUserInput> | MissionClearLogCreateWithoutUserInput[] | MissionClearLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MissionClearLogCreateOrConnectWithoutUserInput | MissionClearLogCreateOrConnectWithoutUserInput[]
    upsert?: MissionClearLogUpsertWithWhereUniqueWithoutUserInput | MissionClearLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MissionClearLogCreateManyUserInputEnvelope
    set?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    disconnect?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    delete?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    connect?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    update?: MissionClearLogUpdateWithWhereUniqueWithoutUserInput | MissionClearLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MissionClearLogUpdateManyWithWhereWithoutUserInput | MissionClearLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MissionClearLogScalarWhereInput | MissionClearLogScalarWhereInput[]
  }

  export type InquiryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InquiryCreateWithoutUserInput, InquiryUncheckedCreateWithoutUserInput> | InquiryCreateWithoutUserInput[] | InquiryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutUserInput | InquiryCreateOrConnectWithoutUserInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutUserInput | InquiryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InquiryCreateManyUserInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutUserInput | InquiryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutUserInput | InquiryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type RegionMissionCounterUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RegionMissionCounterCreateWithoutUserInput, RegionMissionCounterUncheckedCreateWithoutUserInput> | RegionMissionCounterCreateWithoutUserInput[] | RegionMissionCounterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RegionMissionCounterCreateOrConnectWithoutUserInput | RegionMissionCounterCreateOrConnectWithoutUserInput[]
    upsert?: RegionMissionCounterUpsertWithWhereUniqueWithoutUserInput | RegionMissionCounterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RegionMissionCounterCreateManyUserInputEnvelope
    set?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
    disconnect?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
    delete?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
    connect?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
    update?: RegionMissionCounterUpdateWithWhereUniqueWithoutUserInput | RegionMissionCounterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RegionMissionCounterUpdateManyWithWhereWithoutUserInput | RegionMissionCounterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RegionMissionCounterScalarWhereInput | RegionMissionCounterScalarWhereInput[]
  }

  export type DinerCreateNestedManyWithoutCategoryInput = {
    create?: XOR<DinerCreateWithoutCategoryInput, DinerUncheckedCreateWithoutCategoryInput> | DinerCreateWithoutCategoryInput[] | DinerUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: DinerCreateOrConnectWithoutCategoryInput | DinerCreateOrConnectWithoutCategoryInput[]
    createMany?: DinerCreateManyCategoryInputEnvelope
    connect?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
  }

  export type UserFavorCategoryCreateNestedManyWithoutFoodCategoryInput = {
    create?: XOR<UserFavorCategoryCreateWithoutFoodCategoryInput, UserFavorCategoryUncheckedCreateWithoutFoodCategoryInput> | UserFavorCategoryCreateWithoutFoodCategoryInput[] | UserFavorCategoryUncheckedCreateWithoutFoodCategoryInput[]
    connectOrCreate?: UserFavorCategoryCreateOrConnectWithoutFoodCategoryInput | UserFavorCategoryCreateOrConnectWithoutFoodCategoryInput[]
    createMany?: UserFavorCategoryCreateManyFoodCategoryInputEnvelope
    connect?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
  }

  export type DinerUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<DinerCreateWithoutCategoryInput, DinerUncheckedCreateWithoutCategoryInput> | DinerCreateWithoutCategoryInput[] | DinerUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: DinerCreateOrConnectWithoutCategoryInput | DinerCreateOrConnectWithoutCategoryInput[]
    createMany?: DinerCreateManyCategoryInputEnvelope
    connect?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
  }

  export type UserFavorCategoryUncheckedCreateNestedManyWithoutFoodCategoryInput = {
    create?: XOR<UserFavorCategoryCreateWithoutFoodCategoryInput, UserFavorCategoryUncheckedCreateWithoutFoodCategoryInput> | UserFavorCategoryCreateWithoutFoodCategoryInput[] | UserFavorCategoryUncheckedCreateWithoutFoodCategoryInput[]
    connectOrCreate?: UserFavorCategoryCreateOrConnectWithoutFoodCategoryInput | UserFavorCategoryCreateOrConnectWithoutFoodCategoryInput[]
    createMany?: UserFavorCategoryCreateManyFoodCategoryInputEnvelope
    connect?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
  }

  export type DinerUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<DinerCreateWithoutCategoryInput, DinerUncheckedCreateWithoutCategoryInput> | DinerCreateWithoutCategoryInput[] | DinerUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: DinerCreateOrConnectWithoutCategoryInput | DinerCreateOrConnectWithoutCategoryInput[]
    upsert?: DinerUpsertWithWhereUniqueWithoutCategoryInput | DinerUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: DinerCreateManyCategoryInputEnvelope
    set?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
    disconnect?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
    delete?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
    connect?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
    update?: DinerUpdateWithWhereUniqueWithoutCategoryInput | DinerUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: DinerUpdateManyWithWhereWithoutCategoryInput | DinerUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: DinerScalarWhereInput | DinerScalarWhereInput[]
  }

  export type UserFavorCategoryUpdateManyWithoutFoodCategoryNestedInput = {
    create?: XOR<UserFavorCategoryCreateWithoutFoodCategoryInput, UserFavorCategoryUncheckedCreateWithoutFoodCategoryInput> | UserFavorCategoryCreateWithoutFoodCategoryInput[] | UserFavorCategoryUncheckedCreateWithoutFoodCategoryInput[]
    connectOrCreate?: UserFavorCategoryCreateOrConnectWithoutFoodCategoryInput | UserFavorCategoryCreateOrConnectWithoutFoodCategoryInput[]
    upsert?: UserFavorCategoryUpsertWithWhereUniqueWithoutFoodCategoryInput | UserFavorCategoryUpsertWithWhereUniqueWithoutFoodCategoryInput[]
    createMany?: UserFavorCategoryCreateManyFoodCategoryInputEnvelope
    set?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
    disconnect?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
    delete?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
    connect?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
    update?: UserFavorCategoryUpdateWithWhereUniqueWithoutFoodCategoryInput | UserFavorCategoryUpdateWithWhereUniqueWithoutFoodCategoryInput[]
    updateMany?: UserFavorCategoryUpdateManyWithWhereWithoutFoodCategoryInput | UserFavorCategoryUpdateManyWithWhereWithoutFoodCategoryInput[]
    deleteMany?: UserFavorCategoryScalarWhereInput | UserFavorCategoryScalarWhereInput[]
  }

  export type DinerUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<DinerCreateWithoutCategoryInput, DinerUncheckedCreateWithoutCategoryInput> | DinerCreateWithoutCategoryInput[] | DinerUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: DinerCreateOrConnectWithoutCategoryInput | DinerCreateOrConnectWithoutCategoryInput[]
    upsert?: DinerUpsertWithWhereUniqueWithoutCategoryInput | DinerUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: DinerCreateManyCategoryInputEnvelope
    set?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
    disconnect?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
    delete?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
    connect?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
    update?: DinerUpdateWithWhereUniqueWithoutCategoryInput | DinerUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: DinerUpdateManyWithWhereWithoutCategoryInput | DinerUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: DinerScalarWhereInput | DinerScalarWhereInput[]
  }

  export type UserFavorCategoryUncheckedUpdateManyWithoutFoodCategoryNestedInput = {
    create?: XOR<UserFavorCategoryCreateWithoutFoodCategoryInput, UserFavorCategoryUncheckedCreateWithoutFoodCategoryInput> | UserFavorCategoryCreateWithoutFoodCategoryInput[] | UserFavorCategoryUncheckedCreateWithoutFoodCategoryInput[]
    connectOrCreate?: UserFavorCategoryCreateOrConnectWithoutFoodCategoryInput | UserFavorCategoryCreateOrConnectWithoutFoodCategoryInput[]
    upsert?: UserFavorCategoryUpsertWithWhereUniqueWithoutFoodCategoryInput | UserFavorCategoryUpsertWithWhereUniqueWithoutFoodCategoryInput[]
    createMany?: UserFavorCategoryCreateManyFoodCategoryInputEnvelope
    set?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
    disconnect?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
    delete?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
    connect?: UserFavorCategoryWhereUniqueInput | UserFavorCategoryWhereUniqueInput[]
    update?: UserFavorCategoryUpdateWithWhereUniqueWithoutFoodCategoryInput | UserFavorCategoryUpdateWithWhereUniqueWithoutFoodCategoryInput[]
    updateMany?: UserFavorCategoryUpdateManyWithWhereWithoutFoodCategoryInput | UserFavorCategoryUpdateManyWithWhereWithoutFoodCategoryInput[]
    deleteMany?: UserFavorCategoryScalarWhereInput | UserFavorCategoryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserFavorCategoriesInput = {
    create?: XOR<UserCreateWithoutUserFavorCategoriesInput, UserUncheckedCreateWithoutUserFavorCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserFavorCategoriesInput
    connect?: UserWhereUniqueInput
  }

  export type FoodCategoryCreateNestedOneWithoutUserFavorCategoriesInput = {
    create?: XOR<FoodCategoryCreateWithoutUserFavorCategoriesInput, FoodCategoryUncheckedCreateWithoutUserFavorCategoriesInput>
    connectOrCreate?: FoodCategoryCreateOrConnectWithoutUserFavorCategoriesInput
    connect?: FoodCategoryWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserFavorCategoriesNestedInput = {
    create?: XOR<UserCreateWithoutUserFavorCategoriesInput, UserUncheckedCreateWithoutUserFavorCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserFavorCategoriesInput
    upsert?: UserUpsertWithoutUserFavorCategoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserFavorCategoriesInput, UserUpdateWithoutUserFavorCategoriesInput>, UserUncheckedUpdateWithoutUserFavorCategoriesInput>
  }

  export type FoodCategoryUpdateOneRequiredWithoutUserFavorCategoriesNestedInput = {
    create?: XOR<FoodCategoryCreateWithoutUserFavorCategoriesInput, FoodCategoryUncheckedCreateWithoutUserFavorCategoriesInput>
    connectOrCreate?: FoodCategoryCreateOrConnectWithoutUserFavorCategoriesInput
    upsert?: FoodCategoryUpsertWithoutUserFavorCategoriesInput
    connect?: FoodCategoryWhereUniqueInput
    update?: XOR<XOR<FoodCategoryUpdateToOneWithWhereWithoutUserFavorCategoriesInput, FoodCategoryUpdateWithoutUserFavorCategoriesInput>, FoodCategoryUncheckedUpdateWithoutUserFavorCategoriesInput>
  }

  export type DinerCreateNestedManyWithoutRegionInput = {
    create?: XOR<DinerCreateWithoutRegionInput, DinerUncheckedCreateWithoutRegionInput> | DinerCreateWithoutRegionInput[] | DinerUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: DinerCreateOrConnectWithoutRegionInput | DinerCreateOrConnectWithoutRegionInput[]
    createMany?: DinerCreateManyRegionInputEnvelope
    connect?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
  }

  export type RegionMissionCounterCreateNestedManyWithoutRegionInput = {
    create?: XOR<RegionMissionCounterCreateWithoutRegionInput, RegionMissionCounterUncheckedCreateWithoutRegionInput> | RegionMissionCounterCreateWithoutRegionInput[] | RegionMissionCounterUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: RegionMissionCounterCreateOrConnectWithoutRegionInput | RegionMissionCounterCreateOrConnectWithoutRegionInput[]
    createMany?: RegionMissionCounterCreateManyRegionInputEnvelope
    connect?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
  }

  export type DinerUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<DinerCreateWithoutRegionInput, DinerUncheckedCreateWithoutRegionInput> | DinerCreateWithoutRegionInput[] | DinerUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: DinerCreateOrConnectWithoutRegionInput | DinerCreateOrConnectWithoutRegionInput[]
    createMany?: DinerCreateManyRegionInputEnvelope
    connect?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
  }

  export type RegionMissionCounterUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<RegionMissionCounterCreateWithoutRegionInput, RegionMissionCounterUncheckedCreateWithoutRegionInput> | RegionMissionCounterCreateWithoutRegionInput[] | RegionMissionCounterUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: RegionMissionCounterCreateOrConnectWithoutRegionInput | RegionMissionCounterCreateOrConnectWithoutRegionInput[]
    createMany?: RegionMissionCounterCreateManyRegionInputEnvelope
    connect?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
  }

  export type DinerUpdateManyWithoutRegionNestedInput = {
    create?: XOR<DinerCreateWithoutRegionInput, DinerUncheckedCreateWithoutRegionInput> | DinerCreateWithoutRegionInput[] | DinerUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: DinerCreateOrConnectWithoutRegionInput | DinerCreateOrConnectWithoutRegionInput[]
    upsert?: DinerUpsertWithWhereUniqueWithoutRegionInput | DinerUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: DinerCreateManyRegionInputEnvelope
    set?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
    disconnect?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
    delete?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
    connect?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
    update?: DinerUpdateWithWhereUniqueWithoutRegionInput | DinerUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: DinerUpdateManyWithWhereWithoutRegionInput | DinerUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: DinerScalarWhereInput | DinerScalarWhereInput[]
  }

  export type RegionMissionCounterUpdateManyWithoutRegionNestedInput = {
    create?: XOR<RegionMissionCounterCreateWithoutRegionInput, RegionMissionCounterUncheckedCreateWithoutRegionInput> | RegionMissionCounterCreateWithoutRegionInput[] | RegionMissionCounterUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: RegionMissionCounterCreateOrConnectWithoutRegionInput | RegionMissionCounterCreateOrConnectWithoutRegionInput[]
    upsert?: RegionMissionCounterUpsertWithWhereUniqueWithoutRegionInput | RegionMissionCounterUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: RegionMissionCounterCreateManyRegionInputEnvelope
    set?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
    disconnect?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
    delete?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
    connect?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
    update?: RegionMissionCounterUpdateWithWhereUniqueWithoutRegionInput | RegionMissionCounterUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: RegionMissionCounterUpdateManyWithWhereWithoutRegionInput | RegionMissionCounterUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: RegionMissionCounterScalarWhereInput | RegionMissionCounterScalarWhereInput[]
  }

  export type DinerUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<DinerCreateWithoutRegionInput, DinerUncheckedCreateWithoutRegionInput> | DinerCreateWithoutRegionInput[] | DinerUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: DinerCreateOrConnectWithoutRegionInput | DinerCreateOrConnectWithoutRegionInput[]
    upsert?: DinerUpsertWithWhereUniqueWithoutRegionInput | DinerUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: DinerCreateManyRegionInputEnvelope
    set?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
    disconnect?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
    delete?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
    connect?: DinerWhereUniqueInput | DinerWhereUniqueInput[]
    update?: DinerUpdateWithWhereUniqueWithoutRegionInput | DinerUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: DinerUpdateManyWithWhereWithoutRegionInput | DinerUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: DinerScalarWhereInput | DinerScalarWhereInput[]
  }

  export type RegionMissionCounterUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<RegionMissionCounterCreateWithoutRegionInput, RegionMissionCounterUncheckedCreateWithoutRegionInput> | RegionMissionCounterCreateWithoutRegionInput[] | RegionMissionCounterUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: RegionMissionCounterCreateOrConnectWithoutRegionInput | RegionMissionCounterCreateOrConnectWithoutRegionInput[]
    upsert?: RegionMissionCounterUpsertWithWhereUniqueWithoutRegionInput | RegionMissionCounterUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: RegionMissionCounterCreateManyRegionInputEnvelope
    set?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
    disconnect?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
    delete?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
    connect?: RegionMissionCounterWhereUniqueInput | RegionMissionCounterWhereUniqueInput[]
    update?: RegionMissionCounterUpdateWithWhereUniqueWithoutRegionInput | RegionMissionCounterUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: RegionMissionCounterUpdateManyWithWhereWithoutRegionInput | RegionMissionCounterUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: RegionMissionCounterScalarWhereInput | RegionMissionCounterScalarWhereInput[]
  }

  export type RegionCreateNestedOneWithoutDinersInput = {
    create?: XOR<RegionCreateWithoutDinersInput, RegionUncheckedCreateWithoutDinersInput>
    connectOrCreate?: RegionCreateOrConnectWithoutDinersInput
    connect?: RegionWhereUniqueInput
  }

  export type FoodCategoryCreateNestedOneWithoutDinersInput = {
    create?: XOR<FoodCategoryCreateWithoutDinersInput, FoodCategoryUncheckedCreateWithoutDinersInput>
    connectOrCreate?: FoodCategoryCreateOrConnectWithoutDinersInput
    connect?: FoodCategoryWhereUniqueInput
  }

  export type DinerMissionCreateNestedManyWithoutDinerInput = {
    create?: XOR<DinerMissionCreateWithoutDinerInput, DinerMissionUncheckedCreateWithoutDinerInput> | DinerMissionCreateWithoutDinerInput[] | DinerMissionUncheckedCreateWithoutDinerInput[]
    connectOrCreate?: DinerMissionCreateOrConnectWithoutDinerInput | DinerMissionCreateOrConnectWithoutDinerInput[]
    createMany?: DinerMissionCreateManyDinerInputEnvelope
    connect?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutDinerInput = {
    create?: XOR<ReviewCreateWithoutDinerInput, ReviewUncheckedCreateWithoutDinerInput> | ReviewCreateWithoutDinerInput[] | ReviewUncheckedCreateWithoutDinerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutDinerInput | ReviewCreateOrConnectWithoutDinerInput[]
    createMany?: ReviewCreateManyDinerInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type DinerMissionUncheckedCreateNestedManyWithoutDinerInput = {
    create?: XOR<DinerMissionCreateWithoutDinerInput, DinerMissionUncheckedCreateWithoutDinerInput> | DinerMissionCreateWithoutDinerInput[] | DinerMissionUncheckedCreateWithoutDinerInput[]
    connectOrCreate?: DinerMissionCreateOrConnectWithoutDinerInput | DinerMissionCreateOrConnectWithoutDinerInput[]
    createMany?: DinerMissionCreateManyDinerInputEnvelope
    connect?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutDinerInput = {
    create?: XOR<ReviewCreateWithoutDinerInput, ReviewUncheckedCreateWithoutDinerInput> | ReviewCreateWithoutDinerInput[] | ReviewUncheckedCreateWithoutDinerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutDinerInput | ReviewCreateOrConnectWithoutDinerInput[]
    createMany?: ReviewCreateManyDinerInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RegionUpdateOneRequiredWithoutDinersNestedInput = {
    create?: XOR<RegionCreateWithoutDinersInput, RegionUncheckedCreateWithoutDinersInput>
    connectOrCreate?: RegionCreateOrConnectWithoutDinersInput
    upsert?: RegionUpsertWithoutDinersInput
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutDinersInput, RegionUpdateWithoutDinersInput>, RegionUncheckedUpdateWithoutDinersInput>
  }

  export type FoodCategoryUpdateOneRequiredWithoutDinersNestedInput = {
    create?: XOR<FoodCategoryCreateWithoutDinersInput, FoodCategoryUncheckedCreateWithoutDinersInput>
    connectOrCreate?: FoodCategoryCreateOrConnectWithoutDinersInput
    upsert?: FoodCategoryUpsertWithoutDinersInput
    connect?: FoodCategoryWhereUniqueInput
    update?: XOR<XOR<FoodCategoryUpdateToOneWithWhereWithoutDinersInput, FoodCategoryUpdateWithoutDinersInput>, FoodCategoryUncheckedUpdateWithoutDinersInput>
  }

  export type DinerMissionUpdateManyWithoutDinerNestedInput = {
    create?: XOR<DinerMissionCreateWithoutDinerInput, DinerMissionUncheckedCreateWithoutDinerInput> | DinerMissionCreateWithoutDinerInput[] | DinerMissionUncheckedCreateWithoutDinerInput[]
    connectOrCreate?: DinerMissionCreateOrConnectWithoutDinerInput | DinerMissionCreateOrConnectWithoutDinerInput[]
    upsert?: DinerMissionUpsertWithWhereUniqueWithoutDinerInput | DinerMissionUpsertWithWhereUniqueWithoutDinerInput[]
    createMany?: DinerMissionCreateManyDinerInputEnvelope
    set?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
    disconnect?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
    delete?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
    connect?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
    update?: DinerMissionUpdateWithWhereUniqueWithoutDinerInput | DinerMissionUpdateWithWhereUniqueWithoutDinerInput[]
    updateMany?: DinerMissionUpdateManyWithWhereWithoutDinerInput | DinerMissionUpdateManyWithWhereWithoutDinerInput[]
    deleteMany?: DinerMissionScalarWhereInput | DinerMissionScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutDinerNestedInput = {
    create?: XOR<ReviewCreateWithoutDinerInput, ReviewUncheckedCreateWithoutDinerInput> | ReviewCreateWithoutDinerInput[] | ReviewUncheckedCreateWithoutDinerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutDinerInput | ReviewCreateOrConnectWithoutDinerInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutDinerInput | ReviewUpsertWithWhereUniqueWithoutDinerInput[]
    createMany?: ReviewCreateManyDinerInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutDinerInput | ReviewUpdateWithWhereUniqueWithoutDinerInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutDinerInput | ReviewUpdateManyWithWhereWithoutDinerInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type DinerMissionUncheckedUpdateManyWithoutDinerNestedInput = {
    create?: XOR<DinerMissionCreateWithoutDinerInput, DinerMissionUncheckedCreateWithoutDinerInput> | DinerMissionCreateWithoutDinerInput[] | DinerMissionUncheckedCreateWithoutDinerInput[]
    connectOrCreate?: DinerMissionCreateOrConnectWithoutDinerInput | DinerMissionCreateOrConnectWithoutDinerInput[]
    upsert?: DinerMissionUpsertWithWhereUniqueWithoutDinerInput | DinerMissionUpsertWithWhereUniqueWithoutDinerInput[]
    createMany?: DinerMissionCreateManyDinerInputEnvelope
    set?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
    disconnect?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
    delete?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
    connect?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
    update?: DinerMissionUpdateWithWhereUniqueWithoutDinerInput | DinerMissionUpdateWithWhereUniqueWithoutDinerInput[]
    updateMany?: DinerMissionUpdateManyWithWhereWithoutDinerInput | DinerMissionUpdateManyWithWhereWithoutDinerInput[]
    deleteMany?: DinerMissionScalarWhereInput | DinerMissionScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutDinerNestedInput = {
    create?: XOR<ReviewCreateWithoutDinerInput, ReviewUncheckedCreateWithoutDinerInput> | ReviewCreateWithoutDinerInput[] | ReviewUncheckedCreateWithoutDinerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutDinerInput | ReviewCreateOrConnectWithoutDinerInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutDinerInput | ReviewUpsertWithWhereUniqueWithoutDinerInput[]
    createMany?: ReviewCreateManyDinerInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutDinerInput | ReviewUpdateWithWhereUniqueWithoutDinerInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutDinerInput | ReviewUpdateManyWithWhereWithoutDinerInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type DinerMissionCreateNestedManyWithoutMissionInput = {
    create?: XOR<DinerMissionCreateWithoutMissionInput, DinerMissionUncheckedCreateWithoutMissionInput> | DinerMissionCreateWithoutMissionInput[] | DinerMissionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: DinerMissionCreateOrConnectWithoutMissionInput | DinerMissionCreateOrConnectWithoutMissionInput[]
    createMany?: DinerMissionCreateManyMissionInputEnvelope
    connect?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
  }

  export type DinerMissionUncheckedCreateNestedManyWithoutMissionInput = {
    create?: XOR<DinerMissionCreateWithoutMissionInput, DinerMissionUncheckedCreateWithoutMissionInput> | DinerMissionCreateWithoutMissionInput[] | DinerMissionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: DinerMissionCreateOrConnectWithoutMissionInput | DinerMissionCreateOrConnectWithoutMissionInput[]
    createMany?: DinerMissionCreateManyMissionInputEnvelope
    connect?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
  }

  export type DinerMissionUpdateManyWithoutMissionNestedInput = {
    create?: XOR<DinerMissionCreateWithoutMissionInput, DinerMissionUncheckedCreateWithoutMissionInput> | DinerMissionCreateWithoutMissionInput[] | DinerMissionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: DinerMissionCreateOrConnectWithoutMissionInput | DinerMissionCreateOrConnectWithoutMissionInput[]
    upsert?: DinerMissionUpsertWithWhereUniqueWithoutMissionInput | DinerMissionUpsertWithWhereUniqueWithoutMissionInput[]
    createMany?: DinerMissionCreateManyMissionInputEnvelope
    set?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
    disconnect?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
    delete?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
    connect?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
    update?: DinerMissionUpdateWithWhereUniqueWithoutMissionInput | DinerMissionUpdateWithWhereUniqueWithoutMissionInput[]
    updateMany?: DinerMissionUpdateManyWithWhereWithoutMissionInput | DinerMissionUpdateManyWithWhereWithoutMissionInput[]
    deleteMany?: DinerMissionScalarWhereInput | DinerMissionScalarWhereInput[]
  }

  export type DinerMissionUncheckedUpdateManyWithoutMissionNestedInput = {
    create?: XOR<DinerMissionCreateWithoutMissionInput, DinerMissionUncheckedCreateWithoutMissionInput> | DinerMissionCreateWithoutMissionInput[] | DinerMissionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: DinerMissionCreateOrConnectWithoutMissionInput | DinerMissionCreateOrConnectWithoutMissionInput[]
    upsert?: DinerMissionUpsertWithWhereUniqueWithoutMissionInput | DinerMissionUpsertWithWhereUniqueWithoutMissionInput[]
    createMany?: DinerMissionCreateManyMissionInputEnvelope
    set?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
    disconnect?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
    delete?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
    connect?: DinerMissionWhereUniqueInput | DinerMissionWhereUniqueInput[]
    update?: DinerMissionUpdateWithWhereUniqueWithoutMissionInput | DinerMissionUpdateWithWhereUniqueWithoutMissionInput[]
    updateMany?: DinerMissionUpdateManyWithWhereWithoutMissionInput | DinerMissionUpdateManyWithWhereWithoutMissionInput[]
    deleteMany?: DinerMissionScalarWhereInput | DinerMissionScalarWhereInput[]
  }

  export type DinerCreateNestedOneWithoutDinerMissionsInput = {
    create?: XOR<DinerCreateWithoutDinerMissionsInput, DinerUncheckedCreateWithoutDinerMissionsInput>
    connectOrCreate?: DinerCreateOrConnectWithoutDinerMissionsInput
    connect?: DinerWhereUniqueInput
  }

  export type MissionCreateNestedOneWithoutDinerMissionsInput = {
    create?: XOR<MissionCreateWithoutDinerMissionsInput, MissionUncheckedCreateWithoutDinerMissionsInput>
    connectOrCreate?: MissionCreateOrConnectWithoutDinerMissionsInput
    connect?: MissionWhereUniqueInput
  }

  export type MissionClearLogCreateNestedManyWithoutDinerMissionInput = {
    create?: XOR<MissionClearLogCreateWithoutDinerMissionInput, MissionClearLogUncheckedCreateWithoutDinerMissionInput> | MissionClearLogCreateWithoutDinerMissionInput[] | MissionClearLogUncheckedCreateWithoutDinerMissionInput[]
    connectOrCreate?: MissionClearLogCreateOrConnectWithoutDinerMissionInput | MissionClearLogCreateOrConnectWithoutDinerMissionInput[]
    createMany?: MissionClearLogCreateManyDinerMissionInputEnvelope
    connect?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
  }

  export type MissionClearLogUncheckedCreateNestedManyWithoutDinerMissionInput = {
    create?: XOR<MissionClearLogCreateWithoutDinerMissionInput, MissionClearLogUncheckedCreateWithoutDinerMissionInput> | MissionClearLogCreateWithoutDinerMissionInput[] | MissionClearLogUncheckedCreateWithoutDinerMissionInput[]
    connectOrCreate?: MissionClearLogCreateOrConnectWithoutDinerMissionInput | MissionClearLogCreateOrConnectWithoutDinerMissionInput[]
    createMany?: MissionClearLogCreateManyDinerMissionInputEnvelope
    connect?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DinerUpdateOneRequiredWithoutDinerMissionsNestedInput = {
    create?: XOR<DinerCreateWithoutDinerMissionsInput, DinerUncheckedCreateWithoutDinerMissionsInput>
    connectOrCreate?: DinerCreateOrConnectWithoutDinerMissionsInput
    upsert?: DinerUpsertWithoutDinerMissionsInput
    connect?: DinerWhereUniqueInput
    update?: XOR<XOR<DinerUpdateToOneWithWhereWithoutDinerMissionsInput, DinerUpdateWithoutDinerMissionsInput>, DinerUncheckedUpdateWithoutDinerMissionsInput>
  }

  export type MissionUpdateOneRequiredWithoutDinerMissionsNestedInput = {
    create?: XOR<MissionCreateWithoutDinerMissionsInput, MissionUncheckedCreateWithoutDinerMissionsInput>
    connectOrCreate?: MissionCreateOrConnectWithoutDinerMissionsInput
    upsert?: MissionUpsertWithoutDinerMissionsInput
    connect?: MissionWhereUniqueInput
    update?: XOR<XOR<MissionUpdateToOneWithWhereWithoutDinerMissionsInput, MissionUpdateWithoutDinerMissionsInput>, MissionUncheckedUpdateWithoutDinerMissionsInput>
  }

  export type MissionClearLogUpdateManyWithoutDinerMissionNestedInput = {
    create?: XOR<MissionClearLogCreateWithoutDinerMissionInput, MissionClearLogUncheckedCreateWithoutDinerMissionInput> | MissionClearLogCreateWithoutDinerMissionInput[] | MissionClearLogUncheckedCreateWithoutDinerMissionInput[]
    connectOrCreate?: MissionClearLogCreateOrConnectWithoutDinerMissionInput | MissionClearLogCreateOrConnectWithoutDinerMissionInput[]
    upsert?: MissionClearLogUpsertWithWhereUniqueWithoutDinerMissionInput | MissionClearLogUpsertWithWhereUniqueWithoutDinerMissionInput[]
    createMany?: MissionClearLogCreateManyDinerMissionInputEnvelope
    set?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    disconnect?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    delete?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    connect?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    update?: MissionClearLogUpdateWithWhereUniqueWithoutDinerMissionInput | MissionClearLogUpdateWithWhereUniqueWithoutDinerMissionInput[]
    updateMany?: MissionClearLogUpdateManyWithWhereWithoutDinerMissionInput | MissionClearLogUpdateManyWithWhereWithoutDinerMissionInput[]
    deleteMany?: MissionClearLogScalarWhereInput | MissionClearLogScalarWhereInput[]
  }

  export type MissionClearLogUncheckedUpdateManyWithoutDinerMissionNestedInput = {
    create?: XOR<MissionClearLogCreateWithoutDinerMissionInput, MissionClearLogUncheckedCreateWithoutDinerMissionInput> | MissionClearLogCreateWithoutDinerMissionInput[] | MissionClearLogUncheckedCreateWithoutDinerMissionInput[]
    connectOrCreate?: MissionClearLogCreateOrConnectWithoutDinerMissionInput | MissionClearLogCreateOrConnectWithoutDinerMissionInput[]
    upsert?: MissionClearLogUpsertWithWhereUniqueWithoutDinerMissionInput | MissionClearLogUpsertWithWhereUniqueWithoutDinerMissionInput[]
    createMany?: MissionClearLogCreateManyDinerMissionInputEnvelope
    set?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    disconnect?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    delete?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    connect?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    update?: MissionClearLogUpdateWithWhereUniqueWithoutDinerMissionInput | MissionClearLogUpdateWithWhereUniqueWithoutDinerMissionInput[]
    updateMany?: MissionClearLogUpdateManyWithWhereWithoutDinerMissionInput | MissionClearLogUpdateManyWithWhereWithoutDinerMissionInput[]
    deleteMany?: MissionClearLogScalarWhereInput | MissionClearLogScalarWhereInput[]
  }

  export type DinerCreateNestedOneWithoutReviewsInput = {
    create?: XOR<DinerCreateWithoutReviewsInput, DinerUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: DinerCreateOrConnectWithoutReviewsInput
    connect?: DinerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type DinerUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<DinerCreateWithoutReviewsInput, DinerUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: DinerCreateOrConnectWithoutReviewsInput
    upsert?: DinerUpsertWithoutReviewsInput
    connect?: DinerWhereUniqueInput
    update?: XOR<XOR<DinerUpdateToOneWithWhereWithoutReviewsInput, DinerUpdateWithoutReviewsInput>, DinerUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserCreateNestedOneWithoutPointHistoriesInput = {
    create?: XOR<UserCreateWithoutPointHistoriesInput, UserUncheckedCreateWithoutPointHistoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPointHistoriesInput
    connect?: UserWhereUniqueInput
  }

  export type MissionClearLogCreateNestedManyWithoutPointHistoryInput = {
    create?: XOR<MissionClearLogCreateWithoutPointHistoryInput, MissionClearLogUncheckedCreateWithoutPointHistoryInput> | MissionClearLogCreateWithoutPointHistoryInput[] | MissionClearLogUncheckedCreateWithoutPointHistoryInput[]
    connectOrCreate?: MissionClearLogCreateOrConnectWithoutPointHistoryInput | MissionClearLogCreateOrConnectWithoutPointHistoryInput[]
    createMany?: MissionClearLogCreateManyPointHistoryInputEnvelope
    connect?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
  }

  export type MissionClearLogUncheckedCreateNestedManyWithoutPointHistoryInput = {
    create?: XOR<MissionClearLogCreateWithoutPointHistoryInput, MissionClearLogUncheckedCreateWithoutPointHistoryInput> | MissionClearLogCreateWithoutPointHistoryInput[] | MissionClearLogUncheckedCreateWithoutPointHistoryInput[]
    connectOrCreate?: MissionClearLogCreateOrConnectWithoutPointHistoryInput | MissionClearLogCreateOrConnectWithoutPointHistoryInput[]
    createMany?: MissionClearLogCreateManyPointHistoryInputEnvelope
    connect?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPointHistoriesNestedInput = {
    create?: XOR<UserCreateWithoutPointHistoriesInput, UserUncheckedCreateWithoutPointHistoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPointHistoriesInput
    upsert?: UserUpsertWithoutPointHistoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPointHistoriesInput, UserUpdateWithoutPointHistoriesInput>, UserUncheckedUpdateWithoutPointHistoriesInput>
  }

  export type MissionClearLogUpdateManyWithoutPointHistoryNestedInput = {
    create?: XOR<MissionClearLogCreateWithoutPointHistoryInput, MissionClearLogUncheckedCreateWithoutPointHistoryInput> | MissionClearLogCreateWithoutPointHistoryInput[] | MissionClearLogUncheckedCreateWithoutPointHistoryInput[]
    connectOrCreate?: MissionClearLogCreateOrConnectWithoutPointHistoryInput | MissionClearLogCreateOrConnectWithoutPointHistoryInput[]
    upsert?: MissionClearLogUpsertWithWhereUniqueWithoutPointHistoryInput | MissionClearLogUpsertWithWhereUniqueWithoutPointHistoryInput[]
    createMany?: MissionClearLogCreateManyPointHistoryInputEnvelope
    set?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    disconnect?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    delete?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    connect?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    update?: MissionClearLogUpdateWithWhereUniqueWithoutPointHistoryInput | MissionClearLogUpdateWithWhereUniqueWithoutPointHistoryInput[]
    updateMany?: MissionClearLogUpdateManyWithWhereWithoutPointHistoryInput | MissionClearLogUpdateManyWithWhereWithoutPointHistoryInput[]
    deleteMany?: MissionClearLogScalarWhereInput | MissionClearLogScalarWhereInput[]
  }

  export type MissionClearLogUncheckedUpdateManyWithoutPointHistoryNestedInput = {
    create?: XOR<MissionClearLogCreateWithoutPointHistoryInput, MissionClearLogUncheckedCreateWithoutPointHistoryInput> | MissionClearLogCreateWithoutPointHistoryInput[] | MissionClearLogUncheckedCreateWithoutPointHistoryInput[]
    connectOrCreate?: MissionClearLogCreateOrConnectWithoutPointHistoryInput | MissionClearLogCreateOrConnectWithoutPointHistoryInput[]
    upsert?: MissionClearLogUpsertWithWhereUniqueWithoutPointHistoryInput | MissionClearLogUpsertWithWhereUniqueWithoutPointHistoryInput[]
    createMany?: MissionClearLogCreateManyPointHistoryInputEnvelope
    set?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    disconnect?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    delete?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    connect?: MissionClearLogWhereUniqueInput | MissionClearLogWhereUniqueInput[]
    update?: MissionClearLogUpdateWithWhereUniqueWithoutPointHistoryInput | MissionClearLogUpdateWithWhereUniqueWithoutPointHistoryInput[]
    updateMany?: MissionClearLogUpdateManyWithWhereWithoutPointHistoryInput | MissionClearLogUpdateManyWithWhereWithoutPointHistoryInput[]
    deleteMany?: MissionClearLogScalarWhereInput | MissionClearLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMissionClearLogsInput = {
    create?: XOR<UserCreateWithoutMissionClearLogsInput, UserUncheckedCreateWithoutMissionClearLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMissionClearLogsInput
    connect?: UserWhereUniqueInput
  }

  export type DinerMissionCreateNestedOneWithoutMissionClearLogsInput = {
    create?: XOR<DinerMissionCreateWithoutMissionClearLogsInput, DinerMissionUncheckedCreateWithoutMissionClearLogsInput>
    connectOrCreate?: DinerMissionCreateOrConnectWithoutMissionClearLogsInput
    connect?: DinerMissionWhereUniqueInput
  }

  export type PointHistoryCreateNestedOneWithoutMissionClearLogsInput = {
    create?: XOR<PointHistoryCreateWithoutMissionClearLogsInput, PointHistoryUncheckedCreateWithoutMissionClearLogsInput>
    connectOrCreate?: PointHistoryCreateOrConnectWithoutMissionClearLogsInput
    connect?: PointHistoryWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMissionClearLogsNestedInput = {
    create?: XOR<UserCreateWithoutMissionClearLogsInput, UserUncheckedCreateWithoutMissionClearLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMissionClearLogsInput
    upsert?: UserUpsertWithoutMissionClearLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMissionClearLogsInput, UserUpdateWithoutMissionClearLogsInput>, UserUncheckedUpdateWithoutMissionClearLogsInput>
  }

  export type DinerMissionUpdateOneRequiredWithoutMissionClearLogsNestedInput = {
    create?: XOR<DinerMissionCreateWithoutMissionClearLogsInput, DinerMissionUncheckedCreateWithoutMissionClearLogsInput>
    connectOrCreate?: DinerMissionCreateOrConnectWithoutMissionClearLogsInput
    upsert?: DinerMissionUpsertWithoutMissionClearLogsInput
    connect?: DinerMissionWhereUniqueInput
    update?: XOR<XOR<DinerMissionUpdateToOneWithWhereWithoutMissionClearLogsInput, DinerMissionUpdateWithoutMissionClearLogsInput>, DinerMissionUncheckedUpdateWithoutMissionClearLogsInput>
  }

  export type PointHistoryUpdateOneWithoutMissionClearLogsNestedInput = {
    create?: XOR<PointHistoryCreateWithoutMissionClearLogsInput, PointHistoryUncheckedCreateWithoutMissionClearLogsInput>
    connectOrCreate?: PointHistoryCreateOrConnectWithoutMissionClearLogsInput
    upsert?: PointHistoryUpsertWithoutMissionClearLogsInput
    disconnect?: PointHistoryWhereInput | boolean
    delete?: PointHistoryWhereInput | boolean
    connect?: PointHistoryWhereUniqueInput
    update?: XOR<XOR<PointHistoryUpdateToOneWithWhereWithoutMissionClearLogsInput, PointHistoryUpdateWithoutMissionClearLogsInput>, PointHistoryUncheckedUpdateWithoutMissionClearLogsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutInquiriesInput = {
    create?: XOR<UserCreateWithoutInquiriesInput, UserUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInquiriesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutInquiriesNestedInput = {
    create?: XOR<UserCreateWithoutInquiriesInput, UserUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInquiriesInput
    upsert?: UserUpsertWithoutInquiriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInquiriesInput, UserUpdateWithoutInquiriesInput>, UserUncheckedUpdateWithoutInquiriesInput>
  }

  export type RegionCreateNestedOneWithoutRegionMissionCountersInput = {
    create?: XOR<RegionCreateWithoutRegionMissionCountersInput, RegionUncheckedCreateWithoutRegionMissionCountersInput>
    connectOrCreate?: RegionCreateOrConnectWithoutRegionMissionCountersInput
    connect?: RegionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRegionMissionCountsInput = {
    create?: XOR<UserCreateWithoutRegionMissionCountsInput, UserUncheckedCreateWithoutRegionMissionCountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRegionMissionCountsInput
    connect?: UserWhereUniqueInput
  }

  export type RegionUpdateOneRequiredWithoutRegionMissionCountersNestedInput = {
    create?: XOR<RegionCreateWithoutRegionMissionCountersInput, RegionUncheckedCreateWithoutRegionMissionCountersInput>
    connectOrCreate?: RegionCreateOrConnectWithoutRegionMissionCountersInput
    upsert?: RegionUpsertWithoutRegionMissionCountersInput
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutRegionMissionCountersInput, RegionUpdateWithoutRegionMissionCountersInput>, RegionUncheckedUpdateWithoutRegionMissionCountersInput>
  }

  export type UserUpdateOneRequiredWithoutRegionMissionCountsNestedInput = {
    create?: XOR<UserCreateWithoutRegionMissionCountsInput, UserUncheckedCreateWithoutRegionMissionCountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRegionMissionCountsInput
    upsert?: UserUpsertWithoutRegionMissionCountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRegionMissionCountsInput, UserUpdateWithoutRegionMissionCountsInput>, UserUncheckedUpdateWithoutRegionMissionCountsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UserFavorCategoryCreateWithoutUserInput = {
    foodCategory: FoodCategoryCreateNestedOneWithoutUserFavorCategoriesInput
  }

  export type UserFavorCategoryUncheckedCreateWithoutUserInput = {
    id?: number
    foodCategoryId: number
  }

  export type UserFavorCategoryCreateOrConnectWithoutUserInput = {
    where: UserFavorCategoryWhereUniqueInput
    create: XOR<UserFavorCategoryCreateWithoutUserInput, UserFavorCategoryUncheckedCreateWithoutUserInput>
  }

  export type UserFavorCategoryCreateManyUserInputEnvelope = {
    data: UserFavorCategoryCreateManyUserInput | UserFavorCategoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    diner: DinerCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: number
    dinerId: number
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PointHistoryCreateWithoutUserInput = {
    historyDate?: Date | string
    description?: string | null
    amount: number
    missionClearLogs?: MissionClearLogCreateNestedManyWithoutPointHistoryInput
  }

  export type PointHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    historyDate?: Date | string
    description?: string | null
    amount: number
    missionClearLogs?: MissionClearLogUncheckedCreateNestedManyWithoutPointHistoryInput
  }

  export type PointHistoryCreateOrConnectWithoutUserInput = {
    where: PointHistoryWhereUniqueInput
    create: XOR<PointHistoryCreateWithoutUserInput, PointHistoryUncheckedCreateWithoutUserInput>
  }

  export type PointHistoryCreateManyUserInputEnvelope = {
    data: PointHistoryCreateManyUserInput | PointHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MissionClearLogCreateWithoutUserInput = {
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    dinerMission: DinerMissionCreateNestedOneWithoutMissionClearLogsInput
    pointHistory?: PointHistoryCreateNestedOneWithoutMissionClearLogsInput
  }

  export type MissionClearLogUncheckedCreateWithoutUserInput = {
    id?: number
    dinerMissionId: number
    pointHistoryId?: number | null
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type MissionClearLogCreateOrConnectWithoutUserInput = {
    where: MissionClearLogWhereUniqueInput
    create: XOR<MissionClearLogCreateWithoutUserInput, MissionClearLogUncheckedCreateWithoutUserInput>
  }

  export type MissionClearLogCreateManyUserInputEnvelope = {
    data: MissionClearLogCreateManyUserInput | MissionClearLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InquiryCreateWithoutUserInput = {
    title: string
    content?: string | null
    createdAt?: Date | string
  }

  export type InquiryUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    content?: string | null
    createdAt?: Date | string
  }

  export type InquiryCreateOrConnectWithoutUserInput = {
    where: InquiryWhereUniqueInput
    create: XOR<InquiryCreateWithoutUserInput, InquiryUncheckedCreateWithoutUserInput>
  }

  export type InquiryCreateManyUserInputEnvelope = {
    data: InquiryCreateManyUserInput | InquiryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RegionMissionCounterCreateWithoutUserInput = {
    missionCount?: number
    region: RegionCreateNestedOneWithoutRegionMissionCountersInput
  }

  export type RegionMissionCounterUncheckedCreateWithoutUserInput = {
    id?: number
    regionId: number
    missionCount?: number
  }

  export type RegionMissionCounterCreateOrConnectWithoutUserInput = {
    where: RegionMissionCounterWhereUniqueInput
    create: XOR<RegionMissionCounterCreateWithoutUserInput, RegionMissionCounterUncheckedCreateWithoutUserInput>
  }

  export type RegionMissionCounterCreateManyUserInputEnvelope = {
    data: RegionMissionCounterCreateManyUserInput | RegionMissionCounterCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserFavorCategoryUpsertWithWhereUniqueWithoutUserInput = {
    where: UserFavorCategoryWhereUniqueInput
    update: XOR<UserFavorCategoryUpdateWithoutUserInput, UserFavorCategoryUncheckedUpdateWithoutUserInput>
    create: XOR<UserFavorCategoryCreateWithoutUserInput, UserFavorCategoryUncheckedCreateWithoutUserInput>
  }

  export type UserFavorCategoryUpdateWithWhereUniqueWithoutUserInput = {
    where: UserFavorCategoryWhereUniqueInput
    data: XOR<UserFavorCategoryUpdateWithoutUserInput, UserFavorCategoryUncheckedUpdateWithoutUserInput>
  }

  export type UserFavorCategoryUpdateManyWithWhereWithoutUserInput = {
    where: UserFavorCategoryScalarWhereInput
    data: XOR<UserFavorCategoryUpdateManyMutationInput, UserFavorCategoryUncheckedUpdateManyWithoutUserInput>
  }

  export type UserFavorCategoryScalarWhereInput = {
    AND?: UserFavorCategoryScalarWhereInput | UserFavorCategoryScalarWhereInput[]
    OR?: UserFavorCategoryScalarWhereInput[]
    NOT?: UserFavorCategoryScalarWhereInput | UserFavorCategoryScalarWhereInput[]
    id?: IntFilter<"UserFavorCategory"> | number
    userId?: IntFilter<"UserFavorCategory"> | number
    foodCategoryId?: IntFilter<"UserFavorCategory"> | number
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: IntFilter<"Review"> | number
    dinerId?: IntFilter<"Review"> | number
    userId?: IntFilter<"Review"> | number
    rating?: IntFilter<"Review"> | number
    content?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type PointHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: PointHistoryWhereUniqueInput
    update: XOR<PointHistoryUpdateWithoutUserInput, PointHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<PointHistoryCreateWithoutUserInput, PointHistoryUncheckedCreateWithoutUserInput>
  }

  export type PointHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: PointHistoryWhereUniqueInput
    data: XOR<PointHistoryUpdateWithoutUserInput, PointHistoryUncheckedUpdateWithoutUserInput>
  }

  export type PointHistoryUpdateManyWithWhereWithoutUserInput = {
    where: PointHistoryScalarWhereInput
    data: XOR<PointHistoryUpdateManyMutationInput, PointHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type PointHistoryScalarWhereInput = {
    AND?: PointHistoryScalarWhereInput | PointHistoryScalarWhereInput[]
    OR?: PointHistoryScalarWhereInput[]
    NOT?: PointHistoryScalarWhereInput | PointHistoryScalarWhereInput[]
    id?: IntFilter<"PointHistory"> | number
    userId?: IntFilter<"PointHistory"> | number
    historyDate?: DateTimeFilter<"PointHistory"> | Date | string
    description?: StringNullableFilter<"PointHistory"> | string | null
    amount?: IntFilter<"PointHistory"> | number
  }

  export type MissionClearLogUpsertWithWhereUniqueWithoutUserInput = {
    where: MissionClearLogWhereUniqueInput
    update: XOR<MissionClearLogUpdateWithoutUserInput, MissionClearLogUncheckedUpdateWithoutUserInput>
    create: XOR<MissionClearLogCreateWithoutUserInput, MissionClearLogUncheckedCreateWithoutUserInput>
  }

  export type MissionClearLogUpdateWithWhereUniqueWithoutUserInput = {
    where: MissionClearLogWhereUniqueInput
    data: XOR<MissionClearLogUpdateWithoutUserInput, MissionClearLogUncheckedUpdateWithoutUserInput>
  }

  export type MissionClearLogUpdateManyWithWhereWithoutUserInput = {
    where: MissionClearLogScalarWhereInput
    data: XOR<MissionClearLogUpdateManyMutationInput, MissionClearLogUncheckedUpdateManyWithoutUserInput>
  }

  export type MissionClearLogScalarWhereInput = {
    AND?: MissionClearLogScalarWhereInput | MissionClearLogScalarWhereInput[]
    OR?: MissionClearLogScalarWhereInput[]
    NOT?: MissionClearLogScalarWhereInput | MissionClearLogScalarWhereInput[]
    id?: IntFilter<"MissionClearLog"> | number
    userId?: IntFilter<"MissionClearLog"> | number
    dinerMissionId?: IntFilter<"MissionClearLog"> | number
    pointHistoryId?: IntNullableFilter<"MissionClearLog"> | number | null
    status?: StringFilter<"MissionClearLog"> | string
    startedAt?: DateTimeFilter<"MissionClearLog"> | Date | string
    completedAt?: DateTimeNullableFilter<"MissionClearLog"> | Date | string | null
  }

  export type InquiryUpsertWithWhereUniqueWithoutUserInput = {
    where: InquiryWhereUniqueInput
    update: XOR<InquiryUpdateWithoutUserInput, InquiryUncheckedUpdateWithoutUserInput>
    create: XOR<InquiryCreateWithoutUserInput, InquiryUncheckedCreateWithoutUserInput>
  }

  export type InquiryUpdateWithWhereUniqueWithoutUserInput = {
    where: InquiryWhereUniqueInput
    data: XOR<InquiryUpdateWithoutUserInput, InquiryUncheckedUpdateWithoutUserInput>
  }

  export type InquiryUpdateManyWithWhereWithoutUserInput = {
    where: InquiryScalarWhereInput
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyWithoutUserInput>
  }

  export type InquiryScalarWhereInput = {
    AND?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
    OR?: InquiryScalarWhereInput[]
    NOT?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
    id?: IntFilter<"Inquiry"> | number
    userId?: IntFilter<"Inquiry"> | number
    title?: StringFilter<"Inquiry"> | string
    content?: StringNullableFilter<"Inquiry"> | string | null
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
  }

  export type RegionMissionCounterUpsertWithWhereUniqueWithoutUserInput = {
    where: RegionMissionCounterWhereUniqueInput
    update: XOR<RegionMissionCounterUpdateWithoutUserInput, RegionMissionCounterUncheckedUpdateWithoutUserInput>
    create: XOR<RegionMissionCounterCreateWithoutUserInput, RegionMissionCounterUncheckedCreateWithoutUserInput>
  }

  export type RegionMissionCounterUpdateWithWhereUniqueWithoutUserInput = {
    where: RegionMissionCounterWhereUniqueInput
    data: XOR<RegionMissionCounterUpdateWithoutUserInput, RegionMissionCounterUncheckedUpdateWithoutUserInput>
  }

  export type RegionMissionCounterUpdateManyWithWhereWithoutUserInput = {
    where: RegionMissionCounterScalarWhereInput
    data: XOR<RegionMissionCounterUpdateManyMutationInput, RegionMissionCounterUncheckedUpdateManyWithoutUserInput>
  }

  export type RegionMissionCounterScalarWhereInput = {
    AND?: RegionMissionCounterScalarWhereInput | RegionMissionCounterScalarWhereInput[]
    OR?: RegionMissionCounterScalarWhereInput[]
    NOT?: RegionMissionCounterScalarWhereInput | RegionMissionCounterScalarWhereInput[]
    id?: IntFilter<"RegionMissionCounter"> | number
    regionId?: IntFilter<"RegionMissionCounter"> | number
    userId?: IntFilter<"RegionMissionCounter"> | number
    missionCount?: IntFilter<"RegionMissionCounter"> | number
  }

  export type DinerCreateWithoutCategoryInput = {
    name: string
    phoneNumber?: string | null
    address?: string | null
    rating?: number | null
    region: RegionCreateNestedOneWithoutDinersInput
    dinerMissions?: DinerMissionCreateNestedManyWithoutDinerInput
    reviews?: ReviewCreateNestedManyWithoutDinerInput
  }

  export type DinerUncheckedCreateWithoutCategoryInput = {
    id?: number
    regionId: number
    name: string
    phoneNumber?: string | null
    address?: string | null
    rating?: number | null
    dinerMissions?: DinerMissionUncheckedCreateNestedManyWithoutDinerInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutDinerInput
  }

  export type DinerCreateOrConnectWithoutCategoryInput = {
    where: DinerWhereUniqueInput
    create: XOR<DinerCreateWithoutCategoryInput, DinerUncheckedCreateWithoutCategoryInput>
  }

  export type DinerCreateManyCategoryInputEnvelope = {
    data: DinerCreateManyCategoryInput | DinerCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type UserFavorCategoryCreateWithoutFoodCategoryInput = {
    user: UserCreateNestedOneWithoutUserFavorCategoriesInput
  }

  export type UserFavorCategoryUncheckedCreateWithoutFoodCategoryInput = {
    id?: number
    userId: number
  }

  export type UserFavorCategoryCreateOrConnectWithoutFoodCategoryInput = {
    where: UserFavorCategoryWhereUniqueInput
    create: XOR<UserFavorCategoryCreateWithoutFoodCategoryInput, UserFavorCategoryUncheckedCreateWithoutFoodCategoryInput>
  }

  export type UserFavorCategoryCreateManyFoodCategoryInputEnvelope = {
    data: UserFavorCategoryCreateManyFoodCategoryInput | UserFavorCategoryCreateManyFoodCategoryInput[]
    skipDuplicates?: boolean
  }

  export type DinerUpsertWithWhereUniqueWithoutCategoryInput = {
    where: DinerWhereUniqueInput
    update: XOR<DinerUpdateWithoutCategoryInput, DinerUncheckedUpdateWithoutCategoryInput>
    create: XOR<DinerCreateWithoutCategoryInput, DinerUncheckedCreateWithoutCategoryInput>
  }

  export type DinerUpdateWithWhereUniqueWithoutCategoryInput = {
    where: DinerWhereUniqueInput
    data: XOR<DinerUpdateWithoutCategoryInput, DinerUncheckedUpdateWithoutCategoryInput>
  }

  export type DinerUpdateManyWithWhereWithoutCategoryInput = {
    where: DinerScalarWhereInput
    data: XOR<DinerUpdateManyMutationInput, DinerUncheckedUpdateManyWithoutCategoryInput>
  }

  export type DinerScalarWhereInput = {
    AND?: DinerScalarWhereInput | DinerScalarWhereInput[]
    OR?: DinerScalarWhereInput[]
    NOT?: DinerScalarWhereInput | DinerScalarWhereInput[]
    id?: IntFilter<"Diner"> | number
    regionId?: IntFilter<"Diner"> | number
    categoryId?: IntFilter<"Diner"> | number
    name?: StringFilter<"Diner"> | string
    phoneNumber?: StringNullableFilter<"Diner"> | string | null
    address?: StringNullableFilter<"Diner"> | string | null
    rating?: FloatNullableFilter<"Diner"> | number | null
  }

  export type UserFavorCategoryUpsertWithWhereUniqueWithoutFoodCategoryInput = {
    where: UserFavorCategoryWhereUniqueInput
    update: XOR<UserFavorCategoryUpdateWithoutFoodCategoryInput, UserFavorCategoryUncheckedUpdateWithoutFoodCategoryInput>
    create: XOR<UserFavorCategoryCreateWithoutFoodCategoryInput, UserFavorCategoryUncheckedCreateWithoutFoodCategoryInput>
  }

  export type UserFavorCategoryUpdateWithWhereUniqueWithoutFoodCategoryInput = {
    where: UserFavorCategoryWhereUniqueInput
    data: XOR<UserFavorCategoryUpdateWithoutFoodCategoryInput, UserFavorCategoryUncheckedUpdateWithoutFoodCategoryInput>
  }

  export type UserFavorCategoryUpdateManyWithWhereWithoutFoodCategoryInput = {
    where: UserFavorCategoryScalarWhereInput
    data: XOR<UserFavorCategoryUpdateManyMutationInput, UserFavorCategoryUncheckedUpdateManyWithoutFoodCategoryInput>
  }

  export type UserCreateWithoutUserFavorCategoriesInput = {
    email: string
    name: string
    role?: $Enums.UserRole
    gender: string
    birth: Date | string
    address: string
    detailAddress?: string | null
    phoneNumber: string
    reviews?: ReviewCreateNestedManyWithoutUserInput
    pointHistories?: PointHistoryCreateNestedManyWithoutUserInput
    missionClearLogs?: MissionClearLogCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    regionMissionCounts?: RegionMissionCounterCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserFavorCategoriesInput = {
    id?: number
    email: string
    name: string
    role?: $Enums.UserRole
    gender: string
    birth: Date | string
    address: string
    detailAddress?: string | null
    phoneNumber: string
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    pointHistories?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    missionClearLogs?: MissionClearLogUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    regionMissionCounts?: RegionMissionCounterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserFavorCategoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserFavorCategoriesInput, UserUncheckedCreateWithoutUserFavorCategoriesInput>
  }

  export type FoodCategoryCreateWithoutUserFavorCategoriesInput = {
    name: string
    diners?: DinerCreateNestedManyWithoutCategoryInput
  }

  export type FoodCategoryUncheckedCreateWithoutUserFavorCategoriesInput = {
    id?: number
    name: string
    diners?: DinerUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type FoodCategoryCreateOrConnectWithoutUserFavorCategoriesInput = {
    where: FoodCategoryWhereUniqueInput
    create: XOR<FoodCategoryCreateWithoutUserFavorCategoriesInput, FoodCategoryUncheckedCreateWithoutUserFavorCategoriesInput>
  }

  export type UserUpsertWithoutUserFavorCategoriesInput = {
    update: XOR<UserUpdateWithoutUserFavorCategoriesInput, UserUncheckedUpdateWithoutUserFavorCategoriesInput>
    create: XOR<UserCreateWithoutUserFavorCategoriesInput, UserUncheckedCreateWithoutUserFavorCategoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserFavorCategoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserFavorCategoriesInput, UserUncheckedUpdateWithoutUserFavorCategoriesInput>
  }

  export type UserUpdateWithoutUserFavorCategoriesInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: StringFieldUpdateOperationsInput | string
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    pointHistories?: PointHistoryUpdateManyWithoutUserNestedInput
    missionClearLogs?: MissionClearLogUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    regionMissionCounts?: RegionMissionCounterUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserFavorCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: StringFieldUpdateOperationsInput | string
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    pointHistories?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    missionClearLogs?: MissionClearLogUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    regionMissionCounts?: RegionMissionCounterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FoodCategoryUpsertWithoutUserFavorCategoriesInput = {
    update: XOR<FoodCategoryUpdateWithoutUserFavorCategoriesInput, FoodCategoryUncheckedUpdateWithoutUserFavorCategoriesInput>
    create: XOR<FoodCategoryCreateWithoutUserFavorCategoriesInput, FoodCategoryUncheckedCreateWithoutUserFavorCategoriesInput>
    where?: FoodCategoryWhereInput
  }

  export type FoodCategoryUpdateToOneWithWhereWithoutUserFavorCategoriesInput = {
    where?: FoodCategoryWhereInput
    data: XOR<FoodCategoryUpdateWithoutUserFavorCategoriesInput, FoodCategoryUncheckedUpdateWithoutUserFavorCategoriesInput>
  }

  export type FoodCategoryUpdateWithoutUserFavorCategoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    diners?: DinerUpdateManyWithoutCategoryNestedInput
  }

  export type FoodCategoryUncheckedUpdateWithoutUserFavorCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    diners?: DinerUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type DinerCreateWithoutRegionInput = {
    name: string
    phoneNumber?: string | null
    address?: string | null
    rating?: number | null
    category: FoodCategoryCreateNestedOneWithoutDinersInput
    dinerMissions?: DinerMissionCreateNestedManyWithoutDinerInput
    reviews?: ReviewCreateNestedManyWithoutDinerInput
  }

  export type DinerUncheckedCreateWithoutRegionInput = {
    id?: number
    categoryId: number
    name: string
    phoneNumber?: string | null
    address?: string | null
    rating?: number | null
    dinerMissions?: DinerMissionUncheckedCreateNestedManyWithoutDinerInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutDinerInput
  }

  export type DinerCreateOrConnectWithoutRegionInput = {
    where: DinerWhereUniqueInput
    create: XOR<DinerCreateWithoutRegionInput, DinerUncheckedCreateWithoutRegionInput>
  }

  export type DinerCreateManyRegionInputEnvelope = {
    data: DinerCreateManyRegionInput | DinerCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type RegionMissionCounterCreateWithoutRegionInput = {
    missionCount?: number
    user: UserCreateNestedOneWithoutRegionMissionCountsInput
  }

  export type RegionMissionCounterUncheckedCreateWithoutRegionInput = {
    id?: number
    userId: number
    missionCount?: number
  }

  export type RegionMissionCounterCreateOrConnectWithoutRegionInput = {
    where: RegionMissionCounterWhereUniqueInput
    create: XOR<RegionMissionCounterCreateWithoutRegionInput, RegionMissionCounterUncheckedCreateWithoutRegionInput>
  }

  export type RegionMissionCounterCreateManyRegionInputEnvelope = {
    data: RegionMissionCounterCreateManyRegionInput | RegionMissionCounterCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type DinerUpsertWithWhereUniqueWithoutRegionInput = {
    where: DinerWhereUniqueInput
    update: XOR<DinerUpdateWithoutRegionInput, DinerUncheckedUpdateWithoutRegionInput>
    create: XOR<DinerCreateWithoutRegionInput, DinerUncheckedCreateWithoutRegionInput>
  }

  export type DinerUpdateWithWhereUniqueWithoutRegionInput = {
    where: DinerWhereUniqueInput
    data: XOR<DinerUpdateWithoutRegionInput, DinerUncheckedUpdateWithoutRegionInput>
  }

  export type DinerUpdateManyWithWhereWithoutRegionInput = {
    where: DinerScalarWhereInput
    data: XOR<DinerUpdateManyMutationInput, DinerUncheckedUpdateManyWithoutRegionInput>
  }

  export type RegionMissionCounterUpsertWithWhereUniqueWithoutRegionInput = {
    where: RegionMissionCounterWhereUniqueInput
    update: XOR<RegionMissionCounterUpdateWithoutRegionInput, RegionMissionCounterUncheckedUpdateWithoutRegionInput>
    create: XOR<RegionMissionCounterCreateWithoutRegionInput, RegionMissionCounterUncheckedCreateWithoutRegionInput>
  }

  export type RegionMissionCounterUpdateWithWhereUniqueWithoutRegionInput = {
    where: RegionMissionCounterWhereUniqueInput
    data: XOR<RegionMissionCounterUpdateWithoutRegionInput, RegionMissionCounterUncheckedUpdateWithoutRegionInput>
  }

  export type RegionMissionCounterUpdateManyWithWhereWithoutRegionInput = {
    where: RegionMissionCounterScalarWhereInput
    data: XOR<RegionMissionCounterUpdateManyMutationInput, RegionMissionCounterUncheckedUpdateManyWithoutRegionInput>
  }

  export type RegionCreateWithoutDinersInput = {
    name: string
    regionMissionCounters?: RegionMissionCounterCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutDinersInput = {
    id?: number
    name: string
    regionMissionCounters?: RegionMissionCounterUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutDinersInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutDinersInput, RegionUncheckedCreateWithoutDinersInput>
  }

  export type FoodCategoryCreateWithoutDinersInput = {
    name: string
    userFavorCategories?: UserFavorCategoryCreateNestedManyWithoutFoodCategoryInput
  }

  export type FoodCategoryUncheckedCreateWithoutDinersInput = {
    id?: number
    name: string
    userFavorCategories?: UserFavorCategoryUncheckedCreateNestedManyWithoutFoodCategoryInput
  }

  export type FoodCategoryCreateOrConnectWithoutDinersInput = {
    where: FoodCategoryWhereUniqueInput
    create: XOR<FoodCategoryCreateWithoutDinersInput, FoodCategoryUncheckedCreateWithoutDinersInput>
  }

  export type DinerMissionCreateWithoutDinerInput = {
    startDate: Date | string
    endDate?: Date | string | null
    mission: MissionCreateNestedOneWithoutDinerMissionsInput
    missionClearLogs?: MissionClearLogCreateNestedManyWithoutDinerMissionInput
  }

  export type DinerMissionUncheckedCreateWithoutDinerInput = {
    id?: number
    missionId: number
    startDate: Date | string
    endDate?: Date | string | null
    missionClearLogs?: MissionClearLogUncheckedCreateNestedManyWithoutDinerMissionInput
  }

  export type DinerMissionCreateOrConnectWithoutDinerInput = {
    where: DinerMissionWhereUniqueInput
    create: XOR<DinerMissionCreateWithoutDinerInput, DinerMissionUncheckedCreateWithoutDinerInput>
  }

  export type DinerMissionCreateManyDinerInputEnvelope = {
    data: DinerMissionCreateManyDinerInput | DinerMissionCreateManyDinerInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutDinerInput = {
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutDinerInput = {
    id?: number
    userId: number
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutDinerInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutDinerInput, ReviewUncheckedCreateWithoutDinerInput>
  }

  export type ReviewCreateManyDinerInputEnvelope = {
    data: ReviewCreateManyDinerInput | ReviewCreateManyDinerInput[]
    skipDuplicates?: boolean
  }

  export type RegionUpsertWithoutDinersInput = {
    update: XOR<RegionUpdateWithoutDinersInput, RegionUncheckedUpdateWithoutDinersInput>
    create: XOR<RegionCreateWithoutDinersInput, RegionUncheckedCreateWithoutDinersInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutDinersInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutDinersInput, RegionUncheckedUpdateWithoutDinersInput>
  }

  export type RegionUpdateWithoutDinersInput = {
    name?: StringFieldUpdateOperationsInput | string
    regionMissionCounters?: RegionMissionCounterUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutDinersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    regionMissionCounters?: RegionMissionCounterUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type FoodCategoryUpsertWithoutDinersInput = {
    update: XOR<FoodCategoryUpdateWithoutDinersInput, FoodCategoryUncheckedUpdateWithoutDinersInput>
    create: XOR<FoodCategoryCreateWithoutDinersInput, FoodCategoryUncheckedCreateWithoutDinersInput>
    where?: FoodCategoryWhereInput
  }

  export type FoodCategoryUpdateToOneWithWhereWithoutDinersInput = {
    where?: FoodCategoryWhereInput
    data: XOR<FoodCategoryUpdateWithoutDinersInput, FoodCategoryUncheckedUpdateWithoutDinersInput>
  }

  export type FoodCategoryUpdateWithoutDinersInput = {
    name?: StringFieldUpdateOperationsInput | string
    userFavorCategories?: UserFavorCategoryUpdateManyWithoutFoodCategoryNestedInput
  }

  export type FoodCategoryUncheckedUpdateWithoutDinersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    userFavorCategories?: UserFavorCategoryUncheckedUpdateManyWithoutFoodCategoryNestedInput
  }

  export type DinerMissionUpsertWithWhereUniqueWithoutDinerInput = {
    where: DinerMissionWhereUniqueInput
    update: XOR<DinerMissionUpdateWithoutDinerInput, DinerMissionUncheckedUpdateWithoutDinerInput>
    create: XOR<DinerMissionCreateWithoutDinerInput, DinerMissionUncheckedCreateWithoutDinerInput>
  }

  export type DinerMissionUpdateWithWhereUniqueWithoutDinerInput = {
    where: DinerMissionWhereUniqueInput
    data: XOR<DinerMissionUpdateWithoutDinerInput, DinerMissionUncheckedUpdateWithoutDinerInput>
  }

  export type DinerMissionUpdateManyWithWhereWithoutDinerInput = {
    where: DinerMissionScalarWhereInput
    data: XOR<DinerMissionUpdateManyMutationInput, DinerMissionUncheckedUpdateManyWithoutDinerInput>
  }

  export type DinerMissionScalarWhereInput = {
    AND?: DinerMissionScalarWhereInput | DinerMissionScalarWhereInput[]
    OR?: DinerMissionScalarWhereInput[]
    NOT?: DinerMissionScalarWhereInput | DinerMissionScalarWhereInput[]
    id?: IntFilter<"DinerMission"> | number
    dinerId?: IntFilter<"DinerMission"> | number
    missionId?: IntFilter<"DinerMission"> | number
    startDate?: DateTimeFilter<"DinerMission"> | Date | string
    endDate?: DateTimeNullableFilter<"DinerMission"> | Date | string | null
  }

  export type ReviewUpsertWithWhereUniqueWithoutDinerInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutDinerInput, ReviewUncheckedUpdateWithoutDinerInput>
    create: XOR<ReviewCreateWithoutDinerInput, ReviewUncheckedCreateWithoutDinerInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutDinerInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutDinerInput, ReviewUncheckedUpdateWithoutDinerInput>
  }

  export type ReviewUpdateManyWithWhereWithoutDinerInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutDinerInput>
  }

  export type DinerMissionCreateWithoutMissionInput = {
    startDate: Date | string
    endDate?: Date | string | null
    diner: DinerCreateNestedOneWithoutDinerMissionsInput
    missionClearLogs?: MissionClearLogCreateNestedManyWithoutDinerMissionInput
  }

  export type DinerMissionUncheckedCreateWithoutMissionInput = {
    id?: number
    dinerId: number
    startDate: Date | string
    endDate?: Date | string | null
    missionClearLogs?: MissionClearLogUncheckedCreateNestedManyWithoutDinerMissionInput
  }

  export type DinerMissionCreateOrConnectWithoutMissionInput = {
    where: DinerMissionWhereUniqueInput
    create: XOR<DinerMissionCreateWithoutMissionInput, DinerMissionUncheckedCreateWithoutMissionInput>
  }

  export type DinerMissionCreateManyMissionInputEnvelope = {
    data: DinerMissionCreateManyMissionInput | DinerMissionCreateManyMissionInput[]
    skipDuplicates?: boolean
  }

  export type DinerMissionUpsertWithWhereUniqueWithoutMissionInput = {
    where: DinerMissionWhereUniqueInput
    update: XOR<DinerMissionUpdateWithoutMissionInput, DinerMissionUncheckedUpdateWithoutMissionInput>
    create: XOR<DinerMissionCreateWithoutMissionInput, DinerMissionUncheckedCreateWithoutMissionInput>
  }

  export type DinerMissionUpdateWithWhereUniqueWithoutMissionInput = {
    where: DinerMissionWhereUniqueInput
    data: XOR<DinerMissionUpdateWithoutMissionInput, DinerMissionUncheckedUpdateWithoutMissionInput>
  }

  export type DinerMissionUpdateManyWithWhereWithoutMissionInput = {
    where: DinerMissionScalarWhereInput
    data: XOR<DinerMissionUpdateManyMutationInput, DinerMissionUncheckedUpdateManyWithoutMissionInput>
  }

  export type DinerCreateWithoutDinerMissionsInput = {
    name: string
    phoneNumber?: string | null
    address?: string | null
    rating?: number | null
    region: RegionCreateNestedOneWithoutDinersInput
    category: FoodCategoryCreateNestedOneWithoutDinersInput
    reviews?: ReviewCreateNestedManyWithoutDinerInput
  }

  export type DinerUncheckedCreateWithoutDinerMissionsInput = {
    id?: number
    regionId: number
    categoryId: number
    name: string
    phoneNumber?: string | null
    address?: string | null
    rating?: number | null
    reviews?: ReviewUncheckedCreateNestedManyWithoutDinerInput
  }

  export type DinerCreateOrConnectWithoutDinerMissionsInput = {
    where: DinerWhereUniqueInput
    create: XOR<DinerCreateWithoutDinerMissionsInput, DinerUncheckedCreateWithoutDinerMissionsInput>
  }

  export type MissionCreateWithoutDinerMissionsInput = {
    title: string
    description?: string | null
    pointReward?: number
  }

  export type MissionUncheckedCreateWithoutDinerMissionsInput = {
    id?: number
    title: string
    description?: string | null
    pointReward?: number
  }

  export type MissionCreateOrConnectWithoutDinerMissionsInput = {
    where: MissionWhereUniqueInput
    create: XOR<MissionCreateWithoutDinerMissionsInput, MissionUncheckedCreateWithoutDinerMissionsInput>
  }

  export type MissionClearLogCreateWithoutDinerMissionInput = {
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutMissionClearLogsInput
    pointHistory?: PointHistoryCreateNestedOneWithoutMissionClearLogsInput
  }

  export type MissionClearLogUncheckedCreateWithoutDinerMissionInput = {
    id?: number
    userId: number
    pointHistoryId?: number | null
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type MissionClearLogCreateOrConnectWithoutDinerMissionInput = {
    where: MissionClearLogWhereUniqueInput
    create: XOR<MissionClearLogCreateWithoutDinerMissionInput, MissionClearLogUncheckedCreateWithoutDinerMissionInput>
  }

  export type MissionClearLogCreateManyDinerMissionInputEnvelope = {
    data: MissionClearLogCreateManyDinerMissionInput | MissionClearLogCreateManyDinerMissionInput[]
    skipDuplicates?: boolean
  }

  export type DinerUpsertWithoutDinerMissionsInput = {
    update: XOR<DinerUpdateWithoutDinerMissionsInput, DinerUncheckedUpdateWithoutDinerMissionsInput>
    create: XOR<DinerCreateWithoutDinerMissionsInput, DinerUncheckedCreateWithoutDinerMissionsInput>
    where?: DinerWhereInput
  }

  export type DinerUpdateToOneWithWhereWithoutDinerMissionsInput = {
    where?: DinerWhereInput
    data: XOR<DinerUpdateWithoutDinerMissionsInput, DinerUncheckedUpdateWithoutDinerMissionsInput>
  }

  export type DinerUpdateWithoutDinerMissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    region?: RegionUpdateOneRequiredWithoutDinersNestedInput
    category?: FoodCategoryUpdateOneRequiredWithoutDinersNestedInput
    reviews?: ReviewUpdateManyWithoutDinerNestedInput
  }

  export type DinerUncheckedUpdateWithoutDinerMissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviews?: ReviewUncheckedUpdateManyWithoutDinerNestedInput
  }

  export type MissionUpsertWithoutDinerMissionsInput = {
    update: XOR<MissionUpdateWithoutDinerMissionsInput, MissionUncheckedUpdateWithoutDinerMissionsInput>
    create: XOR<MissionCreateWithoutDinerMissionsInput, MissionUncheckedCreateWithoutDinerMissionsInput>
    where?: MissionWhereInput
  }

  export type MissionUpdateToOneWithWhereWithoutDinerMissionsInput = {
    where?: MissionWhereInput
    data: XOR<MissionUpdateWithoutDinerMissionsInput, MissionUncheckedUpdateWithoutDinerMissionsInput>
  }

  export type MissionUpdateWithoutDinerMissionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointReward?: IntFieldUpdateOperationsInput | number
  }

  export type MissionUncheckedUpdateWithoutDinerMissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pointReward?: IntFieldUpdateOperationsInput | number
  }

  export type MissionClearLogUpsertWithWhereUniqueWithoutDinerMissionInput = {
    where: MissionClearLogWhereUniqueInput
    update: XOR<MissionClearLogUpdateWithoutDinerMissionInput, MissionClearLogUncheckedUpdateWithoutDinerMissionInput>
    create: XOR<MissionClearLogCreateWithoutDinerMissionInput, MissionClearLogUncheckedCreateWithoutDinerMissionInput>
  }

  export type MissionClearLogUpdateWithWhereUniqueWithoutDinerMissionInput = {
    where: MissionClearLogWhereUniqueInput
    data: XOR<MissionClearLogUpdateWithoutDinerMissionInput, MissionClearLogUncheckedUpdateWithoutDinerMissionInput>
  }

  export type MissionClearLogUpdateManyWithWhereWithoutDinerMissionInput = {
    where: MissionClearLogScalarWhereInput
    data: XOR<MissionClearLogUpdateManyMutationInput, MissionClearLogUncheckedUpdateManyWithoutDinerMissionInput>
  }

  export type DinerCreateWithoutReviewsInput = {
    name: string
    phoneNumber?: string | null
    address?: string | null
    rating?: number | null
    region: RegionCreateNestedOneWithoutDinersInput
    category: FoodCategoryCreateNestedOneWithoutDinersInput
    dinerMissions?: DinerMissionCreateNestedManyWithoutDinerInput
  }

  export type DinerUncheckedCreateWithoutReviewsInput = {
    id?: number
    regionId: number
    categoryId: number
    name: string
    phoneNumber?: string | null
    address?: string | null
    rating?: number | null
    dinerMissions?: DinerMissionUncheckedCreateNestedManyWithoutDinerInput
  }

  export type DinerCreateOrConnectWithoutReviewsInput = {
    where: DinerWhereUniqueInput
    create: XOR<DinerCreateWithoutReviewsInput, DinerUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutReviewsInput = {
    email: string
    name: string
    role?: $Enums.UserRole
    gender: string
    birth: Date | string
    address: string
    detailAddress?: string | null
    phoneNumber: string
    userFavorCategories?: UserFavorCategoryCreateNestedManyWithoutUserInput
    pointHistories?: PointHistoryCreateNestedManyWithoutUserInput
    missionClearLogs?: MissionClearLogCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    regionMissionCounts?: RegionMissionCounterCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: number
    email: string
    name: string
    role?: $Enums.UserRole
    gender: string
    birth: Date | string
    address: string
    detailAddress?: string | null
    phoneNumber: string
    userFavorCategories?: UserFavorCategoryUncheckedCreateNestedManyWithoutUserInput
    pointHistories?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    missionClearLogs?: MissionClearLogUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    regionMissionCounts?: RegionMissionCounterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type DinerUpsertWithoutReviewsInput = {
    update: XOR<DinerUpdateWithoutReviewsInput, DinerUncheckedUpdateWithoutReviewsInput>
    create: XOR<DinerCreateWithoutReviewsInput, DinerUncheckedCreateWithoutReviewsInput>
    where?: DinerWhereInput
  }

  export type DinerUpdateToOneWithWhereWithoutReviewsInput = {
    where?: DinerWhereInput
    data: XOR<DinerUpdateWithoutReviewsInput, DinerUncheckedUpdateWithoutReviewsInput>
  }

  export type DinerUpdateWithoutReviewsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    region?: RegionUpdateOneRequiredWithoutDinersNestedInput
    category?: FoodCategoryUpdateOneRequiredWithoutDinersNestedInput
    dinerMissions?: DinerMissionUpdateManyWithoutDinerNestedInput
  }

  export type DinerUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    dinerMissions?: DinerMissionUncheckedUpdateManyWithoutDinerNestedInput
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: StringFieldUpdateOperationsInput | string
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    userFavorCategories?: UserFavorCategoryUpdateManyWithoutUserNestedInput
    pointHistories?: PointHistoryUpdateManyWithoutUserNestedInput
    missionClearLogs?: MissionClearLogUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    regionMissionCounts?: RegionMissionCounterUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: StringFieldUpdateOperationsInput | string
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    userFavorCategories?: UserFavorCategoryUncheckedUpdateManyWithoutUserNestedInput
    pointHistories?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    missionClearLogs?: MissionClearLogUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    regionMissionCounts?: RegionMissionCounterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPointHistoriesInput = {
    email: string
    name: string
    role?: $Enums.UserRole
    gender: string
    birth: Date | string
    address: string
    detailAddress?: string | null
    phoneNumber: string
    userFavorCategories?: UserFavorCategoryCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    missionClearLogs?: MissionClearLogCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    regionMissionCounts?: RegionMissionCounterCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPointHistoriesInput = {
    id?: number
    email: string
    name: string
    role?: $Enums.UserRole
    gender: string
    birth: Date | string
    address: string
    detailAddress?: string | null
    phoneNumber: string
    userFavorCategories?: UserFavorCategoryUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    missionClearLogs?: MissionClearLogUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    regionMissionCounts?: RegionMissionCounterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPointHistoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPointHistoriesInput, UserUncheckedCreateWithoutPointHistoriesInput>
  }

  export type MissionClearLogCreateWithoutPointHistoryInput = {
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutMissionClearLogsInput
    dinerMission: DinerMissionCreateNestedOneWithoutMissionClearLogsInput
  }

  export type MissionClearLogUncheckedCreateWithoutPointHistoryInput = {
    id?: number
    userId: number
    dinerMissionId: number
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type MissionClearLogCreateOrConnectWithoutPointHistoryInput = {
    where: MissionClearLogWhereUniqueInput
    create: XOR<MissionClearLogCreateWithoutPointHistoryInput, MissionClearLogUncheckedCreateWithoutPointHistoryInput>
  }

  export type MissionClearLogCreateManyPointHistoryInputEnvelope = {
    data: MissionClearLogCreateManyPointHistoryInput | MissionClearLogCreateManyPointHistoryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPointHistoriesInput = {
    update: XOR<UserUpdateWithoutPointHistoriesInput, UserUncheckedUpdateWithoutPointHistoriesInput>
    create: XOR<UserCreateWithoutPointHistoriesInput, UserUncheckedCreateWithoutPointHistoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPointHistoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPointHistoriesInput, UserUncheckedUpdateWithoutPointHistoriesInput>
  }

  export type UserUpdateWithoutPointHistoriesInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: StringFieldUpdateOperationsInput | string
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    userFavorCategories?: UserFavorCategoryUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    missionClearLogs?: MissionClearLogUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    regionMissionCounts?: RegionMissionCounterUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPointHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: StringFieldUpdateOperationsInput | string
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    userFavorCategories?: UserFavorCategoryUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    missionClearLogs?: MissionClearLogUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    regionMissionCounts?: RegionMissionCounterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MissionClearLogUpsertWithWhereUniqueWithoutPointHistoryInput = {
    where: MissionClearLogWhereUniqueInput
    update: XOR<MissionClearLogUpdateWithoutPointHistoryInput, MissionClearLogUncheckedUpdateWithoutPointHistoryInput>
    create: XOR<MissionClearLogCreateWithoutPointHistoryInput, MissionClearLogUncheckedCreateWithoutPointHistoryInput>
  }

  export type MissionClearLogUpdateWithWhereUniqueWithoutPointHistoryInput = {
    where: MissionClearLogWhereUniqueInput
    data: XOR<MissionClearLogUpdateWithoutPointHistoryInput, MissionClearLogUncheckedUpdateWithoutPointHistoryInput>
  }

  export type MissionClearLogUpdateManyWithWhereWithoutPointHistoryInput = {
    where: MissionClearLogScalarWhereInput
    data: XOR<MissionClearLogUpdateManyMutationInput, MissionClearLogUncheckedUpdateManyWithoutPointHistoryInput>
  }

  export type UserCreateWithoutMissionClearLogsInput = {
    email: string
    name: string
    role?: $Enums.UserRole
    gender: string
    birth: Date | string
    address: string
    detailAddress?: string | null
    phoneNumber: string
    userFavorCategories?: UserFavorCategoryCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    pointHistories?: PointHistoryCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
    regionMissionCounts?: RegionMissionCounterCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMissionClearLogsInput = {
    id?: number
    email: string
    name: string
    role?: $Enums.UserRole
    gender: string
    birth: Date | string
    address: string
    detailAddress?: string | null
    phoneNumber: string
    userFavorCategories?: UserFavorCategoryUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    pointHistories?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
    regionMissionCounts?: RegionMissionCounterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMissionClearLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMissionClearLogsInput, UserUncheckedCreateWithoutMissionClearLogsInput>
  }

  export type DinerMissionCreateWithoutMissionClearLogsInput = {
    startDate: Date | string
    endDate?: Date | string | null
    diner: DinerCreateNestedOneWithoutDinerMissionsInput
    mission: MissionCreateNestedOneWithoutDinerMissionsInput
  }

  export type DinerMissionUncheckedCreateWithoutMissionClearLogsInput = {
    id?: number
    dinerId: number
    missionId: number
    startDate: Date | string
    endDate?: Date | string | null
  }

  export type DinerMissionCreateOrConnectWithoutMissionClearLogsInput = {
    where: DinerMissionWhereUniqueInput
    create: XOR<DinerMissionCreateWithoutMissionClearLogsInput, DinerMissionUncheckedCreateWithoutMissionClearLogsInput>
  }

  export type PointHistoryCreateWithoutMissionClearLogsInput = {
    historyDate?: Date | string
    description?: string | null
    amount: number
    user: UserCreateNestedOneWithoutPointHistoriesInput
  }

  export type PointHistoryUncheckedCreateWithoutMissionClearLogsInput = {
    id?: number
    userId: number
    historyDate?: Date | string
    description?: string | null
    amount: number
  }

  export type PointHistoryCreateOrConnectWithoutMissionClearLogsInput = {
    where: PointHistoryWhereUniqueInput
    create: XOR<PointHistoryCreateWithoutMissionClearLogsInput, PointHistoryUncheckedCreateWithoutMissionClearLogsInput>
  }

  export type UserUpsertWithoutMissionClearLogsInput = {
    update: XOR<UserUpdateWithoutMissionClearLogsInput, UserUncheckedUpdateWithoutMissionClearLogsInput>
    create: XOR<UserCreateWithoutMissionClearLogsInput, UserUncheckedCreateWithoutMissionClearLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMissionClearLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMissionClearLogsInput, UserUncheckedUpdateWithoutMissionClearLogsInput>
  }

  export type UserUpdateWithoutMissionClearLogsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: StringFieldUpdateOperationsInput | string
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    userFavorCategories?: UserFavorCategoryUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    pointHistories?: PointHistoryUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
    regionMissionCounts?: RegionMissionCounterUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMissionClearLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: StringFieldUpdateOperationsInput | string
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    userFavorCategories?: UserFavorCategoryUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    pointHistories?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
    regionMissionCounts?: RegionMissionCounterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DinerMissionUpsertWithoutMissionClearLogsInput = {
    update: XOR<DinerMissionUpdateWithoutMissionClearLogsInput, DinerMissionUncheckedUpdateWithoutMissionClearLogsInput>
    create: XOR<DinerMissionCreateWithoutMissionClearLogsInput, DinerMissionUncheckedCreateWithoutMissionClearLogsInput>
    where?: DinerMissionWhereInput
  }

  export type DinerMissionUpdateToOneWithWhereWithoutMissionClearLogsInput = {
    where?: DinerMissionWhereInput
    data: XOR<DinerMissionUpdateWithoutMissionClearLogsInput, DinerMissionUncheckedUpdateWithoutMissionClearLogsInput>
  }

  export type DinerMissionUpdateWithoutMissionClearLogsInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diner?: DinerUpdateOneRequiredWithoutDinerMissionsNestedInput
    mission?: MissionUpdateOneRequiredWithoutDinerMissionsNestedInput
  }

  export type DinerMissionUncheckedUpdateWithoutMissionClearLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    dinerId?: IntFieldUpdateOperationsInput | number
    missionId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PointHistoryUpsertWithoutMissionClearLogsInput = {
    update: XOR<PointHistoryUpdateWithoutMissionClearLogsInput, PointHistoryUncheckedUpdateWithoutMissionClearLogsInput>
    create: XOR<PointHistoryCreateWithoutMissionClearLogsInput, PointHistoryUncheckedCreateWithoutMissionClearLogsInput>
    where?: PointHistoryWhereInput
  }

  export type PointHistoryUpdateToOneWithWhereWithoutMissionClearLogsInput = {
    where?: PointHistoryWhereInput
    data: XOR<PointHistoryUpdateWithoutMissionClearLogsInput, PointHistoryUncheckedUpdateWithoutMissionClearLogsInput>
  }

  export type PointHistoryUpdateWithoutMissionClearLogsInput = {
    historyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutPointHistoriesNestedInput
  }

  export type PointHistoryUncheckedUpdateWithoutMissionClearLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    historyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateWithoutInquiriesInput = {
    email: string
    name: string
    role?: $Enums.UserRole
    gender: string
    birth: Date | string
    address: string
    detailAddress?: string | null
    phoneNumber: string
    userFavorCategories?: UserFavorCategoryCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    pointHistories?: PointHistoryCreateNestedManyWithoutUserInput
    missionClearLogs?: MissionClearLogCreateNestedManyWithoutUserInput
    regionMissionCounts?: RegionMissionCounterCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInquiriesInput = {
    id?: number
    email: string
    name: string
    role?: $Enums.UserRole
    gender: string
    birth: Date | string
    address: string
    detailAddress?: string | null
    phoneNumber: string
    userFavorCategories?: UserFavorCategoryUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    pointHistories?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    missionClearLogs?: MissionClearLogUncheckedCreateNestedManyWithoutUserInput
    regionMissionCounts?: RegionMissionCounterUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInquiriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInquiriesInput, UserUncheckedCreateWithoutInquiriesInput>
  }

  export type UserUpsertWithoutInquiriesInput = {
    update: XOR<UserUpdateWithoutInquiriesInput, UserUncheckedUpdateWithoutInquiriesInput>
    create: XOR<UserCreateWithoutInquiriesInput, UserUncheckedCreateWithoutInquiriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInquiriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInquiriesInput, UserUncheckedUpdateWithoutInquiriesInput>
  }

  export type UserUpdateWithoutInquiriesInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: StringFieldUpdateOperationsInput | string
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    userFavorCategories?: UserFavorCategoryUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    pointHistories?: PointHistoryUpdateManyWithoutUserNestedInput
    missionClearLogs?: MissionClearLogUpdateManyWithoutUserNestedInput
    regionMissionCounts?: RegionMissionCounterUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInquiriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: StringFieldUpdateOperationsInput | string
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    userFavorCategories?: UserFavorCategoryUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    pointHistories?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    missionClearLogs?: MissionClearLogUncheckedUpdateManyWithoutUserNestedInput
    regionMissionCounts?: RegionMissionCounterUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RegionCreateWithoutRegionMissionCountersInput = {
    name: string
    diners?: DinerCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutRegionMissionCountersInput = {
    id?: number
    name: string
    diners?: DinerUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutRegionMissionCountersInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutRegionMissionCountersInput, RegionUncheckedCreateWithoutRegionMissionCountersInput>
  }

  export type UserCreateWithoutRegionMissionCountsInput = {
    email: string
    name: string
    role?: $Enums.UserRole
    gender: string
    birth: Date | string
    address: string
    detailAddress?: string | null
    phoneNumber: string
    userFavorCategories?: UserFavorCategoryCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    pointHistories?: PointHistoryCreateNestedManyWithoutUserInput
    missionClearLogs?: MissionClearLogCreateNestedManyWithoutUserInput
    inquiries?: InquiryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRegionMissionCountsInput = {
    id?: number
    email: string
    name: string
    role?: $Enums.UserRole
    gender: string
    birth: Date | string
    address: string
    detailAddress?: string | null
    phoneNumber: string
    userFavorCategories?: UserFavorCategoryUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    pointHistories?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    missionClearLogs?: MissionClearLogUncheckedCreateNestedManyWithoutUserInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRegionMissionCountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRegionMissionCountsInput, UserUncheckedCreateWithoutRegionMissionCountsInput>
  }

  export type RegionUpsertWithoutRegionMissionCountersInput = {
    update: XOR<RegionUpdateWithoutRegionMissionCountersInput, RegionUncheckedUpdateWithoutRegionMissionCountersInput>
    create: XOR<RegionCreateWithoutRegionMissionCountersInput, RegionUncheckedCreateWithoutRegionMissionCountersInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutRegionMissionCountersInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutRegionMissionCountersInput, RegionUncheckedUpdateWithoutRegionMissionCountersInput>
  }

  export type RegionUpdateWithoutRegionMissionCountersInput = {
    name?: StringFieldUpdateOperationsInput | string
    diners?: DinerUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutRegionMissionCountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    diners?: DinerUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type UserUpsertWithoutRegionMissionCountsInput = {
    update: XOR<UserUpdateWithoutRegionMissionCountsInput, UserUncheckedUpdateWithoutRegionMissionCountsInput>
    create: XOR<UserCreateWithoutRegionMissionCountsInput, UserUncheckedCreateWithoutRegionMissionCountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRegionMissionCountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRegionMissionCountsInput, UserUncheckedUpdateWithoutRegionMissionCountsInput>
  }

  export type UserUpdateWithoutRegionMissionCountsInput = {
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: StringFieldUpdateOperationsInput | string
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    userFavorCategories?: UserFavorCategoryUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    pointHistories?: PointHistoryUpdateManyWithoutUserNestedInput
    missionClearLogs?: MissionClearLogUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRegionMissionCountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: StringFieldUpdateOperationsInput | string
    birth?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    userFavorCategories?: UserFavorCategoryUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    pointHistories?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    missionClearLogs?: MissionClearLogUncheckedUpdateManyWithoutUserNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserFavorCategoryCreateManyUserInput = {
    id?: number
    foodCategoryId: number
  }

  export type ReviewCreateManyUserInput = {
    id?: number
    dinerId: number
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PointHistoryCreateManyUserInput = {
    id?: number
    historyDate?: Date | string
    description?: string | null
    amount: number
  }

  export type MissionClearLogCreateManyUserInput = {
    id?: number
    dinerMissionId: number
    pointHistoryId?: number | null
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type InquiryCreateManyUserInput = {
    id?: number
    title: string
    content?: string | null
    createdAt?: Date | string
  }

  export type RegionMissionCounterCreateManyUserInput = {
    id?: number
    regionId: number
    missionCount?: number
  }

  export type UserFavorCategoryUpdateWithoutUserInput = {
    foodCategory?: FoodCategoryUpdateOneRequiredWithoutUserFavorCategoriesNestedInput
  }

  export type UserFavorCategoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    foodCategoryId?: IntFieldUpdateOperationsInput | number
  }

  export type UserFavorCategoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    foodCategoryId?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewUpdateWithoutUserInput = {
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    diner?: DinerUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    dinerId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    dinerId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointHistoryUpdateWithoutUserInput = {
    historyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    missionClearLogs?: MissionClearLogUpdateManyWithoutPointHistoryNestedInput
  }

  export type PointHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    historyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    missionClearLogs?: MissionClearLogUncheckedUpdateManyWithoutPointHistoryNestedInput
  }

  export type PointHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    historyDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type MissionClearLogUpdateWithoutUserInput = {
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dinerMission?: DinerMissionUpdateOneRequiredWithoutMissionClearLogsNestedInput
    pointHistory?: PointHistoryUpdateOneWithoutMissionClearLogsNestedInput
  }

  export type MissionClearLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    dinerMissionId?: IntFieldUpdateOperationsInput | number
    pointHistoryId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MissionClearLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    dinerMissionId?: IntFieldUpdateOperationsInput | number
    pointHistoryId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InquiryUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionMissionCounterUpdateWithoutUserInput = {
    missionCount?: IntFieldUpdateOperationsInput | number
    region?: RegionUpdateOneRequiredWithoutRegionMissionCountersNestedInput
  }

  export type RegionMissionCounterUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    missionCount?: IntFieldUpdateOperationsInput | number
  }

  export type RegionMissionCounterUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    missionCount?: IntFieldUpdateOperationsInput | number
  }

  export type DinerCreateManyCategoryInput = {
    id?: number
    regionId: number
    name: string
    phoneNumber?: string | null
    address?: string | null
    rating?: number | null
  }

  export type UserFavorCategoryCreateManyFoodCategoryInput = {
    id?: number
    userId: number
  }

  export type DinerUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    region?: RegionUpdateOneRequiredWithoutDinersNestedInput
    dinerMissions?: DinerMissionUpdateManyWithoutDinerNestedInput
    reviews?: ReviewUpdateManyWithoutDinerNestedInput
  }

  export type DinerUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    dinerMissions?: DinerMissionUncheckedUpdateManyWithoutDinerNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutDinerNestedInput
  }

  export type DinerUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UserFavorCategoryUpdateWithoutFoodCategoryInput = {
    user?: UserUpdateOneRequiredWithoutUserFavorCategoriesNestedInput
  }

  export type UserFavorCategoryUncheckedUpdateWithoutFoodCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserFavorCategoryUncheckedUpdateManyWithoutFoodCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type DinerCreateManyRegionInput = {
    id?: number
    categoryId: number
    name: string
    phoneNumber?: string | null
    address?: string | null
    rating?: number | null
  }

  export type RegionMissionCounterCreateManyRegionInput = {
    id?: number
    userId: number
    missionCount?: number
  }

  export type DinerUpdateWithoutRegionInput = {
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    category?: FoodCategoryUpdateOneRequiredWithoutDinersNestedInput
    dinerMissions?: DinerMissionUpdateManyWithoutDinerNestedInput
    reviews?: ReviewUpdateManyWithoutDinerNestedInput
  }

  export type DinerUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    dinerMissions?: DinerMissionUncheckedUpdateManyWithoutDinerNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutDinerNestedInput
  }

  export type DinerUncheckedUpdateManyWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RegionMissionCounterUpdateWithoutRegionInput = {
    missionCount?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutRegionMissionCountsNestedInput
  }

  export type RegionMissionCounterUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    missionCount?: IntFieldUpdateOperationsInput | number
  }

  export type RegionMissionCounterUncheckedUpdateManyWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    missionCount?: IntFieldUpdateOperationsInput | number
  }

  export type DinerMissionCreateManyDinerInput = {
    id?: number
    missionId: number
    startDate: Date | string
    endDate?: Date | string | null
  }

  export type ReviewCreateManyDinerInput = {
    id?: number
    userId: number
    rating: number
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DinerMissionUpdateWithoutDinerInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mission?: MissionUpdateOneRequiredWithoutDinerMissionsNestedInput
    missionClearLogs?: MissionClearLogUpdateManyWithoutDinerMissionNestedInput
  }

  export type DinerMissionUncheckedUpdateWithoutDinerInput = {
    id?: IntFieldUpdateOperationsInput | number
    missionId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missionClearLogs?: MissionClearLogUncheckedUpdateManyWithoutDinerMissionNestedInput
  }

  export type DinerMissionUncheckedUpdateManyWithoutDinerInput = {
    id?: IntFieldUpdateOperationsInput | number
    missionId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewUpdateWithoutDinerInput = {
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutDinerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutDinerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DinerMissionCreateManyMissionInput = {
    id?: number
    dinerId: number
    startDate: Date | string
    endDate?: Date | string | null
  }

  export type DinerMissionUpdateWithoutMissionInput = {
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    diner?: DinerUpdateOneRequiredWithoutDinerMissionsNestedInput
    missionClearLogs?: MissionClearLogUpdateManyWithoutDinerMissionNestedInput
  }

  export type DinerMissionUncheckedUpdateWithoutMissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    dinerId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    missionClearLogs?: MissionClearLogUncheckedUpdateManyWithoutDinerMissionNestedInput
  }

  export type DinerMissionUncheckedUpdateManyWithoutMissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    dinerId?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MissionClearLogCreateManyDinerMissionInput = {
    id?: number
    userId: number
    pointHistoryId?: number | null
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type MissionClearLogUpdateWithoutDinerMissionInput = {
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMissionClearLogsNestedInput
    pointHistory?: PointHistoryUpdateOneWithoutMissionClearLogsNestedInput
  }

  export type MissionClearLogUncheckedUpdateWithoutDinerMissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    pointHistoryId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MissionClearLogUncheckedUpdateManyWithoutDinerMissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    pointHistoryId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MissionClearLogCreateManyPointHistoryInput = {
    id?: number
    userId: number
    dinerMissionId: number
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type MissionClearLogUpdateWithoutPointHistoryInput = {
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutMissionClearLogsNestedInput
    dinerMission?: DinerMissionUpdateOneRequiredWithoutMissionClearLogsNestedInput
  }

  export type MissionClearLogUncheckedUpdateWithoutPointHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    dinerMissionId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MissionClearLogUncheckedUpdateManyWithoutPointHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    dinerMissionId?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}